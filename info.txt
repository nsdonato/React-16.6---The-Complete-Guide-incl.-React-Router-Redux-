
# Section 1: Getting Started

    1. Welcome To The Course!
        ...

    2. What is React.js?
        Que, como y porque:

        Una /libreria de JavaScript/ para crear interfaces de usuario (Componentes)

        - Basicamente, se crean aplicaciones Javascript, que corren en el navegador, no corren en el servidor. No tenemos que esperar una respuesta del servidor para obtener una nueva página o para renderizar algo nuevo.

        - User interface: Interfaz de usuario, es lo que el usuario puede ver. Con React construimos componentes, para la interfaz de usuario, que a su vez, se pueden reutilizar.

        Joining it is of course free and 100% optional.

    3. Why React Instead Of "Just JavaScript"?
        
        https://github.com/academind/react-complete-guide-code/tree/01-getting-started/code/
        react-vs-vanilla-js-example

        Porque tendríamos que repetir código y con react creamos componentes y reutilizamos lso mismos.

    4. Building Single-Page Applications (SPAs) with React
        
        React puede ser usado para controlar partes de una pagina html o la pagina entera
            "Widget" approach on a multi-page-application, algunas paginas siguen siendo renderizadas y servidas por un servidir backend.

        React también puede ser usado para controlar una frontend entero o una app web.
            "SPA" approach. El servidor envia solamente UN HTML y toma control de la UI.

    5. Exploring React.js Alternatives (Angular / Vue)

        Angular 
            Te sirve para enforcarte en la logica y en el modelo de negocio, y no tanto en el aspecto del elemento en particular que querías cambiar (como en react). Podrian no convenir para proyectos pequeños ya que encima tenes que saber TypeScript.

        Vue.js
            Complete component based UI fw, incluye most core features. Menos popu que react y angular.

    6. Join our Online Learning Community

        Join our Online Learning Community
        As a student of this course you also get free access to our "Academind Community" on Discord: https://academind.com/community/

        There, you can find like-minded people, discuss issues, help each other, share progress, successes and ideas and simply have a good time!

        I believe that you learn the most if you don't learn alone but find learning partners and other people with similar interests. Our community is a great place for this - it's the perfect complimentary resource for this course.

        Joining it is of course free and 100% optional.

    7. About This Course & Course Outline
        ...

    8. The Two Ways (Paths) Of Taking This Course
        Standar (recomendado)   
            Arrancar por el principio, skipear el javascript refresher si no lo necesitas, mirar los summary para refrescar lo que aprendiste.

        Enfoque resumido:
            saltear el modulo de resumen
            opcional tomar el refresher de js
            mirar todo el curso antes que los summary
        
    9. Getting The Most Out Of This Course
        Te recomienda como ver el curso para sacarle jugo..

    10. Setting Up The Course Dev Environment (Code Editor)
        Instala VS Code

# Sección 2: - Refreshing Next Generation JavaScript (Optional)

    11. Module Introduction
        Next-Gen Javascript, para refrescar. React usa esto, así que, hay que saberlo.

    12. Understanding "let" and "const" - 

        let = var (cambia el tema del scope, porque ahora es de bloque.)
        const = para info que no va a cambiar.

    13. Arrow Functions - 

        funciones antes:
            function myFuncion() {
                ...
            }

        funciones ahora:
            const myFuncion = () => {
                ...
            }

        * Arrow functions, mejoran el problema de que this, no siempre apuntaba al contexto de ejecución, sino al objeto global.
        * Si no tiene parametros, va solo parentesis
        * Si tiene uno, es param =>
        * Si tiene mas de uno, es (param1,param2) =>
        * Si la parte de retorno solo tiene una linea, se puede escribir así: const multiplicar = number => number * 2;

    14. Exports and Imports - 

        Para modular el código, para dividir los archivos js en varios archivos.
            Si bien ya se puede (porque agregas diferentes archivos en el html, de manera ordenada)
            Ahora desde un js, se puede usar info de otro js.

        EXPORTAR
            person.js
                const person = {
                    name: 'Max'
                }
                export default person

                // export: sirve para exportar esa función, objeto, etc, desde un archivo.
                // default: que esa funcion, obj, etc, va a ser la predeterminada.
                // person: en este caso es el objeto

            utility.js
                export const clean = () => { ... }
                export const baseData = 10;

        IMPORTAR
            app.js
                // Se pone de alguna de las dos maneras, ya que hace referencia a lo único que se exporto (default)

                    import person from './person.js'
                    import prs from './person.js'

                // Al ser exportada como diferentes constantes, se usa las { }  para "mejorar el codigo", diciendo que se esta exportando algo especifico
                // Tiene que respetar el nombre que se le puso en el archivo donde se la exporta obj
                // se puede ponerle un alias, como en la segunda linea

                    import { baseData } from './utility.js'
                    import { baseData as bd } from './utility.js'

                // También se podría hacer de esta manera.

                    import { baseData, clean } from './utility.js'

    15. Understanding Classes - 

        - Los metodos son como: funciones atachados a esa clase/objetos,
        - las propiedades son como: variables, atachadas a esa clase/objetos,

        class Human {
            constructor(){
                this.gender = 'male';
            }

            printGender(){
                consoe.log(this.gender);
            }
        }

        // Herencia
        class Person extends Human{
            constructor(){
                super();
                this.name = 'Max';
                this.gender = 'female'; // pero no es correcto usar así.
            }

            printMyname (){
                console.log(this.name);
            }
        }

        // Instanciar un objeto de esa clase.
        const miPersona = new Person();
        miPersona.printMyname();
        miPersona.printGender();

    16. Classes, Properties and Methods - 

        ES6
        Propiedades:
            constructor() {
                this.myProperty = 'value'
            }

        Metodos:
            miMetodo () {
                ...
            }

        ES7
        Propiedades:
            myProperty = 'value'; // Si, no hay un "constructor" en si.

        Metodos:
            miMetodo = () => {
                ...
            }

        * Es mejor usar ambos opciones de ES7, para esto si o si hay que usar ES6/Babel, que transpila el código y lo convierte.

    17. The Spread & Rest Operator - 

        // Operator Spread o Rest (depende de donde se use)
        ...

        Spread: (división de las propiedades de un objeto o un array.)

                Se usa para dividir elementos de un array o propiedades de un objeto.
                Por ejemplo, si tenemos una matriz antigua y queremos agregar todos los elementos de esa matriz anterior a una nueva matriz y,
                además, agregar un 1 en un elemento dos, este primer índice sería lo que tenía tres puntos delante
                de toda la matriz. simplemente extraiga todos los elementos y agregue a la nueva matriz que
                creamos con corchetes.

                // Idem object pero array
                    const oldArray = [3,4,5];
                    const newArray = [...oldArray,1,2];
                    console.log(newArray);
                    // 3,4,5,1,2

                // Lo probé, lo que hace es agarrar las propiedades/funciones del objeto viejo, y ponerselo al nuevo y suma la nueva prop/func.
                const oldObject = {
                    name: "Noe";
                }

                const newObject = { ...oldObject, newProp: 5 }
                console.log(newO)

        Rest: (Fusión de elementos en un array)

            Se utiliza con menos frecuencia.

            Se usa para mergear una lista de argumentos de funciones en una matriz.
            O sea, lo usamos en el parametro de una función. ej:

            // Recibe una lista ilimitada de argumentos, y todos se fusionan en un array.
            // O sea, en vez de dividir, los une.

            function sortArgs(...args){
                return args.sort[];
            }

            sortArgs(1,2,3,4,5);

        * Hay que tener en cuenta que si el numero o propiedad / funcion, ya existia en el objeto actual, lo sobreescribe.

        array.filter()  // ejecuta una función en cada elemento de la matriz y se verifica si existe un elemento en ella, ej:
        const filter = (...args) => {
            return args.filter(el => el === 1);
        }

        console.log(filter(1,2,3));
        // [1]

    18. Destructuring - 

        Permite extraer facilmente elementos de una matriz o propiedades de objetos y guardarlos en variables.
        ej:

        array:
            [nombre, apellido] = ['Noe','Donato'];
            console.log(nombre); // Noe
            console.log(apellido); // Donato

            const numbers = [1,2,3];
            [num1, num2] = numbers;
            console.log(num1,num2); // 1 2

            [num1, ,num3] = numbers;
            console.log(num1,num3); // 1 3

        object:
            { name } = { name: 'Noe', age: '32' };
            console.log(name); // Noe
            console.log(age); // undefined

    19. Reference and Primitive Types Refresher - 

        Primitivos
        * Copia el valor de su variable en otra, osea hay 2.
        number, boolean, string

        Referencia
        * No copia, sino que hace referencia al puntero en memoria del otro objeto.
        Object, arrays.

            const person = {
                name: 'Max'
            };
            const secPerson = person;
            person.name = 'Manu';

            console.log(secPerson); // 'Manu'

        Para copiar un objeto, o sea generar uno nuevo, deberíamoshacer:
            const person = {
                name: 'Max'
            };
            const secPerson = {
                ...person
            };
            person.name = 'Manu';

            console.log(secPerson); // 'Max'

    20. Refreshing Array Functions - 

        const numbers = [1,2,3];

        // La función se va a ejecutar por cada elemento
        // Al parametro le ponemos num, porque esta recorriendo numeros, como para ser claros.
        const numbers = [1,2,3];
        const doubleNumArray = numbers.map((num) => num * 2 );
        console.log(doubleNumArray); // [2,4,6]

    21. Wrap Up

        Basicamente que cualquier cosa, se puede volver a esas clases para refrescar por si te olvidaste algo.

    22. Next-Gen Javascript - Summary
        In this module, I provided a brief introduction into some core next-gen JavaScript features, of course focusing on the ones you'll see the most in this course. Here's a quick summary!

        let & const
        Read more about let : https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let

        Read more about const : https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const

        let  and const  basically replace var . You use let  instead of var  and const  instead of var  if you plan on never re-assigning this "variable" (effectively turning it into a constant therefore).

        ES6 Arrow Functions
        Read more: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions

        Arrow functions are a different way of creating functions in JavaScript. Besides a shorter syntax, they offer advantages when it comes to keeping the scope of the this  keyword (see here).

        Arrow function syntax may look strange but it's actually simple.

        function callMe(name) { 
            console.log(name);
        }
        which you could also write as:

        const callMe = function(name) { 
            console.log(name);
        }
        becomes: 

        const callMe = (name) => { 
            console.log(name);
        }
        Important: 

        When having no arguments, you have to use empty parentheses in the function declaration:

        const callMe = () => { 
            console.log('Max!');
        }
        When having exactly one argument, you may omit the parentheses:

        const callMe = name => { 
            console.log(name);
        }
        When just returning a value, you can use the following shortcut:

        const returnMe = name => name
        That's equal to:

        const returnMe = name => { 
            return name;
        }
        Exports & Imports
        In React projects (and actually in all modern JavaScript projects), you split your code across multiple JavaScript files - so-called modules. You do this, to keep each file/ module focused and manageable.

        To still access functionality in another file, you need export  (to make it available) and import  (to get access) statements.

        You got two different types of exports: default (unnamed) and named exports:

        default => export default ...; 

        named => export const someData = ...; 

        You can import default exports like this:

        import someNameOfYourChoice from './path/to/file.js'; 

        Surprisingly, someNameOfYourChoice  is totally up to you.

        Named exports have to be imported by their name:

        import { someData } from './path/to/file.js'; 

        A file can only contain one default and an unlimited amount of named exports. You can also mix the one default with any amount of named exports in one and the same file.

        When importing named exports, you can also import all named exports at once with the following syntax:

        import * as upToYou from './path/to/file.js'; 

        upToYou  is - well - up to you and simply bundles all exported variables/functions in one JavaScript object. For example, if you export const someData = ...  (/path/to/file.js ) you can access it on upToYou  like this: upToYou.someData .

        Classes
        Classes are a feature which basically replace constructor functions and prototypes. You can define blueprints for JavaScript objects with them. 

        Like this:

        class Person {
            constructor () {
                this.name = 'Max';
            }
        }
        
        const person = new Person();
        console.log(person.name); // prints 'Max'
        In the above example, not only the class but also a property of that class (=> name ) is defined. The syntax you see there, is the "old" syntax for defining properties. In modern JavaScript projects (as the one used in this course), you can use the following, more convenient way of defining class properties:

        class Person {
            name = 'Max';
        }
        
        const person = new Person();
        console.log(person.name); // prints 'Max'
        You can also define methods. Either like this:

        class Person {
            name = 'Max';
            printMyName () {
                console.log(this.name); // this is required to refer to the class!
            }
        }
        
        const person = new Person();
        person.printMyName();
        Or like this:

        class Person {
            name = 'Max';
            printMyName = () => {
                console.log(this.name);
            }
        }
        
        const person = new Person();
        person.printMyName();
        The second approach has the same advantage as all arrow functions have: The this  keyword doesn't change its reference.

        You can also use inheritance when using classes:

        class Human {
            species = 'human';
        }
        
        class Person extends Human {
            name = 'Max';
            printMyName = () => {
                console.log(this.name);
            }
        }
        
        const person = new Person();
        person.printMyName();
        console.log(person.species); // prints 'human'
        Spread & Rest Operator
        The spread and rest operators actually use the same syntax: ... 

        Yes, that is the operator - just three dots. It's usage determines whether you're using it as the spread or rest operator.

        Using the Spread Operator:

        The spread operator allows you to pull elements out of an array (=> split the array into a list of its elements) or pull the properties out of an object. Here are two examples:

        const oldArray = [1, 2, 3];
        const newArray = [...oldArray, 4, 5]; // This now is [1, 2, 3, 4, 5];
        Here's the spread operator used on an object:

        const oldObject = {
            name: 'Max'
        };
        const newObject = {
            ...oldObject,
            age: 28
        };
        newObject  would then be

        {
            name: 'Max',
            age: 28
        }
        The spread operator is extremely useful for cloning arrays and objects. Since both are reference types (and not primitives), copying them safely (i.e. preventing future mutation of the copied original) can be tricky. With the spread operator you have an easy way of creating a (shallow!) clone of the object or array. 

        Destructuring
        Destructuring allows you to easily access the values of arrays or objects and assign them to variables.

        Here's an example for an array:

        const array = [1, 2, 3];
        const [a, b] = array;
        console.log(a); // prints 1
        console.log(b); // prints 2
        console.log(array); // prints [1, 2, 3]
        And here for an object:

        const myObj = {
            name: 'Max',
            age: 28
        }
        const {name} = myObj;
        console.log(name); // prints 'Max'
        console.log(age); // prints undefined
        console.log(myObj); // prints {name: 'Max', age: 28}
        Destructuring is very useful when working with function arguments. Consider this example:

        const printName = (personObj) => {
            console.log(personObj.name);
        }
        printName({name: 'Max', age: 28}); // prints 'Max'
        Here, we only want to print the name in the function but we pass a complete person object to the function. Of course this is no issue but it forces us to call personObj.name inside of our function. We can condense this code with destructuring:

        const printName = ({name}) => {
            console.log(name);
        }
        printName({name: 'Max', age: 28}); // prints 'Max')
        We get the same result as above but we save some code. By destructuring, we simply pull out the name  property and store it in a variable/ argument named name  which we then can use in the function body.

        Resources for this lecture
        next-gen-js-summary.pdf

    23. JS Array Functions
        En realidad, no la próxima generación de JavaScript, pero también es importante: un arreglo de funciones de JavaScript, como map() , filter() , reduce()  etc.
        Me verás usarlos bastante ya que muchos conceptos de React se basan en trabajar con arreglos (de manera inmutable).

        La siguiente página ofrece una buena descripción general de los diversos métodos que puede utilizar en el prototipo de matriz. No dude en hacer clic en ellos y actualizar sus conocimientos según sea necesario:
            https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array

        Particularmente importantes en este curso son:

        map()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
        find()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
        findIndex()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
        filter()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
        reduce()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce?v=b
        concat()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat?v=b
        slice()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice
        splice()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice

# Section 3: React Basics & Working With Components

    24. Module Introduction
        ...

    25. What Are Components? And Why Is React All About Them?
        React crea interfaces simples itneractivas y reactivas al usuario.
        
        Componentes: son una composición de html, css y js son reusables. todos los componentes unidos forman una interface de usuarios.

        Porque componentes?
        Reusabilidad:
            DRY 
        Separation of Concerns: 
            No hacer demsiasdo en una sola función. Separarlos en funciones mas chicas.

    26. React Code Is Written In A "Declarative Way"!

        Como se construye un componente? 
            html, css y js
                aunque css no es principalmente lo importante, sino html y js
            
        Declarative approach: que react no le va a decir a react que un html fue creado.
        defina el estado de destino deseado y deje que React descubra las instrucciones DOM de JavaScript reales

    27. Creating a new React Project
        https://github.com/academind/react-complete-guide-code/tree/03-react-basics-working-with-components/code

        new_resources/01-starting-setup.zip

        npm start -> arrancar la app
        ctrl+c -> cancelar la ejecución.

    28. The Starting Project
        In case you skipped the previous lecture, attached you find the starting project snapshot.

        Download it

        Extract it

        run npm install in the extracted folder

        Run npm start to start the development server.

        Resources for this lecture
        01-starting-setup.zip
        Section Code Snapshots

    29. Analyzing a Standard React Project
        index.js es el primer archivo que se ejecuta.

        ambas son parte de la misma libreria, pero se separan las responsabilidades en dos package diferentes.
            react 
            react-dom 

        index.js
            import React from 'react';
            import ReactDOM from 'react-dom';
            import './index.css';
            import App from './App';
            import * as serviceWorker from './serviceWorker';

            // Siempre vamos a tener un elemento donde van a estar todos los componentes
            // y que lo vamos a renderizar en un id x ej root. 
            ReactDOM.render(<App />, document.getElementById('root'));

        app.js
            import React, { Component } from 'react';
            import './App.css';

            class App extends Component {
                render() {
                    return (
                        <div className="App">
                            <h1>Hola, soy una App React</h1>
                        </div>
                    );
                }
            }

            export default App;

        - Para definir un componente, hay 2 maneras.
            1)
                1.1) Creamos una clase y lo hacemos heredar de Component,

                    que se importa de la libreria de react.
                    React, se importa porque es necesario para renderizar el componente y el objeto componente.

                1.2) el metodo render()
                        sirve para renderizar JSX en la pantalla.

            2) crear una función.
        
        * Por lo general cuando se elige el nombre de un componente, se usa ese nombre para la variable a importar, para el archivo y para el elemento.
        * Los archivos también podrían llamarse JSX, pero se usa js por convención.
            JSX en realidad es lo que llaman "syntactic sugar". Es una sintaxis dentro de un lenguaje de programación, diseñado para ser mas facil de leer o expresarse.
            Es como "mas dulce para que lo pueda usar una persona"

    30. Introducing JSX

        Javascript Xml -> es el standar
        es html con js

        son archivos con codigo transformado, ya que jsx no es soportado en los browsers.
            0.chunk.js
            bundle.js
            main.chunk.js      
        
    31. How React Works
        Creamos nuestros propios componentes html.

        Imperative instructions son las que se usan en js normal.
        En react es declarative way.

    32. Building a First Custom Component
        BEST PRACTICE: new components -> new files.

        root, es nuestro main container.

        React tiene su tree, que parte desde App

        crea:
            components/
                ExpenseItems.js -> convensión Pascal Case

                La gran mayor cantidad de tiempo los componentes se crean como el de app, pero por lo general son solo funciones.

        Para crear un componente entonces (que no derive de Component):
            Generamos una función.
            La exportamos como default.
            Retornamos JSX

        Para usar en nuestro component App:
            Importamos el componente.
            Dentro del html que estamos retornando, agregamos el tag con nuestro componente.

        <ExpenseItems /> // lo podemos dejar así ya que no tenemos que anidar nada adentro.

    33. Writing More Complex JSX Code
        - Como en realidad el html que vemos es JSX, no podemos usar palabras reservadas como class, debemos en este caso, por ej usar className, en el elemento.

        - No podemos devolver elementos que no tienen un padre. Por ej, no podemos poner un elemento hermano al div root.

        - Es buena practica, es meter todo dentro de un contenedor a devolver.

    34. Adding Basic CSS Styling
        https://github.com/academind/react-complete-guide-code/blob/03-react-basics-working-with-components/extra-files/ExpenseItem.css

        bajarse el archivo y ponerlo en la misma ruta que el js e importarlo.

        Tener en cuenta que no se puede usar class, ya que es una palabra reservada, por ende hay que usar className, al igual que for, es htmlFor, etc...

    35. Outputting Dynamic Data & Working with Expressions in JSX
        Para que el js, no sea interpretada como texto, se debe usar {js que quiera}

            return <p>Soy una persona and I am {Math.floor(Math.random() * 30)} years old! </p>

        Esto se usa para simples calculos o llamadas a funciones, pero nada mas, debería ser solo una linea de codigo

        En la actualización da un ejemplo creando una variable fecha y actualizando en el código donde estaba hardcoding.

    36. Passing Data via "props"
        Dejo el ejemplo viejo, en el nuevo lo explica lo mismo con <ExpensiveItems />
        https://github.com/academind/react-complete-guide-code/blob/03-react-basics-working-with-components/extra-files/expenses.txt

        Trabajar componentes en archivos separados, hace que el codigo sea mas mantenible.
        Aparte se lo puede configurar y reutilizar.
        return (
            <div className="App">
            <h1>Hola, soy una App React</h1>
            <Person />
            <Person />
            <Person />
            </div>
        );

         return (
            <div className="App">
            <h1>Hola, soy una App React</h1>
            <Person name="Max" age="28"/>
            <Person name="Manu" age="29"/>
            <Person name="Noe" age="32"/>
            </div>
        );

        Del componente principal, se le pasa al componente que corresponde el valor de las propiedades, name y age en este ejemplo.

        Person.js
            #IMPORTANTE:
            El argumento es un objeto con toda la info que se le pasa al componente, se puede llamar props, como se puede llamar pepito.

            const person = (props) => {
                return <p>Hola! Soy {props.name} y tengo {props.age} años! </p>
            }

        Cuanto se usa en una clase-componente (como app), se tiene que usar this.props

    37. Adding "normal" JavaScript Logic to Components
        crea diferentes variables y utiliza funciones propias de js, que usa en el código jsx.

    38. Splitting Components Into Multiple Components
        Crea un segundo componente ExpenseDate.js pone lo referido a las fechas ahí y lo importa en ExpenseItem.js apare ahora se puede reutilizar en cualquier parte de la app.

        Al componente le pasa las props necesarias para que funcione.
        
        Importa un css a ExpenseDate: https://github.com/academind/react-complete-guide-code/blob/03-react-basics-working-with-components/extra-files/ExpenseDate.css

    Assignment 1: Time to Practice: React & Component Basics
        TODO: después hago esta tarea nueva..

    39. The Concept of "Composition" ("children props")
        Explicación vieja, en lo nuevo explica lo mismo pero crando una card y en props usa la prop children.

        Si queremos pasar algo entre la etiqueta de apertura y cierre, tenemos que envolver eso en un elemento padre y usar children.

        <div className="App">
            <h1>Hola, soy una App React</h1>
            <Person name="Max" age="28"/>
            <Person name="Manu" age="29">My hobbies: Racing</Person>
            <Person name="Noe" age="32"/>
        </div>

        Person.js
         <div>
            <p>I'm {props.name} and I am {props.age} years old!</p>
            <p>{props.children}</p>
         </div>

    40. A First Summary
        TODO: Lo veo a lo último del curso.

    41. A Closer Look At JSX
        En las nuevas versiones de react, no es necesario importar React. React lo utiliza under the hood.

        Explicación vieja, que aplica a esta sección.
        Componente basado en clase:
        class App extends Component {
            render() {
                // Podemos usar el objeto de React para crear un elemento.
                // createElement, toma infinitos argumentos, pero el primero es o un elemento o un componente.
                // 2 arg: puede ser un objeto, aunque es opcional, por lo tanto pasamos null
                // 3 arg, los hijos: a partir de ese, van separados por comas, y basicamente s todo lo que va a ir, adentro del primer arg, el div en este caso.
                    1 linea: como el comportamiento por default es tomar todo por texto, va a imprimir en pantalla, h1Iamreactapp,
                    2 lines: así que hay que usar otro react.createelement...
                    3 linea: Para pasarle estilo

                //return React.createElement('div', null, 'h1','I\'m a React App!!!!');
                //return React.createElement('div', null, React.createElement('h1',null,'I\'m a React App!!!!'));
                return React.createElement('div', { className: 'App'}, React.createElement('h1',null,'I\'m a React App!!!!'));

            }
        }

        * NO SE USA CREAR LOS ELEMENTOS ASÍ, es para que sepamos que existe esto y no es lo correcto.
        Para eso se genera el "HTML, que en realidad es JSX" = javascript.

    42. Organizing Component Files
        components/
            Expenses/
                ExpenseDate.js
                ExpenseDate.css
                ExpenseItem.js
            UI -> interfaces elements

        Siempre igual depende de vos o el equipo en el que trabajes.

    43. An Alternative Function Syntax
        Muestra como cambiar de function ExpensiveDate a arrow functions ...

    Quiz 1: Learning Check: React Basics, Components, Props & JSX
        TODO: lo hago a lo ultimo

    44. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).

        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/03-react-basics-working-with-components

        Usage instructions can be found on the page that link is leading to.

        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.

        You also find section slides (if available) in that Github repository.

# Section 4: React State & Working with Events

    45. Module Introduction
        ...

    46. Listening to Events & Working with Event Handlers
        React expone eventos que arrancan con on
        onClick, onChange, etc..

        Explicación vieja, en la nueva lo hace sobre un boton de ExpenseItem:
            // en JSX es con la C mayus. 
            <button onClick=>Cambiar de nombre</button>

            es buena practica ponerle al final Handler, a la función que haga de handler.

            switchNameHanlder = () => {
                console.log("click");
            }

            a la función no hay que ponerle los () para que no lo llame en ese mismo momento.

            <button onClick={this.switchNameHanlder}>Cambiar de nombre</button>

    47. How Component Functions Are Executed
        Tu componente es una función regular que retorna JSX, cuando el componente se utiliza en algun lugar de la pagina se llama al mismo como si fuera una función, verifica todas las funciones que hay que ejecutar hasta que termina renderizando el componente.

        React no repite todo eso, lo hace solo cuando renderiza toda la pagina por primera vez, por lo que para que reevalue algo que cambio, se utiliza el state.

    48. Working with "State"
        Explicación nueva para functional components:
            import React, { useState } from 'react' -> es una función (hook) que provee React que nos habilita encontrar valores como estado, que cuando cambian esos valores, debe reflejar en la functional component.
            
            Se coloca dentro de la función del componente:
            Los hooks solo van dentro de la functionals components.
            Todos arrancan con useXxxx

            const ExpensiveItem = (props) => {
                
                // const [valor, functionQueUpdateaElstado] = useState(valorInicial, puede ser obj, arrat, variable, etc..)
                
                const [title,setTitle] = useState(props.title) 

                const clickHandler = () => {
                    setTitle('updated') // es manejado por react en algun lugar de la memoria, actualiza la variable title. re-renderiza el componente, ya que re-evalua todo el jsx de la función y actualiza solo lo necesario
                }
            }
        

        Explicación vieja:

        Hasta React 16.8 setState era la unica manera de manejar estados en las aplicaciones de React.

        Ahora hay una característica llamada React Hooks, se utiliza mas que nada en los componentes de funciones.

        IMPORTANTE: El va a seguir enseñando la manera tradicional (clases basadas en componentes) porque en las compañias ya tienen proyectos hechos basados en esto.

        Si bien desde React 16.8 podemos usar componentes funcionales para todo, vamos a mantenernos en las clases basadas en componentes, porque el dice que en los laburos se usa mas eso.

        "react hooks"
            Es una colección de funciones expuestas por React para que puedas en componentes funcionales y demás, una de ellas es useState.

            Cambia el componente app por uno funcional o sea,
                const app = props => {
                    useState({
                        mete el array de persons
                    });

                    return() { JSX }
                }

            Este es un componente funcional normal, pero ahora puede usar la función de "react hooks" o una de las funciones de React.
            --> Para eso hay que importarlo:  import React, { useState } from 'react' (React ya lo teníamos, solo agregamos { useState })

            UseState:
                Devuelve una matriz con exactamente dos elementos y siempre dos elementos que son importantes.

                    // Usamos destructuración [ param1, param 2] , lo que hace que useState ponga la info en donde corresponda.
                    const [ currentState, updateCurrentState ] = useState({});

                    1) Ahora el primer elemento que recibimos siempre será nuestro estado actual.
                    2) El segundo elemento en la matriz de estado siempre será una función que nos permita actualice este estado para que react lo sepa y volverá a procesar este componente
                        IMPORTANTE: La 2da función no mergea los cambios, pisa el objeto con el nuevo estado.

                    3) Si estabamos usando this.state ahora debemos cambiarlo por currentState

            <button>Cambiar de nombre</button>

            state:
                - SOLO SE PUEDE USAR: En las clases-componentes
                - es una propiedad especial, donde se establecen y pasan props desde afuera como name, age etc, y que se gestionan dentro del componente.
                    Si cambiamos algo que use esta propiedad, va a renderizar nuevamente el dom/componente.

                Se inicializa como un objeto.
                    state = {}
                Se le pueden agregar, array objetos:
                    state = {
                        persons: [
                            { name: 'Noe', age: 32 },
                            { name: 'Gia', age: 29 },
                            { name: 'Nany', age: 33 },
                        ]
                    }

                Una vez que hacemos esto, la podemos usar en nuestro metodo dinamico.

                <div className="App">
                <h1>Hola, soy una App React</h1>
                <button>Cambiar de nombre</button>
                <Person name={this.state.persons[0].name} age={this.state.persons[0].age}/>
                <Person name={this.state.persons[1].name} age={this.state.persons[1].age}>My hobbies: Racing</Person>
                <Person name={this.state.persons[2].name} age={this.state.persons[2].age}/>
                </div>

                props.children mostraría por ej en el componente Person "My hobbies: Racing"

            this, hace referencia a la clase donde se esta usando

    49. A Closer Look at the "useState" Hook
        Cada State es unico en cuanto a su componente, por ejemplo en una lista, si aprestas un botno especifico que actualiza un texto de su row, es de esa row el cambio no de todos.

        si hay 4 rows en la primera renderizada, va a haber 4 renderizados, en la segunda por ej a un click, solo uno.

        Cuando se renderiza el componente, react en primera instancia guardo los estados que pudiera haberse inicializado y en los demás, solo actualiza aquel que realmente se haya actualizado.

    50. State can be updated in many ways!
        Thus far, we update our state upon user events (e.g. upon a click).

        That's very common but not required for state updates! You can update states for whatever reason you may have.

        Later in the course, we'll see Http requests that complete (where we then want to update the state based on the Http response we got back) but you could also be updating state because a timer (set with setTimeout()) expired for example.

    51. Adding Form Inputs
        https://github.com/academind/react-complete-guide-code/blob/04-react-state-events/extra-files/ExpenseForm.css
        https://github.com/academind/react-complete-guide-code/blob/04-react-state-events/extra-files/NewExpense.css

        genera el form y los inputs..

    52. Listening to User Input
        pone un onChange en un input, explica como setear el estado desde la función que handlea el evento.

        event.target.value

        Explicación vieja para class components:
            switchNameHanlder = () => {
                // No hay que mutar de esta manera (cambiar de estado), va a dar un error.
                //this.state.persons[0].name = 'Noelia';
                this.setState({
                    persons: [
                        { name: 'Noeñs', age: 32 },
                        { name: 'Gabuns', age: 29 },
                        { name: 'Nanys', age: 33 },
                    ]
                )
            }

            setState:
                Esta disponible solo en clases basadas en componentes.

                Este es un método que nos permite actualizar esta propiedad state, después
                nos aseguramos de que react conozca como la actualización y react actualice el DOM.

                // Toma un objeto como argumento y fusionara (sobreescribe) eso con nuestro estado actual
                switchNameHanlder = () => {
                    this.setState({
                        persons: [
                            { name: 'Noels', age: 32 },
                            { name: 'Gabuns', age: 29 },
                            { name: 'Nanys', age: 33 },
                        ]
                    })
                }

                * Solo se pueden cambiar props y state

    53. Working with Multiple States
        const [title,setTitle] = useState(props.title) 
        const [name,setName] = useState(props.name) 
        const [lastName,setLastName] = useState(props.lastName) 

    54. Using One State Instead (And What's Better)
        const [data,setData] = useState({
            name: props.name,
            lastName: props.lastName,
            title: props.title
        }) 

        Para no perder los estados ahora que estan unificados, React mergea estos, utilizando el setState de esta manera:

        spread operator sirve para copiar lo que había en el estado actual, y después pisamos solo lo que queremos actualizar

        setData({...data, name: 'nuevo nombre'})

    55. Updating State That Depends On The Previous State
        Cuando actualizamos el estado como antes, es una mejor practica, hacer esto:

        recibe el snaptshoot previo, 
            setData((prevState) => {}, {
                return {
                    ...prevState, 
                    title: 'nuevo titulo'
                }
            })
        
        Dice que si usas el primer approach, y estás actualizando varios estados, podes llegar a tener un estadio "desactualizado". De la otra manera, React garantiza que siempre sera el último snaptshoot y que va a estar correctamente actualizado.

        Esto siempre usarlo si tu state update depende del estado previo, sino no es necesario.

        De todas maneras el se va a manejar con estados separados porque prefiere ese approach.

    56. Handling Form Submission
        La mejor manera de handlear el submit no es poner el handler en el submit, sino en el onSubmit de la etiqueta form.

        Como el form esta preparado par que al submitir envie información a un backend, x ej, hay que hacer si o si preventDefault para evitar esto.

    57. Adding Two-Way Binding
        Significa que va a estar bindeado de dos maneras, porque, el input en este caso, handlea el evento que cambia el estado y a la vez utiliza la propiedad actualizada en dicho estado.

        Una vez que se submite, hay que limpiar los inputs, reinicializando sus estados a vacio.

    58. Child-to-Parent Component Communication (Bottom-up)
        Explica como hacer un handler de saveExpenses por ejemplo, desde un padre, a un hijo y que el hijo setee el estado del padre mediante la función, entonces por ej.

        App 
            handlerAddExpense
                <NewExpense onAddExpense={handlerAddExpense} />
                    dentro de NewExpense tiene la funcion para guardar y se la pasa al hijo
                    handlerSaveExpense
                    <ExpenseForm onSaveExpense={handlerSaveExpense} />
                        este setea el estado y lo "levanta"

        Explicación vieja para class components:
            en el padre, al hijo embebido, le generamos un atributo donde le podemos pasar un metodo, entonces en el archivo del hijo, usando prop podemos utilizarlo.

            o sea, el hijo termina usando un metodo que esta en el padre.

            Si necesitamos pasar parametros hay que usar bind.

            this.metodo.bind(this, param)

            si en vez de usar esa manera, usamos una funcion de flecha anonima, tenemos que tener en cuenta que cuando escribimos la función en una linea:
                onClick={() => this.metodo()}

                adelante del this, si bien no lo pone, hay un RETURN.

            Idealmente es mejor usar bind, porque la función anonima es ineficiente.

    59. Lifting The State Up
        "levantando el estado"

        basicamente el punto anterior, pasar el estado del hijo al padre.

    Assignment 2: Time to Practice: Working with Events & State
        TODO:

    60. Controlled vs Uncontrolled Components & Stateless vs Stateful Co…60. Controlled vs Uncontrolled Components & Stateless vs Stateful Components

        Functional (Stateless) vs class (Stateful) Components
        La mayoria de las veces vamos a usar funciones stateless, las que reciben props.

        La mayor parte de la app, no debería cambiar el estado de la aplicación, se supone que solo va a cambiar en ciertos componentes,
            conocidos como "contenedores" Statefull Components. ej app.js
            
    Quiz 2: Learning Check: Working with Events & State
        TODO:

    61. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).

        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/04-react-state-events

        Usage instructions can be found on the page that link is leading to.

        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.

        You also find section slides (if available) in that Github repository.

# Section 5: Rendering Lists & Conditional Content

    62. Module Introduction
        ...

    63. Rendering Lists of Data

        Explicación vieja, aplica acá igual...
                .map mapea elementos en un array dado (en este caso "elArray"), ejecuta un metodo en cada elemento del array
            el metodo/funcion, es pasado a mapa dentor de los ().
            - .map retorna un nuevo array, react lo que intenta hacer al retornarlo es renderizarlo otra vez en el DOM (si es un JSX valido)

        esa función que se le pasa a map, se ejecuta en cada elemento del array.
        map tiene un segundo parametro que es el index del elemento.

        {this.state.elArray.map(elementoDelArray => {
            // Lo que quiero mapear dentro de cada elemento.
            return <Person name="person.name" age="person.age" />;                                    
        })}

    64. Using Stateful Lists


        Explicación vieja:

        deletePersonHandler = (personIndex) => {
            const persons = this.state.persons; // Me guardo el array de personas.
            persons.splice(personIndex, 1); // Splice, sirve para eliminar elementos del array, acá le decimos que elimine 1 solo, y un index en particular.
            this.setState({persons: persons})
        }

        {this.state.elArray.map( ( elementoDelArray, index ) => {
            return <Person click={this.deletePersonHandler} name="person.name" age="person.age" />;
        })}

    65. Understanding "Keys"
        React actualiza todos los elementos y los reordena cuando no tiene una key, porque no sabe bien que actualizar, hasta podría perderse información, se soluciona agregandole una key a lo elementos jsx.
        en key o usamos un id especifico o usamos el index del array que estamos recorriendo

        Explicación vieja:
         React exige escribir el elemento key, ya que esto le deja comparar el dom virtual con el dom real, y de esta manera identifica que elemento cambió y debe actualizar y no así toda la lista.
            se tiene que poner el id de los elementos.

            {this.state.elArray.map( ( elementoDelArray, index ) => {
                return <Person click={this.deletePersonHandler} name="person.name" age="person.age" key="person.id" />;
            })}
            
    66. Outputting Conditional Content
    
        por ejemplo para mostrar o dejar de mostrar un div.
        - Hay que usar el operador ternario -
        Dentro de JSX no se puede poner el if comun.

        ej:
        {this.showParrafo === true ?
            <p>hola</p>
        :
        null
        }

        o 

        {this.showParrafo === true && <p>hola</p>}

        significa que o muestro o el parrafo o no muestro (renderizo nada)

        Explicación vieja que suma:
        Dentro de render, antes de retornar algo, podemos poner variables javascript, ya que ahí podemos usar js normalmente.

        ej:

        render (){
            let person = null;

            if(this.person == null) {
                person = ( // esto es como crear un elemento
                    metemos el html aca que queremos ocultar o no
                );
            }

            return (
                html..
                {person} // person es la variable null o la variable donde guardamos el html a renderizar.
            )
        }

    67. Adding Conditional Return Statements
        retorna el componente antes de procesarlo todo al pedo, o sea, valida antes si tiene elementos el array por ej, y sino retorna un mensaje.

    Assignment 4: Time to Practice: Conditional Content
        TODO:

    68. Demo App: Adding a Chart
        https://github.com/academind/react-complete-guide-code/blob/05-rendering-lists-conditional-content/extra-files/ChartBar.css
        https://github.com/academind/react-complete-guide-code/blob/05-rendering-lists-conditional-content/extra-files/Chart.css
        
    69. Adding Dynamic Styles

        Explicación vieja, acá habla de lo mismo.

        Para usar inline styles, se usa javascript en camelCase, ej lo que en css es background-color, aca es backgroundColor o marginLeft, etc.. en el JSX se usa

        Dentro de render ()
        const style = {
            backgroundColor: color,
        }

        <a style={style}></a>

    70. Wrap Up & Next Steps
        ...

    71. Fixing a Small Bug
        The demo application has a small bug at the moment: When adding multiple values, those values are added as strings instead of numbers.

        Fixing it is easy though, simply make sure you enforce a number conversion:

        In ExpenseForm.js, just change

        const expenseData = {
        title: enteredTitle,
        amount: enteredAmount,
        date: new Date(enteredDate),
        };
        to

        const expenseData = {
        title: enteredTitle,
        amount: +enteredAmount,
        date: new Date(enteredDate),
        };
        in the submitHandler function.

    Quiz 3: Learning Check: Outputting Lists & Conditional Content
        TODO: 

    72. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).

        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/05-rendering-lists-conditional-content

        Usage instructions can be found on the page that link is leading to.

        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.

        You also find section slides (if available) in that Github repository.

# Sección 6: Styling React Components
    Cualquier cosa reveer porque apenas chequee xq deje las explicaciones viejas

    73. Module Introduction
        ...

    74. Setting Dynamic Inline Styles

        Explicación vieja, igual aplica acá:

        render () {
            // Agrega esto
            const style = {
                backgroundColor: 'green',
                color: 'white',
                font: 'inherit',
                border: '1px solid blue',
                padding: '8px',
                cursor: 'pointer'
            }

            let persons = null;

            if ( this.state.showPersons ) {
            persons = (
                <div>
                {this.state.persons.map((person, index) => {
                    return <Person
                    click={() => this.deletePersonHandler(index)}
                    name={person.name}
                    age={person.age}
                    key={person.id}
                    changed={(event) => this.nameChangedHandler(event, person.id)} />
                })}
                </div>
            );

            style.backgroundColor = 'red'; // Agrega esto
        }

    75. Setting CSS Class Dynamically

        // Agrega las clases:

        App.css
            .red {
                color: red;
            }

            .bold {
                font-weight: bold;
            }

        App.js
            // Esto usa las clases que declaramos y las une con un espacio en el medio.
            let classes = ['red','bold'].join(' ');

            return (
                <div className="App">
                    <h1>Hi, I'm a React App</h1>
                    <p className={classes}>This is really working!</p>

    76. Introducing Styled Components
        npm install --save styled-components

        import syled from 'styled-components';
        const Button = styled.button`` -> feature: que se llama tacked templates. button es una función o metodo, dentro de los ticks, podes pasar texto.

        Los metodos retornan un componente de react.

        En vez de:
        <div className="Person" style={style}">

        Haces:
        styled.div``
            width: 60%;
            margin:  16px auto;

        pero, es mejor, crear un nuevo COMPONENTE, de esta manera, que es especifica para este framework, ya que recordemos, los metodos, retornan un componente.:

        const StyledDiv = styled.div`
            width: 60%;
            margin:  16px auto;`;

        Esto después lo usamos así:
        <StyledDiv>
        </StyledDiv>

    77. Styled Components & Dynamic Props
        Para pasarle props y cambiar su estilo, dinamicamente, simplemente le pasamos como cualquier otro componente, mediante un nombre de prop y un valor. Después dentro de los backteacks, usamos por ej:

        <StyledButton alt="this.state.button">

        const StyledButton = styled.button`
            background-color: ${props => props.alt ? 'red' : 'green' }
        `;

        Todo esto es javascript, no react, por eso usando los backteacks, se puede usar interpolación de cadenas y a su vez el package hace la magia de poder usar props.

    78. Styled Components & Media Queries (antes este y el prox hablaban de radium)
        TOOD: 

    79. Using CSS Modules
        TOOD: 
        
    80. Dynamic Styles with CSS Modules
        TODO: 

    81. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).

        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/06-styling

        Usage instructions can be found on the page that link is leading to.

        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.

        You also find section slides (if available) in that Github repository.

# Section 7: Debugging React Apps

    82. Module Introduction
        ... 

    83. Understanding React Error Messages
        Como ver en la consola el error y en que linea esta.

    84. Analyzing Code Flow & Warnings
        Muestra como seguir un error a partir de la consola de desarrollador.

    85. Working with Breakpoints
        Muestra como buscar en la solapa sources los componentes y poner Breakpoints desde la consola...

    86. Using the React DevTools
        Instala la extensión de chrome, muestra la solapa Components en la consola de Chrome.

        Del lado derecho abajo de todo, en negrita dice "rendering by", muestra el componente seleccionado y quien lo renderizo, tener en cuenta eso.
        
        se puede buscar componentes, se puede cambiar el tema a dark, desde el icono de configuración.

    87. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).

        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/07-debugging

        Usage instructions can be found on the page that link is leading to.

        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.

        You also find section slides (if available) in that Github repository.

# Section 8: Time to Practice: A Complete Practice Project - TODO:

    88. Module Introduction
        ...

    89. Adding a "User" Component

    90. Adding a re-usable "Card" Component

    91. Adding a re-usable "Button" Component

    92. Managing the User Input State

    93. Adding Validation & Resetting Logic

    94. Adding a Users List Component

    95. Managing a List Of Users via State

    96. Adding The "ErrorModal" Component

    97. Managing the Error State

    98. Module Resources
        You may want to compare your code to mine (e.g. to find + fix errors).

        For that, you find multiple code snapshots for this module here in this Github repository: https://github.com/academind/react-complete-guide-code/tree/08-practice-project

        Usage instructions can be found on the page that link is leading to.

        Simply pick one of the snapshots in the /code folder - the subfolder names are chosen such that they are easy to match against lecture names in this course section.

        You also find section slides (if available) in that Github repository.

# Section 9: Diving Deeper: Working with Fragments, Portals & "Refs"

    99. Module Introduction
        ...

    100. JSX Limitations & Workarounds
        Que no se puede retornar mas de un elemento, ni tener mas de un root.

        Soluciones: wrappear los elementos a la misma altura con un div, un fragment, o cualquier otro elemento sirve. También podemos wrappear los elmentos en un array y separar los componentes por comas, también hay que agregarles key, para que react pueda identificar bien los componentes.

        El problema es que si abusas de los divs, el tree termina lleno de divs que no tienen sentido.

    101. Creating a Wrapper Component
        Para solucionar el problema anterior crea un componente Wrapper, dentro de una carpeta Helper. Y el componente retorna props.children. Ahora si se revisa el dom, no hay components divs demas al pedo.

    102. React Fragments
        Tambiénn podemos reemplazar el de App con <> o Fragment

    103. Introducing React Portals
        Comenta que tener un modal en una sección o algo así, considerando que ocupa toda la app no es buena practica. O sea, el problema es que este nesteado con otros elementos cuando no debería ser así.

        Es malo para la accesibilidad, es como hacer un boton con un div :|

        Para esto hay que usar React Portal, para mantener la estructura, pero que al reflejarlo en el DOM real, este por fuera de todo.

    104. Working with Portals

    105. Working with "ref"s

    106. Controlled vs Uncontrolled Components

    107. Module Resources

----------------------------------- SECCIONES VIEJAS --------------------------------------    

# Sección 6, cosas que quedaron por revisar:
    71. More on Styled Components
            Como funcionan realmente?

            Si nos fijamos en el html, los nombres de las clases que se generaron son fruta, estos nombres los genera el framework.

            El package agarra todo el css y lo pone como selectores de clase y los agrega al encabezado documento, y después agrega el css al div que es retornado por ese compoenente.

        73. Working with CSS Modules
            npm run eject
            // Esto ya se hace varias veces en el curso, buscarlo en el archivo.

            En el caso de que estemos manejando todo el css dentro de un solo arhivo, podríamos indicar adelante de los selectores, el css principal por ejemplo el de App.

        74. CSS Modules & Media Queries
            Con CSS Modules, tenemos la info separada, js por un lado css por otro, y aparte de importar el css solo en el js que lo necesitamos. Recomendable este en la misma carpeta del componente junto al js.

        75. More on CSS Modules
            CSS Modules are a relatively new concept (you can dive super-deep into them here: https://github.com/css-modules/css-modules). With CSS modules, you can write normal CSS code and make sure, that it only applies to a given component.

            It's not using magic for that, instead it'll simply automatically generate unique CSS class names for you. And by importing a JS object and assigning classes from there, you use these dynamically generated, unique names. So the imported JS object simply exposes some properties which hold the generated CSS class names as values.

            Example:

            In Post.css File

            .Post {
                color: red;
            }
            In Post Component File

            import classes from './Post.css';

            const post = () => (
                <div className={classes.Post}>...</div>
            );
            Here, classes.Post  refers to an automatically generated Post  property on the imported classes  object. That property will in the end simply hold a value like Post__Post__ah5_1 .

            So your .Post  class was automatically transformed to a different class (Post__Post__ah5_1 ) which is unique across the application. You also can't use it accidentally in other components because you don't know the generated string! You can only access it through the classes  object. And if you import the CSS file (in the same way) in another component, the classes  object there will hold a Post  property which yields a different (!) CSS class name. Hence it's scoped to a given component.

            By the way, if you somehow also want to define a global (i.e. un-transformed) CSS class in such a .css  file, you can prefix the selector with :global .

            Example:

            :global .Post { ... }

            Now you can use className="Post"  anywhere in your app and receive that styling.

        76. Useful Resources & Links
            Using CSS Modules in create-react-app Projects: https://medium.com/nulogy/how-to-use-css-modules-with-create-react-app-9e44bec2b5c2
            More information about CSS Modules: https://github.com/css-modules/css-modules
            Recursos de esta clase
            styling--01-radium.zip
            styling--02-styled-components.zip
            styling--03-finished.zip

        Desde acá hasta el 75, cambio todo, esto es viejo:
            70. MUST READ: Enabling CSS Modules

                // Para habilitar CSS Modules:
                1) commitear los cambios que puedas tener
                2) npm run eject
                3) Vamos a ver nuevas carpetas:
                    /config -->
                    /scripts --> Tiene un script por cada comando en scripts a ejecutar

                4) Modificar el archivo en config/webpack.config.js

                test: cssRegex,
                        exclude: cssModuleRegex,
                        use: getStyleLoaders({
                            importLoaders: 1,
                            modules: true,
                            localIdentName: '[name]__[local]__[hash:base64:5]',
                            sourceMap: isEnvProduction && shouldUseSourceMap,
                        }),

                    debería modificarse también en el de prod, pero no lo tengo.. igual que otros archivos que el tiene y yo no.
                5) Modificamos el import del css: import clases from './App.css'
                    las clases que tenemos en el archivo pasan a ser propiedades :O
                6) Cambiamos
                    <div className="App">
                    por:
                    <div className={clases.App}>

                    Transforma la info que esta en la clase en unica.
                7) Si revisamos el html vemos que tiene un nombre de clase super extraño :D

            71. Enabling & Using CSS Modules

                // Para habilitar CSS Modules:
                1) commitear los cambios que puedas tener
                2) npm run eject
                3) Vamos a ver nuevas carpetas:
                    /config -->
                    /scripts --> Tiene un script por cada comando en scripts a ejecutar

                4) Modificar el archivo en config/webpack.config.js

                test: cssRegex,
                        exclude: cssModuleRegex,
                        use: getStyleLoaders({
                            importLoaders: 1,
                            modules: true,
                            localIdentName: '[name]__[local]__[hash:base64:5]',
                            sourceMap: isEnvProduction && shouldUseSourceMap,
                        }),

                    debería modificarse también en el de prod, pero no lo tengo.. igual que otros archivos que el tiene y yo no.
                5) Modificamos el import del css: import clases from './App.css'
                    las clases que tenemos en el archivo pasan a ser propiedades :O
                6) Cambiamos
                    <div className="App">
                    por:
                    <div className={clases.App}>

                    Transforma la info que esta en la clase en unica.
                7) Si revisamos el html vemos que tiene un nombre de clase super extraño :D

            72. More on CSS Modules

                CSS Modules are a relatively new concept (you can dive super-deep into them here: https://github.com/css-modules/css-modules). With CSS modules, you can write normal CSS code and make sure, that it only applies to a given component.

                It's not using magic for that, instead it'll simply automatically generate unique CSS class names for you. And by importing a JS object and assigning classes from there, you use these dynamically generated, unique names. So the imported JS object simply exposes some properties which hold the generated CSS class names as values.

                Example:

                In Post.css File

                .Post {
                    color: red;
                }
                In Post Component File

                import classes from './Post.css';

                const post = () => (
                    <div className={classes.Post}>...</div>
                );
                Here, classes.Post  refers to an automatically generated Post  property on the imported classes  object. That property will in the end simply hold a value like Post__Post__ah5_1 .

                So your .Post  class was automatically transformed to a different class (Post__Post__ah5_1 ) which is unique across the application. You also can't use it accidentally in other components because you don't know the generated string! You can only access it through the classes  object. And if you import the CSS file (in the same way) in another component, the classes  object there will hold a Post  property which yields a different (!) CSS class name. Hence it's scoped to a given component.

                By the way, if you somehow also want to define a global (i.e. un-transformed) CSS class in such a .css  file, you can prefix the selector with :global .

                Example:

                :global .Post { ... }

                Now you can use className="Post"  anywhere in your app and receive that styling.

            73. Adding Pseudo Selectors

                Elimina todo el css que andaba por los archivos. Lo voy a eliminar cualquier cosa ver commit "elime css por curso 72"

                .App button {
                    border: 1px solid blue;
                    padding: 16px;
                    background-color : green;
                    font: inherit;
                }

                Sigue funcionando todo porque:
                <div className={classes.App}>
                    <button
                </div


                btnClass = classes.Red;
                <button
                    className={btnClass}

            74. Working with Media Queries

                Person.css
                @media (min-width: 500px) {
                    .Person {
                        width: 450px;
                    }
                }

                no se que pasa que no funciona.

            75. Useful Resources & Links

                Using CSS Modules in create-react-app Projects: https://medium.com/nulogy/how-to-use-css-modules-with-create-react-app-9e44bec2b5c2
                More information about CSS Modules: https://github.com/css-modules/css-modules
                Recursos de esta clase
                styling--01-radium.zip
                styling--02-css-modules-finished.zip

### Sección 7: Diving Deeper into Components & React Internals

    84. Module Introduction
    85. A Better Project Structure

        Los componentes a generar deben tener sentido. Por ej si queremos tener algo generico como un input que se use en varias partes, ahí si valdría la pena hacer un solo componente por eso.
        Los componentes que manejan estados, no deberían comprometerse mucho con la renderización de otros, o sea no tener mucho JSX.

        En src, genera:
            /components  --> cada componente
            /assets      --> imagenes y css
            /containers  --> los componentes principales (como App)

    86. Splitting an App Into Components

        // Si hacemos esto, no es necesario poner el return, gracias a ES6
        const persons = (props) => (
            Podemos poner JSX
        );

        Si en una función utilizamos { } y un metodo return -> componente.
        Si en una función utilizamos { } -> funcion

        Resumen: Hay que tener containers donde se manejen estados y el resto deberían ser funcional components donde
                solamente se pasen props.

    87. Comparing Stateless and Stateful Components

        Presentational component (stateless components) = functional component que no maneja estados

    88. Class-based vs Functional Components

            A los containers se les puede pasar props desde index.js al renderizarlos.

    89. class Component Lifecycle Overview

        - Solo esta disponible en class Component.
        - Hay un monton de metodos, que react corre por nosotross, ej:
        contructor(), getDerivedStateFromProps()...

        IMPORTANTE: no realizar "side effects" en el construtor, como:
            http request, store aglo en la base. Usar solo para inicializar variables.

        Ejemplos de llamados de metodos en orden:

            1) constructor
            2) getDerivedStateFromProps
                Cuando las props cambien para la clase. Idem constructor, no side effects acá.

            3) render
                prepara y estructura tu jsx para retornarlo.

            4) Child components:
                Se renderizan estos components.

            5) ComponentDidMount()
                Acá se pueden generar "side effects"
                NO ACTUALIZAR EL ESTADO ACA. Salvo que se cumpla una promesa sobre un llamado http.

    90. Component Creation Lifecycle in Action
        lifecycle-creation-learning-card (1)
        cmp-deep-dive-01-creation-lifecycle

        mediante console log, muestra como se van ejecutando en orden las cosas, idem las posteriores..

    91. Component Update Lifecycle (for props Changes)

        lifecycle-update-external-learning-card (1)
        cmp-deep-dive-02-updating-lifecycle-props

        Ciclo de vida para actualizar los componentes.
            Cuando cambian las props o el estado

        1) getDerivedStateFromProps(props, state)
            No se usa amenudo, se utiliza para inicializar el estado de un componente que se actualiza en funcion de los accesorios que esta obteniendo. ej, algun control de form que obtiene propieades externas y luego internamente desea manejar la entrada del usuario pero inicializa su estado o actualiza el estado en función de cmbioas externos.
            Sirve para sincronizar tu estado local dentro del component, no debería realizar side effects, por lo que no se deberían realizar llamadas http.

        2) shouldComponentUpdate(nextProps, nextState)
            permite cancelar el proceso de actualización, o sea, si react debe continuar evaluando y renderizando el componente o no.
            se usa para optimizar el rendimiento.
            tener cuidado porque podes bloquear tus componentes

        3) render()
            revisa el codigo JSX, lo evalua y basicamente construye su dom virtual

        4) Update Child Components Props
            Evalua todos los hijos secundarios que tengas en tu JSX y los actualiza

        5) getSnapshotBeforeUpdate(prevProps, prevState)
            devuelve un objeto snapshot que se puede configurar.
            también es un enlace de ciclo de vida que no se usa demasiado.
            se usa para operaciones de ultimo momento en el dom, no cambios, sino como obtener la posición de desplazamiento actual del usuario.
            suponiendo que su proxima actualizacion del dom va a volver a representar el dom y agregara nuevos elementos y por lo tanto queres restaurar donde estaba el usuario posicionado.

        6) componentDidUpdate(prevProps, prevState, snapshot)
            un enlace de ciclo de vida que te "avisa" que terminó la actualización del componente.
            acá si se pueden realizar llamadas http
            LOOP INFINITOO ALERT:
                no actualice el stado aqui porque sino va a causar re-renderizado nuevamente.

    92. Component Update Lifecycle (for state Changes)
        cmp-deep-dive-03-updating-lifecycle-state

    93. Using useEffect() in Functional Components

        import React, { useEffect } import 'react'

        Toma una función que corre en cada ciclo de renderizado, después que se re-renderiza.
            useEffect(() => {

            })

        useEffect combina dos :
            componentDidMount y componentDidUpdate.

    94. Controlling the useEffect() Behavior

        1) Que haga algo solo la primera vez. Se pone un array vacio [] y corre una sola vez y nunca mas.
            useEffect(() => {

            },[])

        2) cuando se actualiza un estado.
            Lo que hay que hacer sería lo siguiente:

            useEffect(() => {

            },[props.persons])

        IMPORTANTE: En el caso de necesitar lo mismo para otra prop, hay que volver a escribir useEffect y pasarle esa prop.

    95. Cleaning up with Lifecycle Hooks & useEffect()

        componentWillUnmount, se ejecuta cuando se remueve el componente, en el caso del toggle persons por ej cuando haces clic otra vez para ocultarlo.

        Dentro del mismo useEffect, se puede retornar algo mediante una función anonima, para limpiar algo.

    96. Cleanup Work with useEffect() - Example
        useeffect

    97. Using shouldComponentUpdate for Optimization
        https://academind.com/learn/javascript/reference-vs-primitive-values/

        shouldComponentUpdate -> se renderizan todos los componentes, pero lo podemos modificar para que se renderice solo el que se actualizó:

        shouldComponentUpdate(nextProps, nextState){
            if(nextProps.persons !== this.props.persons){
                return true;
            }else{
                return false;
            }

            return true;
        }

        IMPORTANTE: Para ver que se refresca en la pantalla > F12 > clic en los 3 puntos > More Tools > Rendering > chequear la opción Paint Flashing
                    Ojo porque a veces parece que refresca la pantalla, pero en realidad esta refrescando el dom virtual.

    98. Optimizing Functional Components with React.memo()

        En cockppit por ejemplo, al exportar el componente, utilizaríamos memo.
        Lo que hace es tomar un snapshot del componente y lo re-renderiza, si y solo si, el input cambia.

        export default React.memo(cockpit);

        El problema es que en cockpit, hay una propiedad que cambia siempre que es persons, por ende hay que hacer un mini fix en la manera de pasarselo en App.
            le pasamos solo el lenght de cockpit, en vez de que lo resuelva el adentro.

    99. When should you optimize?
    100. PureComponents instead of shouldComponentUpdate

        Si queremos chequear si alguna de todas las propiedades cambió, no nos conviene usar shouldComponentUpdate.
        Para eso tenemos que extender de otro componente:

        import React, { PureComponent } from 'react'

        PureComponent, ya implementa shouldComponentUpdate con un completo chequeo de todas las props.

    101. How React Updates the DOM

        render() --> No actualiza inmediatamente al DOM real. Aplica a todo tipo de componentes.
                    Este puede llegar a dar el mismo resultado que antes, es por eso que se usa shouldComponentUpdate, para manejar que es lo que realmente se debería renderizar.

                    Lo que hace es compara el viejo DOM con el nuevo DOM (virtuals)
                        Hace esto porque es mas rapido que el DOM real.

                    DOM Virtual, es una representación del DOM en Javascript.
                    El future DOM, es el que se crea cuando render es llamado, recordemos que render no llama inmediatamente al DOM real sin antes comparar (el viejo con el futuro para ver si hay diferencias.)
                    Una vez que termina llama al DOM real y lo actualiza, y no lo re-renderiza por completo, solo lo que fue detectado para updetear.

                    Si no encuentra diferencias, se ejecuta render y ahí es donde shouldComponentUpdate debería prevenir que llame al dom real, si realmente nada cambio.

    102. Rendering Adjacent JSX Elements

        En vez de envolver los elementos en un div, podemos usar:

            return [
                <h1></h1>,
                <p></p>
            ]

            El tema es que hay que generar una key, para cada elemento, si no tenes que generar identificadores unico igual.

        Otra manera de hacer esto es:

            Crear una carpeta hoc (High order component)
            Después hay que crear un archivo Aux.js (mac) Auxiliary.js (Windows)

            import React from 'react';

            const aux = props => props.children;

            export default aux;

            IMPORTANTE: Children es una propiedad especial, que lo que sea que entre, lo pone entre tags cerrados.

    103. Windows Users Must Read

        On Windows, the Aux.js  filename is not allowed in ZIP archives. Hence when extracting the attached source code, you might get prompted to rename the Aux.js  file. You might also face difficulties creating an Aux folder and Aux.js file.

        I really apologize for that inconvenience, Windows is really doing an amazing job here ;-).

        Follow these fixes:

        1) Problems when unzipping the attached file:
        Simply skip this step (e.g. by pressing "No") and ignore the upcoming error message.

        In the extracted folder, you'll then find all source files EXCEPT for the Aux.js  file. In later course modules (where we work on the course project), the Aux.js  file can be found in an Aux/  subfolder inside hoc/ .

        Make sure to take the Aux.js  file attached to this lecture and place it inside the hoc/  or hoc/Aux/  folder (which ever of the two you got).

        2) Problems with the creation of an Aux folder and/ or file:
        Simply name both differently. For example, you may create an Auxiliary  folder and name the file inside of it Auxiliary.js . Make sure to then adjust your imports (import Aux from './path/to/Auxiliary/Auxiliary' ) and you should be fine.



        Recursos de esta clase
        Aux.js
        Auxiliary.js

    104. Using React.Fragment

        En vez de usar Aux, se puede usar <React.Fragment> si no queremos usarlo así (separado por el punto, hay que importar Fragment)
        import React, { Fragment} from 'react'

        Hace lo mismo que Aux.

    105. Higher Order Components (HOC) - Introduction

        Se llama así porque contiene un componente, no hace nada.

        También puede haber componentes HOC:
            Puede ser por ej el div con className App.

        Otro ejemplo:
            Crea el archivo /hoc/WithClass.js

            import React from 'react';

            const withClass = props => {
                <div className={props.classes}>
                    {props.children}
                </div>
            };

            export default withClass;

        CONVENCIÓN: Los archivos de hoc, tienen que tener With adelante.

        Cambia el div de app por este withClass y le pasa classes por props.

    106. Another Form of HOCs

        Existe otra manera de crear las clases tipo withClass.

        Devolver una función comun de Javascript.
        1) parametro que debe arrancar con mayuscula
        2) algo que necesitemos en el componente hoc.
        3) Puede tener n parametros (obvio los que necesitas nada mas.)

        const withClass = (WrappedComponent, className) => {
            // Retorno un componente funcional.
            return props => (
                <div className={className}>
                <WrappedComponent></WrappedComponent>
                </div>
            );
        };

        4) Usamos el componente Aux en App y cambiamos el nombre del js a tener w minuscula, porque ahora estamos devolviendo una función no un componente.
        5) modificamos el export de App:
            export default withClass(App, classes.App);

            Esto se usa dependiendo de que necesitemos.

    107. Passing Unknown Props

        Si lo hacemos en el componente de Person no tenemos prop, entonces hay qu tocar la función, para que dentro delc omponente, haga un spread de props, así después los demas componentes que la quieren usar no tienen ningun problema.

    108. Setting State Correctly

        Esto que muestra es solo para clases basadas en componentes.

        Hay que actualizar el estado así:
            this.setState((prevState, props) => {
                return {
                    persons: persons,
                    changeCounter: prevState.changeCounter + 1;
                }
            })

        NO ASÍ:
            this.setState({
                persons: persons,
                changeCounter: this.state.changeCounter + 1;
            })

        Porque cuando se usa de la ultima forma, React no te garantiza que ese sea realmente el último estado.

    109. Using PropTypes

        No necesariamente son necesarias, pero cuando trabaja en un equipo grande o que queres distribuir lo que estás haciendo, evitas que la gente pase mal las propiedades.

        Hay que:

            1) Instalar prop-types
                > npm install --save prop-types
            2) Importarlo:
                import PropTypes from 'prop-types';
            3) Agregar antes del export:

                NOTA: va con minuscula acá:

                Person.propTypes = {
                    click: PropTypes.func,
                    name: PropTypes.string,
                    age: PropTypes.number
                }

        IMPORTANTE:
            - Funciona en cualquier tipo de componente.
            - Te avisa si estas pasando una propiedad incorrecta EN DEVELOPMENT MODE.
            - Podes usarlo en el componente que creas necesario.

    110. Using Refs

        Solo funciona en componentes basados en clases.
        Ejemplo para ponerle el foco en el ultimo elemento de una lista de 3 elementos input:

        ref:
            es una key especial, que le podes pasar a cualquier componente.
            Se puede usar de varias maneras, una es esta:

                Lo usas con una función anonima en la que obtenes tenes la referencia, de donde pongas ref.
                y le pones el nombre que quieras, por ej inputEl,
                en el cuerpo de la función podes asignar ese elemento a una nueva propiedad de clase

                ComponentDidMount() {
                    this.inputElement.focus();
                }

                <input
                    ref={ ( inputEl ) => { this.inputElement = inputEl }}
                />

            Otra es:
                constructor() {
                    super(props);
                    this.inputElementRef = react.createRef();
                }

                ComponentDidMount() {
                    this.inputElementRef.current.focus();
                }

                <input
                    ref={ this.inputElementRef }
                />

    111. Refs with React Hooks

        Como usar algo parecido a Refs, con React Hooks en functional components.

        import React, { useRef } from 'react'
        const toggleBtnRef = React.createRef(null);

        y hay que usar dentro de useEffect: toggleBtnRef.current.click()

    112. Understanding Prop Chain Problems

        Hace un ejemplo donde pasa una propiedad por varios componentes y que si tenes un componente que es reutilizable vas a tener que estar haciendo cosas demas para poder usarlo solo por eso,
        explica que esto lo resuelve

    113. Using the Context API

        * this.context no se usa mas, se debe usar esta api. React.createContext + useContext

        PROVIDER: se crea el context para que los componentes después, lo puedan CONSUMIR.
            - React create context, nos permite inicializar nuestro contexto con un valor inicial, puede ser cualquiera cosa, obj, array, etc. También se inicializa para poder usar el intellisense, pero generalmente la inicialización no se utiliza salvo que no se pase nada al atributo value del componente.

            - Crete context es un "objeto global" de javascript. O sea, en realidad no es que es un objeto global,
            sino que vos decidis donde se va a aplicar.

            - En el contexto tengo que guardar todo lo que quiero acceder desde mis diferentes componentes.

            - Con nuestro nuevo componente, en este caso authContext, tenemos que envolver, los componentes, que querramos que tengan acceso a esta información.

        CONSUMER:
            - Se debe importar el context, y en el return, debemos utilizar el componente, englobando los componentes que necesitan esa info, pero con <AuthContext.Consumer> ver ej mas abajo:
            - No toma JSX como un hijo, pero si una función, ver ej de como realizar esto.
            - Se utiliza en el componente que este lo mas abajo posible, ya que sino tenemos que andar pasando cosas por props y justamente esa no es la idea.

        EJEMPLO:
        Agrega una nueva carpeta /context y después un archivo aux-context.js
            import React from 'react';

            const authContext = React.createContext({
                authenticated: false,
                login: () => {}
            });

            export default authContext;

        App.js
            Lo importamos.
            Envolvemos los componentes que queremos con el componente que creamos:
                // value, se setea cuando vos no seteas ningun otro valor.
                <AuthContext.Provider value={authenticated: this.state.authenticated, login: this.loginHandler  } >

        Persons.js
            Como acá lo queremos consumir, tenemos que, después del return, poner:
            <AuthContext.Consumer>
            {context => <button onClick...}
            </ AuthContext.Consumer>

        IMPORTANTE: lo que se cambie en ese contexto, no va a generar una re-renderización.

        export default authContext;

    114. contextType & useContext()


        COMPONENTES BASADOS EN CLASES:

            Como en ComponentDidMount, puede que tengas que hacer un llamado HTTP y necesites el context y ahí no se puede obtener la info como la aprendimos.
            A partir de react 16.6 hay una variable estatica contextType.

            static contextType = authContext;

            Esto habilita a que detrás de escena, el metodo ComponentDidMount, se comunique con la variable estatica, ya que ahora tenes dentro del metodo:
            this.context.login por ej.
            this.context.authenticated
            También podemos modificar el elemento AuthContext.Consumer por this.context.authenticated

        FUNCTIONAL COMPONENTS
            import AuthContext from 'context/aut-context';
            import React, {useContext} from 'react'

            const authContext = useContext(AuthContext);

            authContext.authenticated

            en coockpit, cambias el elemento por esto y listo.

    115. Wrap Up
    116. Useful Resources & Links

        More on useEffect(): https://reactjs.org/docs/hooks-effect.html

        State & Lifecycle: https://reactjs.org/docs/state-and-lifecycle.html

        PropTypes: https://reactjs.org/docs/typechecking-with-proptypes.html

        Higher Order Components: https://reactjs.org/docs/higher-order-components.html

        Refs: https://reactjs.org/docs/refs-and-the-dom.html

        Recursos de esta clase
        cmp-deep-dive-01-creation-lifecycle.zip
        cmp-deep-dive-02-updating-lifecycle-props.zip
        cmp-deep-dive-03-updating-lifecycle-state.zip
        cmp-deep-dive-04-finished-useeffect.zip
        cmp-deep-dive-05-shouldcomponentupdate-memo.zip
        cmp-deep-dive-06-aux.zip
        cmp-deep-dive-07-withclass.zip
        cmp-deep-dive-08-finished-hocs.zip
        cmp-deep-dive-09-updating-state.zip
        cmp-deep-dive-10-proptypes.zip
        cmp-deep-dive-11-refs.zip
        cmp-deep-dive-12-finished.zip

### Sección 8: A Real App: The Burger Builder (Basic Version)

    117. About React Hooks

        As mentioned before, we'll build the course project without React Hooks for now (React Hooks are a new feature, introduced with React 16.8, I'll introduce them in-depth later).
        Towards the end of the course, we'll have an entire module where we convert it to use React Hooks though (after having yet another Hooks deep-dive module of course).

    118. Module Introduction
    119. Planning an App in React - Core Steps

        Como planear una applicación React: Pasos Core

        1) Estructura (planificar el árlbol de componentes)
        2) Estado (State)
        3) Componentes vs Contenedores (cuales tienen que mantener el estado y cuales no)
            Es normal que a veces cambiemos sobre la marcha, porque nos damos cuenta que es mejor otra cosa..

    120. Planning our App - Layout and Component Tree

        Modela como va a ser la pagina, y los componentes que va a necesitar.

    121. Planning the State

        Identificar donde necesitamos state, va a ayudar a saber que va a ser un componente o no

        State
            -Ingredients
                -carne
                -queso
            -comprado: true/false
            -totalPrice: 0
            ...
    122. MUST READ: Enabling CSS Modules

        MUST READ (at least the first few paragraphs ... ;-))

        In the next lecture, we'll use a styling solution named "CSS modules". We already had a look at that in the "Styling" section earlier in the course.

        In the next lecture, we'll enable CSS modules and depending on the project setup you're using, the exact steps shown there might not work for you.

        At least if you're not using the starting project you also find attached to the next lecture. If you DO use that, you should be able to continue without issues (and you can skip the rest of this text lecture here).

        ***

        In more recent project versions created by CRA, support for CSS modules is already built-in and you can use that feature without ejecting, please see: https://facebook.github.io/create-react-app/docs/adding-a-css-modules-stylesheet

        I also showed this built-in support in the "Styling" section earlier in the course.

        If you use this approach, you DON'T need to eject. But please don't skip the next videos though, I do explain what CSS modules are and why + how we use them there!

        ***

        Optional:

        If you still want to eject and manually adjust the Webpack config (as we do it in the new videos - which you don't need to do if you follow the approach described in the link above), you should take the below comments into account in case your webpack config (after ejecting) doesn't look the same as it does in my videos:

        After ejecting, we edit a Webpack config file that's made available by ejecting. This file might look slightly different for you.

        In the video, I'll look for an entry that starts like this (in the webpack.config.js file):

        {
        test: /\.css$/,
        ...
        }
        and I then edit this entry.

        This entry now looks slightly different. You'll have to find the following part in your webpack.config.js file:

        {
        test: cssRegex,
        exclude: cssModuleRegex,
        ...
        }
        and then edit that entry.

        Finally, it should look like this:

        {
        test: cssRegex,
        exclude: cssModuleRegex,
        use: getStyleLoaders({
            importLoaders: 1,
            modules: true,
            localIdentName: '[name]__[local]__[hash:base64:5]'
        }),
        }
        You can ignore me editing the webpack.config.prod.js file - with the latest version of create-react-app, ejecting only gives you ONE webpack config file (which you edit as described above).
    123. Setting up the Project
        Habilita Csss Modules, que ahora ya esta habilitada desde la nueva versión.
        Agrega el css de una tipografia y nadamas..

    124. Creating a Layout Component
        Crea las carpetas de componentes/contenedores.
        Crea el componente layout y comenta que usa props.children porque de esa manera va a ir mostrando las cosas en pantalla que esten por debajo de ese componente ??¿¿

        crea una carpeta hoc y adentro un componente aux, que va a utilizar para envolver elementos adyacentes.
            const aux = (props) => props.childre;
            export default aux;

    125. Starting Implementation of The Burger Builder Container
        para agregar estilo, se pone el css y después se importa donde se necesita el estilo y con js se agrega, ej:

        import classes from './Layout/Layout.css'
        className={classes.laClaseQueHice}

    126. Adding a Dynamic Ingredient Component
        Si queremos tener un poco de logica nuestra función tiene que arrancar con llaves, sino directamente con parentesis.

        Arma toda la parte de los ingredientes de la hamburguesa con una clase de css que el tenía.

    127. Adding Prop Type Validation
        npm install --save prop-types

        sirve para validar lo que le pasamos a las properties sea lo que realmente esperamos.

        Componente.propTypes = {
            type: PropTypes.string,isRequired;
        }

    128. Starting the Burger Component
        Estila Burger.css

        En el componente BurgerBuilder, agrega el componente Burger.

    129. Outputting Burger Ingredients Dynamically
        Hace toda una función para mostrar pseudo dinamicament los ingredientes de la hamburgeusa (heardcoders), pero recorre todo el objeto.

    130. Calculating the Ingredient Sum Dynamically
        .reduce((previosValue, currentValue) => {
            return previosValue.concat(currentValue)
        }, [])

        hace esto para poder verificar si no hay ingredientes y mostrar un texto para que el usuario empiece a agregarlos.

    131. Adding the Build Control Component
        Agrega un BuildControls y crea un componente BuildControl, lo estila..

    132. Outputting Multiple Build Controls
        agrega el control al componente principal y con map, mapea todos los controles para agregar los distintos ingredientes.

    133. Connecting State to Build Controls
        genera las funciones de remover y agregar, agrega el codigo necesario a add, como actualizar el precio, y los ingredientes.

        en el componente de mas abajo de todos de los controles, no el ultimo, ya que ese es el que ejuta la funcion nad amas, el anterior, a la función le pase el tipo cuando hace clic, el se encarga de hacer eso no el padre de todos esos componentes, porque es el que tiene la función y el que pasa la referencia a sus componentes hijos.

    134. Removing Ingredients Safely
        copia y pega la de agregar y la modifica para el removr.
        también valida que los ingredientes sean mayor a 0, así cuando intenta remover mas y no hay mas, no hay errres.

        genera un flag que inhabilita el ctrl de el ingrediente cuando no hay mas de ese especifico

        pasa la property de disable entre los componentes.

    135. Displaying and Updating the Burger Price
        con .toFixed(2) -> dice que el precio muestre con 2 decimales.

    136. Adding the Order Button
        genera la función que valida si hay al menos u ingrediente para que se habilite el boton de ordernar ahora. agrega la función al final del remover ingredientes o agregar ingredientes para que se llame y justamente verifique si tiene que habilitar el boton o no.

    137. Creating the Order Summary Modal
        crea una carpeta Ui dentro decomponentes, para poner el modal y un par mas,
        a la misma altura que los controles crea un componente orderSumarr que se va a ir actualizando desde el componente raiz con los ingredientes.

    138. Showing & Hiding the Modal (with Animation!)
        crea el código para mostrar u ocultar el modal y le da un poco de estilo.
        En el interin tiene un problema con this, por la manera que escribio la función, así que la pasa a una arrow function y listo, solucionado.

        El error pasó porque la función se ejecutaba después de un evento y eso hacía que this no apunte a la función.

    139. Implementing the Backdrop Component
         Se puede retornar null en un componente, esta ok, significa que no queres mostrar nada.

         Genera el overlay y pone el componente dentro del modal porque estan totalmente relacionados.

    140. Adding a Custom Button Component
        Agregar los botones confirmar y cancelar.
        Genera en UI un componente nuevo Button, y le define las propiedades necesarias para utilizarlo y qe sea generico.

        de clase le passa un array, ya que le agrega 2 o mas segun el estado del boton.

    141. Implementing the Button Component
        Lo implementa en OrderSummery
        Le pasa por props a OrderSummery los handlers para los botones.

    142. Adding the Price to the Order Summary
        Usa el precio total que viene por props, y lo muestra.

    143. Adding a Toolbar
        crea el toolbar de la burguer y su css. (un nav con 2 menus)

    144. Using a Logo in our Application
        Dentro de componentes crea una carpeta Logo, dentro de assests tiene el logo de la app.

        Importa el logo como si fuera un package.

        en el src={variableConLaQueLoImporte}

        Usa el componente logo donde lo necesita en el toolbar y listo.

    145. Adding Reusable Navigation Items
        Dentro de la carpeta Navigation aparte del Toolbar, crea una capreta NavigationItem, NavigationItems y sus js.

        Dentro de NavigationItem.js
            lo que mete acá sería el <li><a href="/"> A Link</a></li>

        Dentro de NavigationItems.js
            importa el componente NavigationItem

            Lo que pone acá es el ul y pone los navigationItem que necesita.

        Dentro de Toolbar.
            Importa NavigationItems y dentro de <nav> pone NavigationItem.

    146. Creating a Responsive SideDrawer
        Cuando aprestas el boton Menu, el SideDrawer debería aparecer de costado.

        importa el componente Logo y NavigationItems, classes..

        <div className={classes.SideDrawer}>
            <Logo />
            <nav>
                <NavigationItems />
            </nav>
        </div>

        Lo que hace es meterlo detro del componente Layout, junto con el Toolbar.
            <Aux>
                <Toolbar />
                <SideDrawer />
                <main classNAme={classes.Content}>
                    {props.children}
                </main>
            </Aux>

    147. Working on Responsive Adjustments
        Le hace modificaciones en el css al SideDrawer
    148. More about Responsive Adjustments
        Css y mas css par todo lo relacionado al layout y mobile.

    149. Reusing the Backdrop
        El backdrop es como el telon que se pone cuando abris un modal. Ahora lo que hace es reutilizarlo
        para el SideDrawer.

        Por ende lo importa y lo usa en el SideDrawer y le pasa a su property show, true o false dependiendo si se tiene que ver o ono (idem el SideDrawer)

        Pasa a layout como componente. y pone los handlers necesarios para manejar el mostrar o no el SideDrawer y el backdrop.

        También agrega código para que cuando se hace clic en el overlay, se cierre todo.

    150. Adding a SideDrawer Toggle Button
        Intenta que primero lo hagas vos, después da el resultado:

        Dentro de SideDrawer, crea otra carpeta DrawerToggle y su js.

        Después lo importa en Toolbar y reemplaza la parte del menu con el componente DrawerToggle.

        En el componente pasa una prop clicked, por ende maneja el estado en toolbar, pero como este se usa desde Layout, ahí finalmente va a manejar el handler del evento.

    151. Adding a Hamburger Icon
        Hace lo que dice el modulo.

    152. Improving the App - Introduction
        Habla sobre todo lo que nos enseño, su manera de pensar, que si hay componentes que se podrían mejorar, unir, si hay mejoras de performance que hacer, se va a tratar todo en las siguientes clases.

    153. Prop Type Validation
        Comenta que solamente hice una validación de propiedades, porque es una app que esta haciendo el solo, que si lo aplicaría para un team de trabajo, o si esta haciendo algo open source, etc.

    154. Improving Performance
        Empieza a analizar la aplicación y comenta que en OrderSummery, se esta re-renderizando el componente, aún cuando el modal no esta visible, por lo que va a optimizar eso:

        Para verificar eso, pasa el componente de Order a una clase y utiliza el metodo ComponentWillUpdate(), si falla por la versión que tenemos, se puede usar también ComponenteDidUpdate()

        Hace lo mismo con el modal, ya que verificó que realmente cada vez que agrega un ingrediente se actualiza Order.
        A modal también lo convierte a clase y usa la función shouldComponentUpdate y solo va a actualizar las cosas si show (muestra o no el modal, se cambia a verdadero)


        shouldComponentUpdate(nextProps, nextState) {
            return nextProps.show !== this.props.show;
        }

        También comenta que no es necesario que se convierta en una clase, que debería ser un componente funcional.

    155. Using Component Lifecycle Methods
        Side effects en realidad aca se usa como llegar a hacer una llamada a una api y obtener datos de ella.
        Explica la importancia de los metodos que ayudan a verificar si se actualizó un estado o no, etc.

    156. Changing the Folder Structure
        Explica que Layout es un HOC, que podría estar en esa carpeta, pero que tampoco esta mal que este en containers, porque maneja el estado y se lo pasa a los componentes que esta conteniendo.

        Que no necesariamente hay que tener una carpeta hoc, podriamos tener solo componentes y containers y tampoco estaría mal.

        Dentro de la carpeta hoc, agrega una Aux y mete ahí el archivo Aux.js
    157. Wrap Up
        Explica que hicimos nuestra primer app en react, que aprendimos, etc.

    158. Useful Resources & Links
        Useful Resources & Links
        Find the finished code (as well as in-between steps) for this module attached to this lecture.

        Recursos de esta clase
        burger-basics--06-finished.zip
        burger-basics--01-project-setup.zip
        burger-basics--02-after-ingredients.zip
        burger-basics--03-after-build-controls.zip
        burger-basics--04-after-modal.zip
        burger-basics--05-after-navigation.zip

### Sección 9: Reaching out to the Web (Http / Ajax)

    159. Module Introduction
    160. Understanding Http Requests in React
        explica como funciona cuando un cliente hace un request mediante el navegador y que responde el servidor..

    161. Understanding our Project and Introducing Axios
        Habla de que se puede hacer algo con Javascript, pero ya existen paquetes que hacen todo mas facil, como axios.

        npm install axios --save

    162. Creating a Http Request to GET Data
        simula llamadas a una api, con json placeholder

        axios.get(url)
            .then(response => {
                console.log(response);
            }) // cuando se resuelva la promesa, cae en then.

    163. Rendering Fetched Data to the Screen
        guarda la info que retorna la api en el state, y después con map genera los componentes necesarios dependiendo de cuanta info vino en el repsonse.

    164. Transforming Data
        usa slice para en vez de mostrar todos los elementos del response, mostrar solo los primeros 4.
        Envia por atributos/props la info y arregla el componente para que muestre bien todo.

    165. Making a Post Selectable
        Hace una función y se la pasa al componente que termina renderizando un mensaje o la info que seleccionaste.

    166. Fetching Data on Update (without Creating Infinite Loops)
        Valida que el fetch se haga si y solo si, el id que esta queriendo cargar es difernete al que esta cargado.
        Sino esto genera un loop infinito de requests.

    167. POSTing Data to the Server
        axios.post(url, data)
            .then(response => {
                console.log(response);
            })

    168. Sending a DELETE Request
        axios.delete(url, this.props.id)
            .then(response => {
                console.log(response);
            })

    169. Fixing a Bug
        arregla un temita que no se había dado cuenta, que era que cuando hacia click en un post se mostraba el titulo y no el contendido, nad amas.

    170. Handling Errors Locally
        a la llamada de axios aparte de .then, se le puede agregar
        .catch(response => {
            this.setState({error: true});
        })

    171. Adding Interceptors to Execute Code Globally
        Para cuando queres hacer cosas como agregar headers que tienen que ir siempre, en app.js
        importa axios.
        Tiene 2 parametros, en uno recibimos la config del request y después podemos manejar los errores que puedean ocurrir.

        axios.interceptors.request.use(request =>  {
            console.log(request);
            // Editamos la configuración del request (que es lo que hay en request en si)
            return request; // siempre tenemos que retornar request, sino estamos bloqueando el request.
        }, error => { -> esto es para cuando hay errores de conectividad, no un 400 bad request por ej
            return Promise.reject(error);
        })


        También podemos manejar los response.
        axios.interceptors.response.use(response => {
            console.log(response);
            return response;
        }, error => {
            console.log(error);
            return Promise.reject(error);
        });


        Hay otr manera también de acceder a las configuraciones, la muestra en la proxima.

    172. Removing Interceptors
        You learned how to add an interceptor, getting rid of one is also easy. Simply store the reference to the interceptor in a variable and call eject  with that reference as an argument, to remove it (more info: https://github.com/axios/axios#interceptors):

        var myInterceptor = axios.interceptors.request.use(function () {/*...*/});
        axios.interceptors.request.eject(myInterceptor);

    173. Setting a Default Global Configuration for Axios
        En app.js

        axios.defaults.BaseUrl = 'la url de mi api'; -> sacamos en nuestras llamadas la parte del server:port
        axios.defaults.headers.common['Authorization'] = 'AUTH TOKEN'; -> que venga con el token
        axios.defaults.headers.post['Content-Type'] = 'application/json' -> que solo para los post pida esto, se puede con cualquier metodo

    174. Creating and Using Axios Instances
        se puede configurar diferentes url base, usando diferentes instancias.

        crea un nuevo archivo axios.js y:
            importa axios

            const instance = axios.create({
                baseURL: 'mi url',

            })

            //axios.defaults.headers.common['Authorization'] = 'AUTH TOKEN';
            instance.headers.common['Authorization'] = 'AUTH TOKEN'; -> solo para esta instancia con esa url.

            export default instance;

        en donde la necesitamos ahora importamos este archivo en vez de axios.

    175. Wrap Up
    176. Useful Resources & Links
        Useful Resources & Links
        Axios Docs: https://github.com/axios/axios
        Recursos de esta clase
        http--01-starting-setup.zip
        http--02-after-get.zip
        http--03-after-post-error.zip
        http--04-after-global-axios.zip
        http--05-finished.zip

### Sección 10: Burger Builder Project: Accessing a Server

    177. Module Introduction
    178. Firebase & The Right Database
        The Firebase Database console - which we'll see in the next lecture - changed visually.

        Important: Make sure you pick the Realtime Database, NOT Firestore!

    179. Creating the Firebase Project
        Ir a consola > Nuevo proyecto > poner el nombre > destilde Google Analytics.

        Dice que hay que tener en cuenta los planes...
        Setea en rules en true, la opción de lectura/escritura, al menos por el momento.
        Copia la url que le provee que es como un endpoint al que le pegas a la base.


        * La consola que muestra el es bastante diferente de la que tiene actualmente firebase.
          El en este curso usa la opción de realtime database, por si en algún lugar de la consola se llega a ver eso.

    180. Creating the Axios Instance
        crea un archivo axios-order.js y genera una instancia de axios para hacer posteos

    181. Sending a POST Request
        Dentro de la función purchaseContinueHandler

        hace la llamada a axios, y hay que tener en cuenta que para pegarle a la base a la tabla que corresponde en firebase, hay que poner por ej:

        axios.post('/orders.json', objetoConInfo);

    182. Displaying a Spinner while Sending a Request

        Crea dentro de la carpeta UI un spinner.js
        Busca en google css spinner, se copia el css,
        genera el componente en el archivo, props, estado.

        Dentro del modal, en el metodo shouldComponentUpdate, agrega una condición al if, que se renderice lo que esta adentro del componente si cambia show o si nextProps.children !== this.props.children

    183. Handling Errors
        Implementar Global Error Handling.

        Crea un componente hoc, withErrorHandler, con minuscula (es otra manera de crear un componente), no va a devolver JSX.
        Usa el interceptor de response de axios para obtener si hubo algun error en alguna llamada en el response.
        Crea una función para setear el error en nulo cuando cierra el modal de error.

    184. Retrieving Data from the Backend
        En FireBase, crea la "tabla" ingredients, con las mismas propiedades del objeto con el que inicializaba, ahora en componentDidUpdate realiza la llamada a la base y mete una validación para que no rompa la app ya que ahora ingredients en el state es nulo al arrancar, porque se actualiza después con lo de la base.

        Hay un error por la manera en la que se llaman los componentes cuando son clases y el problema lo tiene porque se utlizan los interceptores, por lo que cambia componentDidUpdate por componentWillMount, en la versión 16.8 ya no existe.
        Agrega los catch a las llamadas con axios que faltaban.

    185. Removing Old Interceptors
        Genera propiedades a la clase donde pone el resultado de los interceptors de req y resp, para usarlo en el componentWillUnmount.

        Y utiliza axios.interceptors.request.eject(this.reqInterceptor)
        Y utiliza axios.interceptors.response.eject(this.reqResponse)

        con esto evitamos crear y crear interceptors.

    186. Useful Resources & Links
        Useful Resources & Links
        Find the source code for this module attached to this lecture.

        Recursos de esta clase
        http-burger--01-post-data.zip
        http-burger--02-after-error-hoc.zip
        http-burger--03-finished.zip

### Sección 11: Multi-Page-Feeling in a Single-Page-App: Routing

    187. Module Introduction
    188. Routing and SPAs
        El enrutamiento se trata de poder mostrar diferentes paginas a el usuario.

        Router Package:
        Parsear url / path -> configurar las rutas ->  renderiza / carga el jsx apropiado / componente

    189. Setting Up Links
        Agrega un nav y los links necesarios.

    190. Setting Up the Router Package
        npm install --save react-router react-router-dom

        importamos BrowserRouter y envolvemos el div de app por ej, a partir de ahí en todos los subcomponentes se van a poder acceder a las funcionalidades de este componente. (La funcionalidad sería parecida a la de Context)

        import { BrowserRouter } from 'react-router-dom';
        <BrowserRouter>
        ...
        </BrowserRouter>

    191. react-router vs react-router-dom

        We installed both react-router  and react-router-dom . Technically, only react-router-dom  is required for web development. It wraps react-router  and therefore uses it as a dependency.

        We don't need to install react-router  on our own for it to work. You can omit this installation step, I left it in there for historic reasons and because I like to emphasize that the main package is named react-router. If you ever search for assistance, you probably want to search for "react router" - that's the name of the package.

    192. Preparing the Project For Routing
        Modifica la estructura, cambiando componentes de lugar Post lo saca de adentro de blog...

    193. Setting Up and Rendering Routes
        En Blog, importa Route de react-router-dom

        render -> se le pasa una función por esta prop, dentro de la función se debe retornar jsx
        exact -> prop booleana que exije que se muestre la ruta que realmente es actualmente

        <Route path="/" render={() => <h1>Home</h1>}>

    194. Rendering Components for Routes
        component tiene que hacer referencia a la función o clase que queremos usar por ej Post dentro de Blog.
        En render no debería renderizarse componentes enteros, porque es dificil de mantener después.

        <Route path="/" component={Post}>

    195. Switching Between Pages
        <Route path="/" component={NewPost}>

        Si bien funciona, al pasar de una pagina a otra se recarga toda la pagina y por lo tanto se pierde el state, en el prox muestra como soucionar esto.

    196. Using Links to Switch Pages
        Comenta que no es correcto usar Route, sino que hay que importar y usar Link

        Para eso modifica en en el nav, los <a> por el componente link
        React router genera la etiqueta de anclaje y previene el reload, por lo tanto
        to, apate de ser un string, también se le puede pasar una función, un objeto...

        hash -> esto sirve para si hay algún id con submit, directamente vaya a esa pagina.
        search -> nos habilita a pasar parametros por query

        <Link to="/"> Home</Link>

        Son ejemplos para que sepamos que existen, pero no lo vamos a usar así.
        <Link to={{
            pathname: '/new-post',
            hash: '#submit',
            search: '?quick-submit=true',
        }}> New Post</Link>

        Si hacemos click ahora vamos a ver que no se actualiza la pagina entera (se nota en el icono de reload del navegador, que no se mueve esta vez-)

    197. Using Routing-Related Props
        Muestra en consola las props que tiene Router.

    198. The "withRouter" HOC & Route Props
       Para que un componente que esta routeando a otro, a este último, si queremos pasarle la props de ruteo, hay que decorarlo con withRouter.

    199. Absolute vs Relative Paths
        Absolute: depende siempre del dominio.

        Relative: podes construir la url con las props, ya que vimos que en match viene parte de la url, entonces lo que harías es:
        pathname: this.props.match + '/new-posts'

    200. Absolute vs Relative Paths (Article)
        Absolute vs Relative Paths (Article)
        You learned about <Link> , you learned about the to  property it uses.

        The path you can use in to can be either absolute or relative.

        Absolute Paths
        By default, if you just enter to="/some-path"  or to="some-path" , that's an absolute path.

        Absolute path means that it's always appended right after your domain. Therefore, both syntaxes (with and without leading slash) lead to example.com/some-path .

        Relative Paths
        Sometimes, you might want to create a relative path instead. This is especially useful, if your component is already loaded given a specific path (e.g. posts ) and you then want to append something to that existing path (so that you, for example, get /posts/new ).

        If you're on a component loaded via /posts , to="new"  would lead to example.com/new , NOT example.com/posts/new .

        To change this behavior, you have to find out which path you're on and add the new fragment to that existing path. You can do that with the url  property of props.match :

        <Link to={props.match.url + '/new'}>  will lead to example.com/posts/new  when placing this link in a component loaded on /posts . If you'd use the same <Link>  in a component loaded via /all-posts , the link would point to /all-posts/new .

        There's no better or worse way of creating Link paths - choose the one you need. Sometimes, you want to ensure that you always load the same path, no matter on which path you already are => Use absolute paths in this scenario.

        Use relative paths if you want to navigate relative to your existing path.

    201. Styling the Active Route
        <NavLink
            activeClassName="my-active"
            actuveStyle={{
                color: #6546
                textDecoration: underline
            }}
        >
        de react-router-dom se usa para estilar los links, magicamente te deja estilar los links tiene otras propiedades también, pero bueno la magia de estilar el link que esta activo se maneja con este componente.

        Con actuveStyle se aplican estilos en linea.

    202. Passing Route Parameters
         <Route path="/:id" exact component={Post} />

        Soluciones:

        1) Envolver al post con <Link>, al link en to, agregarle el "/" + id, el key lo tenía post, pero ahora como link es el componente mas externo, lo tiene que manejar él.

    203. Extracting Route Parameters
        Ahora si hacemos props.match.params.id vamos a tener el idque pasamos y seteamos en nuestro <Route>

    204. Parsing Query Parameters & the Fragment
        You learned how to extract route parameters (=> :id  etc).

        But how do you extract search (also referred to as "query") parameters (=> ?something=somevalue  at the end of the URL)? How do you extract the fragment (=> #something  at the end of the URL)?

        Query Params:
        You can pass them easily like this:

        <Link to="/my-path?start=5">Go to Start</Link>

        or

        <Link
            to={‌{
                pathname: '/my-path',
                search: '?start=5'
            }}
            >Go to Start</Link>
        React router makes it easy to get access to the search string: props.location.search .

        But that will only give you something like ?start=5

        You probably want to get the key-value pair, without the ?  and the = . Here's a snippet which allows you to easily extract that information:

        componentDidMount() {
            const query = new URLSearchParams(this.props.location.search);
            for (let param of query.entries()) {
                console.log(param); // yields ['start', '5']
            }
        }
        URLSearchParams  is a built-in object, shipping with vanilla JavaScript. It returns an object, which exposes the entries()  method. entries()  returns an Iterator - basically a construct which can be used in a for...of...  loop (as shown above).

        When looping through query.entries() , you get arrays where the first element is the key name (e.g. start ) and the second element is the assigned value (e.g. 5 ).

        Fragment:
        You can pass it easily like this:

        <Link to="/my-path#start-position">Go to Start</Link>

        or

        <Link
            to={‌{
                pathname: '/my-path',
                hash: 'start-position'
            }}
            >Go to Start</Link>
        React router makes it easy to extract the fragment. You can simply access props.location.hash .

    205. Using Switch to Load a Single Route
        Switch basicamente lo que hace es: cargar la primer ruta que realmente coincida y deja de analizar el resto.

        El orden es importante, tampoco es necesario meter todo dentro del switch, hay que ver que hacer depende de lo que necesitemos.

    206. Navigating Programmatically
        Va a mostrar una alternativa a usar link envolviendo en este caso <Post>

        También podemos usar history y pushear la nueva ruta al historial.

        props.history.push({pathname: "/" + props.match.params.id});

    207. Additional Information Regarding Active Links
        Cuando cambiamos de ruta, si estamos usando <NavLink> para estilar. Dice que como es un caso raro, no pasa nada (?)

    208. Understanding Nested Routes
        Podes utilizar <Route> en cualquier parte de tu aplicación, siempre y cuando el enutador atrape el componente que lo esta utilizando.

        Para que sea realmente dinamico, en vez de hardcodear /post/id, vamos a usar props.match.url, que es la ruta que llamó a ese componente y después se le suma '/:id', por lo tanto va a matchera con la ruta.

    209. Creating Dynamic Nested Routes
        Desde que hicimos las rutas dinamicas, el componente no carga el post especifico, porque como nota que no cambió nada no lo vuelve a renderizar, por lo que para solucionarlo hay que implementar:

        componentDidUpdate()

        mete todo acá y lo llama desde DidUpdate.
        loadData()

        cuando hacemos esto, se genera un loop infinito, por lo que:
            modifica donde usa props.id por props.match.params.id

        después sigue sin funcionar porque tiene chequeo estricto, así que o convertimos a number o le sacamos el stricto y listo.

        
        Otra manera de convertir algo a number es meterle un + adelante.

    210. Redirecting Requests
        Una solución diferente a poner una ruta abajo de la otra es, en el switch utilizar
        <Redirect from="/" to="/post" />

        De esta manera hacemos que el usuario vaya a donde realmente debería estar.

        Por ej si ahora vamos a  /, nos va a redigir a /posts

    211. Conditional Redirects
        Lo que hace es generar por ejemplo un Redirect, solo si el formulario se submitió, entonces renderiza nu componente <Redirect> condicionalmente.

        <Redirect to="/posts">

        No es necesario que le digamos desde donde from=

    212. Using the History Prop to Redirect (Replace)
        Cambiamos el redirect por push con history.
        Push, lo que hace es enviar la pagina a la pila, por ende podemos volver atrás.
        no así con redirect.

        Redirect reemplaza el lugar donde estabamos, por eso no podemos volver atras.

        También existe props.history.replace, que hace lo mismo que redirigir.

    213. Working with Guards
        Basicamente sirve para utilizar en esas surtas que sabes que el usuario necesita estar autenticado.
        Algo asi como el [Authorized] pero autenticado.

        te fijas si el usuario esta logueado y sino no renderizas el componente.

    214. Handling the 404 Case (Unknown Routes)
        Si no se puede catchear ninguna ruta, podemos poner un caso de ruta no encontrada de esta manera:

        <Route render={() => <h1>Not found</h1>} />

        O sea, puede existir la ruta, pero si por ejemplo no la mostramos porque el usuario no esta autenticado, va a terminar cayendo en Not found, y esta ok.

    215. Loading Routes Lazily
        Porque cargamos código del componente que todavía no se navego si no estamos autenticados?

        Todo esta movida vale la pena solamente cuando tenemos una aplicación grande. Cuando es una aplicación chica no se justifica.

        La técnica de descargar solo lo que necesita se conoce como división de código o carga diferida.

        Para esto creamos una carpeta hoc -> AsyncComponent.js

        * ver archivo.

    216. Lazy Loading with React Suspense (16.6)
        En vez de hacer lo que hicimos antes, usamos React.lazy() ej:

        const Post = React.lazy(() => import('./containers/Posts'));

        y después en en vez de levantar el componente en Route, usamos ej:


        <Route
            fallback={<div>Loading...</div>}
            path="/posts"
            render={() => {
                <Suspense>
                    <Posts />
                </Suspense>
            }}
        />

       No necesariamente necesitamos meter esto dentro de BrowserRouter, podemos usar suspense sin Route siquiera.

    217. Routing and Server Deployment
        La primer parte no entendí a que iba, ver otra vez.
        La segunda parte:

            Si tu sitio se aloja en lugar y queda algo asi como
            blabla.com/my-app
            hay que comunicarle esto a react.

            basename por default no es necesario escribirlo y siempre apunta a la raiz ="/".

            Esto se hace en BrowserRouter basename="/my-app"

    Tarea 3: Time to Practice - Routing
    218. Wrap Up
    219. Useful Resources & Links
        React Router Docs: https://reacttraining.com/react-router/web/guides/philosophy
        Recursos de esta clase
        routing--01-start.zip
        routing--02-links-and-routes.zip
        routing--03-after-nested-routing.zip
        routing--04-redirect.zip
        routing--05-finished.zip
        routing--assignment-solution.zip

### Sección 12: Adding Routing to our Burger Project

    220. Module Introduction
    221. Building the Checkout Container

         Crea el componente Checkout, para manejar el estado, ya que es donde se procesan todos los ingredientes, pago etc.


        En App.js
            <Layout>
                <BurgerBuilder />
                <Checkout />
            </Layout>

        Para poner css en linea por ej, hace:
            <div style={{with: 100%, margin: 'auto'}}

    222. Setting Up Routing & Routes

        npm install --save react-router-dom

        En index envuelve app con BrowserRouter.
        En App, usa switch y router para los componentes quee estaba cargando.

    223. Navigating to the Checkout Page

        this.props.history.push('/checkout')

    224. Navigating Back & To Next Page

        en el cancel usa this.props.history.goBack();
        en el de continuar history.replace('/checkout/contact-data')

    225. Passing Ingredients via Query Params

        const queryParams = [];
        for (let i in this.state.ingridients){
            queryParams.push(encodedURIcomponent(i) + '=' + encodedURIcomponent(this.state.ingridients[i]))
        }
        const queryString = queryParams.join('&');

        this.props.history.push({
            pathName: '/checkout',
            search= '?' + queryString
        })

        En Checkout, agrega la logica para obtener la info.

        Ver en resources/section_12/routing-burger-02-query-params

    226. Navigating to the Contact Data Component

    227. Order Submission & Passing Data Between Pages

    228. Adding an Orders Page

    229. Implementing Navigation Links

    230. Fetching Orders

    231. Outputting the Orders

    232. Wrap Up

    233. Useful Resources & Links
        Find the source code for the module attached to this lecture.

        Recursos de esta clase
        routing-burger--01-first-routes.zip
        routing-burger--02-query-params.zip
        routing-burger--03-finished.zip

### Sección 13: Forms and Form Validation

    234. Module Introduction
    235. Analyzing the App
        Habla de poner los input en su propio componente para poder centralizar, poner label y algún manejo de errores.

    236. Creating a Custom Dynamic Input Component
        Lo mete dentro de la carpeta components > UI
        Genera css, y le pasa la info desde el form que lo usa, no más que eso

    237. Setting Up a JS Config for the Form
        Genera un objeto con los inputs que va a tener el formulario, ej:

        orderForm: {
            name: {
                elementType: 'input',
                elementConfig: {
                    type: 'text',
                    placeholder: 'Your Name'
                },
                value: '',
                validation: {
                    required: true
                },
                valid: false,
                touched: false
            },
        }

    238. Dynamically Create Inputs based on JS Config
         después dinamicamente genera el form:

        <form onSubmit={this.orderHandler}>
                {formElementsArray.map(formElement => (
                    <Input
                        key={formElement.id}
                        elementType={formElement.config.elementType}
                        elementConfig={formElement.config.elementConfig}
                        value={formElement.config.value}
                        invalid={!formElement.config.valid}
                        shouldValidate={formElement.config.validation}
                        touched={formElement.config.touched}
                        changed={(event) => this.inputChangedHandler(event, formElement.id)} />
                ))}
                <Button btnType="Success" disabled={!this.state.formIsValid}>ORDER</Button>
            </form>

    239. Adding a Dropdown Component
        Genera en el switch el código para renderizar selects

    230. Handling User Input
        Le agrega los onchage a los input y genera la función:

        inputChangedHandler = (event, inputIdentifier) => {
            const updatedOrderForm = {
                ...this.state.orderForm
            };
            const updatedFormElement = {
                ...updatedOrderForm[inputIdentifier]
            };
            updatedFormElement.value = event.target.value;
            updatedFormElement.valid = this.checkValidity(updatedFormElement.value, updatedFormElement.validation);
            updatedFormElement.touched = true;
            updatedOrderForm[inputIdentifier] = updatedFormElement;

            let formIsValid = true;
            for (let inputIdentifier in updatedOrderForm) {
                formIsValid = updatedOrderForm[inputIdentifier].valid && formIsValid;
            }
            this.setState({orderForm: updatedOrderForm, formIsValid: formIsValid});
        }

    241. Handling Form Submission
        Genera la función que va a utilizar el formulario al submitirse.

        orderHandler = ( event ) => {
            event.preventDefault();

            const formData = {};
            for (let formElementIdentifier in this.state.orderForm) {
                formData[formElementIdentifier] = this.state.orderForm[formElementIdentifier].value;
            }
            const order = {
                ingredients: this.props.ings,
                price: this.props.price,
                orderData: formData,
                userId: this.props.userId
            }

            this.props.onOrderBurger(order, this.props.token);

        }

    242. Adding Custom Form Validation
        Genera la función, con la que se valida si esta bien lla info ingresada en los input o no.

        checkValidity(value, rules) {
            let isValid = true;
            if (!rules) {
                return true;
            }

            if (rules.required) {
                isValid = value.trim() !== '' && isValid;
            }

            if (rules.minLength) {
                isValid = value.length >= rules.minLength && isValid
            }

            if (rules.maxLength) {
                isValid = value.length <= rules.maxLength && isValid
            }

            if (rules.isEmail) {
                const pattern = /[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/;
                isValid = pattern.test(value) && isValid
            }

            if (rules.isNumeric) {
                const pattern = /^\d+$/;
                isValid = pattern.test(value) && isValid
            }

            return isValid;
        }
    243. Fixing a Common Validation Gotcha
        Mejora esto:

        if (rules.required) {
            isValid = value.trim() !== '' && isValid;
        }

    244. Adding Validation Feedback
        if (props.invalid && props.shouldValidate && props.touched) {
            inputClasses.push(classes.Invalid);
        }

    245. Improving Visual Feedback
        Agrega la propiedad touche: false, esto es para que los input no arranquen rojos, como que tuvieran mal la validación.

    274. Showing Error Messages
        We're not showing any error messages in our form, but you can of course easily add some.

        The form inputs (<Input />  component) already receives the information whether it's invalid or not. You could of course easily add some conditionally rendered element inside of that component.

        For example (inside <Input />  component function):

        // all the other code from the videos

        let validationError = null;
        if (props.invalid && props.touched) {
            validationError = <p>Please enter a valid value!</p>;
        }

        return (
            <div className={classes.Input}>
                <label className={classes.Label}>{props.label}</label>
                {inputElement}
                {validationError}
            </div>
        );
        This could of course be finetuned. You could also pass the value type (e.g. "email address" ) as a prop:

        validationError = <p>Please enter a valid {props.valueType}</p>;

        You could also receive the complete error message as a prop:

        validationError = <p>{props.errorMessage}</p>;

        And of course, also don't forget to style the messages if you want to do that:

        validationError = <p className={classes.ValidationError}>{props.errorMessage}</p>;

        In your CSS file, you could have:

        .ValidationError {
            color: red;
            margin: 5px 0;
        }

    247. Handling Overall Form Validity
        Agrega formValid a los controles del form.

        Hace que el boton no este habilitado si no estan todos los inputs requeridos validados.

    248. Working on an Error
        Arregla un problema con el combo.
        Agrega un validation: {} en el control del select, para que no de error.

    249. Fixing a Bug
        Le pone un valor por defecto al combo, para que se posicione en un value, dice que lo va a arreglar después ??

    250. Useful Resources & Links
        Validate.js (you may import its functionality into your React projects): https://validatejs.org/
        Get more ideas about potential validation approaches: https://react.rocks/tag/Validation
        Alternatives to the manual approach taken in this course:

        react-validation package: https://www.npmjs.com/package/react-validation
        formsy-react package: https://github.com/christianalfoni/formsy-react
        Recursos de esta clase
        forms--01-basic-form.zip
        forms--02-form-validation.zip
        forms--03-finished.zip

### Sección 14: Redux

    251. Module Introduction
        State management, que es el estado y como funciona redux.

    252. Understanding State
        Ingredientes nuevos
        Esta el usuario autenticado?
        El modal esta abierto?
        lista de posteos en nuestro blog, etc...

    253. The Complexity of Managing State
        Si bien podemos manejar el estado y pasar información de un componente A a un componente B mediante queryString a travez de las rutas, se vuelve inmanejable cuando crece la app.

        Si queremos pasar por ej, la información de autenticación de un componente A a B, se puede tornar muy engorroso ya que o lo vamos a manejar pasando de props en props y componentes.. o queryStrings, ahí aparece redux en acción...

    254. Understanding the Redux Flow
        Redux es una libreria de terceros, que si bien vemos que se puede integrar con React, se puede usar sola.

        Como maneja los datos y como se actualiza?

        CentralStorage:
            Tiene el estado de toda la aplicación

        Acciones:
            - Se envian (dispatch) desde los componentes.
            - Un action, es un es un paquete de información predefinida, por ej "Agregar componente" o "Eliminar componente"
            - Posiblemente también tenga un payload, por ej, si la acción es un ingrediente, necesitamos pasar toda la información sobre QUE ingrediente
            - Una acción no sabe como operar el central storage, no tiene logica, es solo un mensajero.

        Reducers:
            - Se utiliza para cambiar el central storage.
            - Es una función pura que recibe la acción y el estado viejo.
            - Podemos combinar diferentes reducers en 1. Pero en el "final", simplemente es una ruta reducer que se conecta directamente con el central storage.
            - El reducer puede chequear el tipo de la acción , por ej si es agregar un ingrediente, y cuando definimos el codigo para ese tipo de acción y luego "escupe" un estado actualizado.
            - El reducer ejecuta codigo sincronico, por ende no ejecuta HTTP request, no side effects, nada. Es solo información entrando, respuesta saliendo, nada de delay, igual vamos a aprender a hacer cosas asincronicas.
            - El reducer actualiza el estado del central storage, de una manera inmutable, por lo que siempre retornamos un nuevo estado, que es basado en el viejo pero es tecnicamente un nuevo objeto javascript, porque los objetos son de tipo de referencia y no queremos que accidentalmente cambiemos el objeto viejo.

        Subscriptions Model (Subscriptors?):
             - Sirve para que una vez que el reducer actualiza el estado del central storage, se triggeree la finromación nuevamente al componente que lo necesitaba, para ello el componente debe estar subscripto al modelo de subscripción.

        EJ:
            Tenemos un componente que quiere manipular el estado, este no lo actualiza directamente modificando central storage

    255. Setting Up Reducer and Store
        Comenta que agrego un proyecto para que bajemos y con el que vamos a ejercitar redux.

        1) Instalación redux:
            > npm install --save redux
        2) Crea el archivo redux-basics.js acá va a poner el Store, Reducer, Dispatching Action, Subscription.

        Estado incial del estado..
            const initialState = {
                counter: 0;
            }

        Reducer:
            Es una función rootReducer que recibe el estado y la acción por parametro.
            return state;

            const rootReducer = (state = initialState, action) => {
                return state;
            }

        Store:
            const store = createSotre(rootReducer) ;nos habilita a crear un nuevo store.
                                                    un Store, necesita ser inicializado con un reducer.
            connsole.log(sotre);

    256. Dispatching Actions
        Una acción es "enviada" por simplemente acceder al store.


        // Dispatching
         // recibe como parametro una acción, un objeto, que si o si tiene que ser type, por convención su valor tiene que estar todo en mayus.
        store.dispatch({ type: 'INC_COUNTER' });
        store.dispatch({ type: 'INC_COUNTER', value: 10 }); // tiene otro parametro opcional.


        const rootReducer = (state = initialState, action) => {
            if(action.type === 'INC_COUNTER'){
                // state.counter++ -> esto no se puede hacer porque estas mutando su estado original.
                return {
                    ...state,
                    counter: state.counter + 1; // obtiene el estado que acabo de desesctructurar y ahi si, en un nuevo obj le sumo 1.
                };
            }

            return state;
        }

    257. Adding Subscriptions
        // Subscription -> Tienqe que ir antes de los dispatchers.

        store.suscribe(() => {
            console.log('[Suscripción]', store.getState());
        }) // como parametro toma una función que se va a ejecutar cada vez que se actualice el estado.

    258. Connecting React to Redux
         Tenemos que tener en cuenta que hay aplicaciones que no necesitan redux porque no son tan complejas...

         en el archivo index.js, importamos redux:
            import { createStore } from 'redux';

            // antes de que se renderice la app:
            const store = createStore(reducer);

        # ! Generalmente se puede ver en la estructura del proyecto que hay una carpet store. #

        crea la carpeta store, adentro crea un archivo reducer.js:

            const initialState = {
                counter: 0
            }

            const reducer = (state = initialState, action) => {
                return state;
            }

            export default reducer;

    259. Connecting the Store to React
        Instalamos react-redux, para conectar el store con nuestra app react:
            npm install --save react-redux;

        index.js
            import { Provider }  from 'react-redux';

            envolvemos el componente a renderizar <App /> con el componente Provider.

        Provider:
            Es un helper component, que nos habilita a "inyectar" nuestro store dentro de los componentes de react.
            le tenemos que pasar una propiedad, le vamos a poner store por sentido comun, y le pasamos el store que creamos.
            <Provider store={}> <App /> </Provider>

        Counter.js
            Importamos un hoc, una función de redux que nos permite ocnectar con nuestro store. O sea, no es realmente un hoc, sino una función que retorna un hoc.
            En grandes aplicaciones podríamos tener montones y montones de diferentes estados y piezas de estados que manejar.

            import { connect } from 'redux';

            const mapStateToProps = state => {
                return {
                    ctr: state;
                }
            }
            export default connect(mapStateToProps)(Counter); // En el primer param le pasamos cierta config.

            Al hacer esto ahora en nuestro componente, donde mostramos el value que crece o decrece, simplemente utilizamos la prop que acabamos de generar y pasarle a connect:

            // value={this.state.counter}
            <CounterOutput value={this.props.ctr} />

    260. Dispatching Actions from within the Component
        Ahora vamos a aprender a enviar acciones desde nuestro componente.

        También necesitamos una función para enviarle por parametro a connect e informarle que acciones queremos realmente que se envien.

        // retorna un obj javascript que va a tener la función que cuando se ejecute va a enviar una acción.
        // pasariamos como nulo el primer parametro a connect si no es necesario, segun lo que tengamos en nuestro componente.
        const mapDispatchToProps = dispatch => {
            return {
                onIncrementCounter: () => dispatch({type: 'INCREMENT'})
            };
        }

        Ahora en el componente <CounterControl pasamos en la prop donde tenemos el handler de la función que hace el incremento, simplemente pasamos this.props.onIncrementCounter


        Ahora tenemos que actualizar en nuestro archivo reducer, el if que verifica las acciones que van llegando.

    Tarea 4: Time to Practice - Dispatching Actions
    261. Passing and Retrieving Data with Action
        cuando pasamos info al dispatch, en el segundo parametro, podemos pasar info por el action.
        después lo manejamos en el reducer.

    262. Switch-Case in the Reducer
        statement expression: switch

        en el caso default, retornamos solo state;

    263. Updating State Immutably
        en el case arregla los return:

        const newState = Object.assign({}, state);
        newState.counter= state.counter + 1;
        return newState;

        una mejor manera:

        case 'DECREMENT':
            return {
                ...state,
                counter: state.counter + action.val
            }

        // en este caso esta es la manera correcta:
        case 'STORE_RESULT':
            return {
                ...state,
                results: state.results.concat(state.counter)
            }

        Agrega a mapStateToProps una propiedad:

            storedResults: state.results;

    264. Updating Arrays Immutably


        Para eliminar info de un array se usa splice, pero como este lo hace sobre el array existe y nosotros no podemos mutar el original, muestra dos opciones:

        1)
            const id = 2;
            const newArray = [...state.results]
            newArray.splice(id, 1);

            case 'DELETE_RESULT':
            return {
                ...state,
                results: newArray
            }

        2) const updatedArray = state.results.filter(result => result.id !== action.resultElId);

            case 'DELETE_RESULT':
            return {
                ...state,
                results: updatedArray
            }

    265. Immutable Update Patterns
        Immutable Update Patterns on reduxjs.org: http://redux.js.org/docs/recipes/reducers/ImmutableUpdatePatterns.html

        Updating Nested Objects
        The key to updating nested data is that every level of nesting must be copied and updated appropriately. This is often a difficult concept for those learning Redux, and there are some specific problems that frequently occur when trying to update nested objects. These lead to accidental direct mutation, and should be avoided.

        Common Mistake #1: New variables that point to the same objects
        Defining a new variable does not create a new actual object - it only creates another reference to the same object. An example of this error would be:

        function updateNestedState(state, action) {
            let nestedState = state.nestedState;
            // ERROR: this directly modifies the existing object reference - don't do this!
            nestedState.nestedField = action.data;

            return {
                ...state,
                nestedState
            };
        }
        This function does correctly return a shallow copy of the top-level state object, but because the nestedState variable was still pointing at the existing object, the state was directly mutated.

        Common Mistake #2: Only making a shallow copy of one level
        Another common version of this error looks like this:

        function updateNestedState(state, action) {
            // Problem: this only does a shallow copy!
            let newState = {...state};

            // ERROR: nestedState is still the same object!
            newState.nestedState.nestedField = action.data;

            return newState;
        }
        Doing a shallow copy of the top level is not sufficient - the nestedState object should be copied as well.

        Correct Approach: Copying All Levels of Nested Data
        Unfortunately, the process of correctly applying immutable updates to deeply nested state can easily become verbose and hard to read. Here's what an example of updating state.first.second[someId].fourth might look like:

        function updateVeryNestedField(state, action) {
            return {
                ...state,
                first : {
                    ...state.first,
                    second : {
                        ...state.first.second,
                        [action.someId] : {
                            ...state.first.second[action.someId],
                            fourth : action.someValue
                        }
                    }
                }
            }
        }
        Obviously, each layer of nesting makes this harder to read, and gives more chances to make mistakes. This is one of several reasons why you are encouraged to keep your state flattened, and compose reducers as much as possible.

        Inserting and Removing Items in Arrays
        Normally, a Javascript array's contents are modified using mutative functions like push, unshift, and splice. Since we don't want to mutate state directly in reducers, those should normally be avoided. Because of that, you might see "insert" or "remove" behavior written like this:

        function insertItem(array, action) {
            return [
                ...array.slice(0, action.index),
                action.item,
                ...array.slice(action.index)
            ]
        }

        function removeItem(array, action) {
            return [
                ...array.slice(0, action.index),
                ...array.slice(action.index + 1)
            ];
        }
        However, remember that the key is that the original in-memory reference is not modified. As long as we make a copy first, we can safely mutate the copy. Note that this is true for both arrays and objects, but nested values still must be updated using the same rules.

        This means that we could also write the insert and remove functions like this:

        function insertItem(array, action) {
            let newArray = array.slice();
            newArray.splice(action.index, 0, action.item);
            return newArray;
        }

        function removeItem(array, action) {
            let newArray = array.slice();
            newArray.splice(action.index, 1);
            return newArray;
        }
        The remove function could also be implemented as:

        function removeItem(array, action) {
            return array.filter( (item, index) => index !== action.index);
        }
        Updating an Item in an Array
        Updating one item in an array can be accomplished by using Array.map, returning a new value for the item we want to update, and returning the existing values for all other items:

        function updateObjectInArray(array, action) {
            return array.map( (item, index) => {
                if(index !== action.index) {
                    // This isn't the item we care about - keep it as-is
                    return item;
                }

                // Otherwise, this is the one we want - return an updated value
                return {
                    ...item,
                    ...action.item
                };
            });
        }
        Immutable Update Utility Libraries
        Because writing immutable update code can become tedious, there are a number of utility libraries that try to abstract out the process. These libraries vary in APIs and usage, but all try to provide a shorter and more succinct way of writing these updates. Some, like dot-prop-immutable, take string paths for commands:

        state = dotProp.set(state, `todos.${index}.complete`, true)
        Others, like immutability-helper (a fork of the now-deprecated React Immutability Helpers addon), use nested values and helper functions:

        var collection = [1, 2, {a: [12, 17, 15]}];
        var newCollection = update(collection, {2: {a: {$splice: [[1, 1, 13, 14]]}}});
        They can provide a useful alternative to writing manual immutable update logic.

        Immutable Data#Immutable Update Utilities section of the Redux Addons Catalog.

    266. Outsourcing Action Types
        Recomienda por ej en un archivo acions.js crear constantes para las acciones, así si hay un error de tipo sabes donde puede estar el problema, y no tenes que andar buscando por toda la app donde pusiste esa variable para el dispatcher y que le pifiaste.

        export const INCREMENTE = 'INCREMENT';
        export const DECREMENT = 'DECREMENT';
        ...ETC

    267. Combining Multiple Reducers
        Divide los reducers en diferentes archivos. Crea una carpeta reducers > counter.js, result.js

        en counter pone los de decremento y incremento.
        en result pone store result y delete result.
        a ambos los exporta default reducer;

        para combinarlos en el archivo index, aparte de importarlos, importa una helper function del paquete de readux, que se llama combineReducers

        const rootReducer = combineReducers({
            ctr: counterReducer,
            res: resultReducer
        });

        y después al createStore se le pasa rootReducer.

    268. Understanding State Types
        Dice que para una aplicación chiquita no es necesario usar redux, pero para una chica>mediana, si. Pero que de todas maneras no es necesario que toda la app lo use, simplemente hay que analizar donde se necesita.

        Tipos de estado:

        Type:               Example:                Use Redux?:
        loca ui state      show / hide backdrop     mostly handled within components.
        Persistent state     All Users... All posts..    Stored on Server, relevant slice managed by Redux.
        Client State        Esta autenticado? Filter set by User        Managed via Redux.


        * No olvidarse que si el usuario recarga la pagina, el estado se pierde, redux no reemplaza una base de datos. *
    Tarea 5: Time to Practice - Redux Basics

    269. [OPTIONAL] Assignment Solution
        Solución por él de la tarea.

    270. Combining Local UI State and Redux
        Muestra combina los dos, useState para manejar los valores que usa el usuario en los input.
        Y en el boton que usa la función que se creo para redux dentro de mapDispatchToProps

    271. Wrap Up
    302. Useful Resources & Links
        Redux Docs: http://redux.js.org/
        Core Concepts: http://redux.js.org/docs/introduction/CoreConcepts.html
        Actions: http://redux.js.org/docs/basics/Actions.html
        Reducers: http://redux.js.org/docs/basics/Reducers.html
        Redux FAQs: http://redux.js.org/docs/FAQ.html
        Recursos de esta clase
        redux--01-start.zip
        redux--02-basic-flow.zip
        redux--03-react-redux.zip
        redux--04-improved-setup.zip
        redux--05-finished.zip
        redux--assignment-1-solution.zip
        redux--assignment-2-solution.zip

### Sección 15: Adding Redux to our Project

    273. Module Introduction
        Analiza la app de la hamburguesa, para ver donde puede usar Redux y donde deja state.

        Analiza que es local ui state.

    274. Installing Redux and React Redux

    275. Basic Redux Setup

    276. Finishing the Reducer for Ingredients

    277. Connecting the Burger Builder Container to our Store

    278. Working on the Total Price Calculation

    279. Redux & UI State

    280. Adjusting Checkout and Contact Data

    281. Wrap Up
    282. Useful Resources & Links
        Find the source code for this module attached to this lecture.

        Recursos de esta clase
        redux-burger--01-basic-setup.zip
        redux-burger--02-finished.zip

### Sección 16: Redux Advanced

    283. Module Introduction

    284. Adding Middleware

    285. Using the Redux Devtools

    286. Executing Asynchronous Code - Introduction

    287. Introducing Action Creators

    288. Action Creators & Async Code

    289. Handling Asynchronous Code

    290. Restructuring Actions

    291. Where to Put Data Transforming Logic?

    292. Using Action Creators and Get State

    293. Using Utility Functions

    294. A Leaner Switch Case Statement

    295. An Alternative Folder Structure

    296. Diving Much Deeper

    297. Wrap Up
    298. Useful Resources & Links
        Middleware: http://redux.js.org/docs/advanced/Middleware.html

        redux-thunk package: https://github.com/gaearon/redux-thunk

        Async Actions: https://redux.js.org/advanced/asyncactions

        Recursos de esta clase
        redux-adv--01-start.zip
        redux-adv--02-action-creators.zip
        redux-adv--03-async-actions.zip
        redux-adv--04-finished.zip

### Sección 17: Redux Advanced: Burger Project

    299. Module Introduction

    300. Installing the Redux Devtools

    301. Preparing the Folder Structure

    302. Creating Action Creators

    303. Executing Asynchronous Code

    304. Fetching Ingredients Asynchronously

    305. Initializing Ingredients in the BurgerBuilder

    306. Changing the Order of our Ingredients Manually

    307. Adding Order Actions

    308. Connecting Contact Data Container & Actions

    309. The Order Reducer

    310. Working on Order Actions

    311. Redirect to Improve UX

    312. Combining Reducers

    313. Handling Purchases & Updating the UI

    314. Resetting the Price after Purchases

    315. Fetching Orders (via Redux)

    316. Checking our Implemented Functionalities

    317. Refactoring Reducers

    318. Refactoring Reducers Continued

    319. Wrap Up
    320. Useful Resources & Links
        Find the source code for this module attached to this lecture.

        Recursos de esta clase
        redux-adv-burger--01-async-action-ingredients.zip
        redux-adv-burger--02-finished.zip

### Sección 18: Adding Authentication to our Burger Project

    321. Module Introduction
        En MPA generalmente esto se maneja en el servidor mediante session. Acá tenemos un solo archivo, así que vamos a ver como se maneja...

    322. Understanding Authentication in Single Page Applications
        SPA -> envia un auth al SERVER, el server no devuelve una sesión sino un TOKEN (json), generalmente se guarda en el localStorage, no se puede guardar en el estado porque si refresca la pagina se pierde..
        Para hacer ciertos request necesitamos estar autenticados, entonces para no andar validando eso todo el tiempo en el request se envia el token con cierta información

        Si bien acá usamos Firebase, el token se puede generar en cualuqier server.

    323. Required App Adjustments
        Comenta que va a agregar una vista, que es el formulario de inicio de sesión, que también tenemos que manejar en que endpoints vamos a pedir autenticación y por ultimo tenemos que pasar el token para poder hacer lo anterior.

    324. Adding an Auth Form
        Dentro de containers crea un nuevo componente Auth.
        Reutiliza lo que hizo en el modulo de Form y validaciones.

        Le agrega un css, actualiza codigo..etc

    325. Adding Actions
        Al final termina usando redux..
        Agrega un tipo de acción al archivo actionsTypes.js
        crea un archivo auth.js dentro de la carpeta actions.
        // TODO: terminar de ver

    326. Getting a Token from the Backend
        En firebase va a la sección de autenticación, y muestra que hay una opción para marcar donde elegis quedarte con el usuario y password del usuario y se aloja en firebase.
        Enable > save.

        Busca en Google firebase rest auth
        Busca en Firebase el api key, para pegarle al nuevo endpoint.
        Autenticación > web setup

        Elige la url de sing up, la pone dentro del archivo auth, que esta dentro de la carpeta store > actions > auth.js en la parte donde se exporta la función auth, ahí hace el post.

        Verifica que datos tiene que mandarle en el body al endpoint, lo prueba y muestra por consola que le retorno bien la info.

    327. Adding Sign-In

    328. Storing the Token
        Dentro de la carpeta reducer, genera un archivo auth.js

    329. Adding a Spinner

    330. Logging Users Out

    331. Accessing Protected Resources

    332. Updating the UI Depending on Auth State

    333. Adding a Logout Link

    334. Forwarding Unauthenticated Users

    335. Redirecting the User to the Checkout Page

    336. Persistent Auth State with localStorage
        Agrega en el local storage el token que obtiene, y también en localStorage agrega un expirationDate.

        let expirationDate = new Date(new Date().getTime() + response.data.expiresIn * 1000);
        localStorage('expirationDate', expirationDate);

    337. Fixing Connect + Routing Errors

    338. Ensuring App Security

    339. Guarding Routes

    340. Displaying User Specific Orders

    341. Wrap Up
    342. Useful Resources & Links
        SPA Authentication in general: https://stormpath.com/blog/token-auth-spa
        Firebase authentication REST API: https://firebase.google.com/docs/reference/rest/auth/
        Recursos de esta clase
        auth--01-form-actions.zip
        auth--02-auth-store.zip
        auth--03-token.zip
        auth--04-finished.zip

### Sección 19: Improving our Burger Project

    343. Module Introduction
    344. Fixing the Redirect to the Frontpage
        Arregla un flag que le había quedado mal en purchaseBurgerStart (el loading lo pasó a true)

        Cuando submite la orden, se redirige al index con todo vacio.
            Vuelve a poner la ruta de auth, porque dentro de ese componente estaba la funcionalidad y como no hace daño volver a ponerlo, es la solucion mas rapida que encontró.

        fixea el css de la hamburgeusa porque no esta bien centrado..

    345. Using updateObject in the Entire App
        Crea una carpeta shared y pasa el archivo utility.js ahí adentro.
        actualiza las referencias al archivo en los import.

        en updatedFormElement = updateObject(this.state.orderForm[inputIdentifier],
            value: event.target.value,
            valid: this.checkValidity(updatedFormElement.value, updatedFormElement.validation),
            touched: true
        )

        mismo para orderForm

        verifica en otros archivos y hace lo mismo.

    346. Sharing the Validation Method
        a la función checkValidity, la mete en el archivo utility.js, la usa para validar cosas del formulario.

        elimina el metodo de los archivos, importa la función y le saca el this a la función en los archvos.

    347. Using Environment Variables
        Hace que la dev tools de redux se vea solo en dev con las variables de entorno.

    348. Removing console.log()s
        Elimina los console.log...

    349. Adding Lazy Loading
        Carga diferida.
        Agrega dentro de la carpeta hoc > asyncComponent
        le pega info que hizo en la sección de enrutamiento

        Genera una para cada una, order, auth, etc.

        * No se debe usar siempre y para cualquier cosa, porque si son cosas chicas ni vale la pena hacer esto.

    350. Wrap Up
    351. Useful Resources & Links
        Find the source code for this module attached to this lecture.

        Recursos de esta clase
        burger-improvements--01-finished.zip

### Sección 20: Testing

    352. Module Introduction
    353. What is Testing?
        Build App > Testear manualmente en el navegador > Tests Automaticos > Ship App to Server.

    354. Required Testing Tools
        Necesitamos 2 cosas:

        Un corredor de test.
        Ejecutar test y tener una libreria de validación.
        React viene con Jest instalado.

        Generamos test unitarios
        Simulamos la app, montamos componentes y de esto nos permite consumir el DOM.
        React Test Units.

        Enzyme es otra herramienta como Jest, creada por el equipo de Airbnb (también recomendada por el team de React), esta herramienta hace mas facil montar componentes y navegar entre ellos.

    355. What To Test?

        Que NO queres testear:
            No queres testear la libreria, ni react, ni axios, redux, etc. Todo esto ya fue testeado por el que lo creó.

            No queres testear conecciones complejas.

        Lo que si queres:
            - Mockear y generar data fake.
            - Unidades aisladas, por ej una función que creaste, un componente.
            - Output condicional.

    356. Writing our First Test

        enzyme             -> Nos permite cargar un componente por si mismo, sin dependenr de toda la app.
            Estos dos packages, son complementos para enzyme.
            react-test-render           -> dependencia de enzyme.
            enzyme-adapter-react-16     -> adaptador de enzyme para nuestra versión actual.

        jest               -> ya viene instalado.

        npm install --save enzyme react-test-render

        Va a testear NavigationItems, en la misma carpeta crea un js con el mismo nombre del componente pero le agrega test, ej: NavigationItems.test.js

        describe es una función que toma 2 argumentos
            1) Lo que se va a testear, el puso el nombre del componente x ej
            2) Testing arrow function.

        It te permite escribir un test individual, también tiene 2 argumentos.
            1) Una descripción de lo que se esta testeando
            2) Testing arrow function.

        import React from 'react';
        import { configure, shallow } from 'enzyme';
        import Adapter from 'enzyme-adapter-react-16';

        import NavigationItems from './NavigationItems';
        import NavigationItem from './NavigationItem/NavigationItem';

        // Para conectar enzyme con mi app.
        configure({adapter: new Adapter});

        describe('<NavigationItems />', () => {
            it('should render two <NaviationItems /> elements if not authenticated', () => {
                // testing logic
                const wrapper = shallow(<NavigationItems />);
                expect(wrapper.find(NavigationItem)).toHaveLength(2); // osea, que haya 2 componentes.
            })
        })

        * shallow, es un helper (una función),que usamos para renderizar el componente con todo su contenido, pero todo no es completamente cargado, osea no todo el sub arbol de componentes.
        * wrapper en realidad puede ser pepito.
        * en expect definimos lo que queremos chequear.
        * find es una utilidad de enzyme que nos permite ver dentro del componente y chequear si existe lo que necesitamos.

        Para correr los test, primero chequeamos que en package.json este el script de test.

        npm test
        * Si llega a haber un error, eliminar el test de App.test.js

    357. Testing Components Continued

        // Agrego otro test, ahora verifico que haya 3 componentes y le paso al componente la prop que necesita para que se rendericen los 3.

        import React from 'react';
        import { configure, shallow } from 'enzyme';
        import Adapter from 'enzyme-adapter-react-16';

        import NavigationItems from './NavigationItems';
        import NavigationItem from './NavigationItem/NavigationItem';

        // Para conectar enzyme con mi app.
        configure({adapter: new Adapter});

        describe('<NavigationItems />', () => {
            // Si se repiten ciertas cosas, podemos usar este setup general:
            let wrapper;

            beforeEach(() => {
                wrapper = shallow(<NavigationItems />);
            })

            it('should render two <NaviationItems /> elements if not authenticated', () => {
                expect(wrapper.find(NavigationItem)).toHaveLength(2); // osea, que haya 2 componentes.
            });

            it('should render two <NaviationItems /> elements if not authenticated', () => {
                // Como este necesitaba que se pase una prop para correr bien, lo podemos setear de esta manera:
                wrapper.setProps({ isAuthenticated: true });
                expect(wrapper.find(NavigationItem)).toHaveLength(3);
            })
        })

    358. Jest and Enzyme Documentations

        Para ver todas las cosas que podemos usar de los packages:
        Enzyme API: http://airbnb.io/enzyme/docs/api/
        Jest Docs: https://facebook.github.io/jest/

        it('should render two <NaviationItems /> elements if not authenticated', () => {
            wrapper.setProps({ isAuthenticated: true });
            expect(wrapper.contains(<NavigationItem link="/logout"> Logout </NavigationItem)).toEqual(True);
        })

    359. Testing Components Correctly

        Escribir test correctos es complicado. Siempre hay algo que se nos puede escapar.
        Lo que dice es que hay que escribir test de las cosas que sabemos que pueden romper todo, por ej un if negado, cuando no era negado y así.

    360. Testing Containers

        Como tenemos setProps también tenemos setTest para poder mockear estados.

        Le agregamos export adelante de la clase, para exponerla y poder testearla. Esto no choca con el export default que ya tenemos.

        en el test, por ej BurgerBuilder.test.js, la importamos así:

        import { BurgerBuilder } from './BurgerBuilder';

        Lo que hace es verificar si se encontra el componente BurgerBuilder, ya que se muestra solo si no hay ingredientes.

    361. How to Test Redux

        Hay testear Redux, pero hay que tener cuidado qué testeamos.
        Si seguimos el patron de no poner demasiada logica dentro de en la creación de los actions.
        Como son sincronicos y funciones que se les pasa y devuelven algo, es mas facil de testear.

        import reducer from './auth';
        import * as actionTypes from '../actions/actionTypes';

        describe('auth reducer', () => {
            it('should return the initial state', () => {
                expect(reducer(undefined, {})).toEqual({
                    token: null,
                    userId: null,
                    error: null,
                    loading: false,
                    authRedirectPath: '/'
                });
            });

            it('should store the token upon login', () => {
                expect(reducer({
                    token: null,
                    userId: null,
                    error: null,
                    loading: false,
                    authRedirectPath: '/'
                }, {
                    type: actionTypes.AUTH_SUCCESS,
                    idToken: 'some-token',
                    userId: 'some-user-id'
                })).toEqual({
                    token: 'some-token',
                    userId: 'some-user-id',
                    error: null,
                    loading: false,
                    authRedirectPath: '/'
                });
            })
        });

    362. Wrap Up
    363. Useful Resources & Links
        Enzyme API: http://airbnb.io/enzyme/docs/api/
        Jest Docs: https://facebook.github.io/jest/
        Recursos de esta clase
        testing--01-finished.zip

### Sección 21: Deploying the App to the Web

    364. Module Introduction
    365. Deployment Steps
        chequear y quizas actualizar basePath
        buildear y optimizar el proyecto.
            -> npm run build // in create-react-app project
        el servidor siempre tiene que servir el index.html (sino da 404) ->
        actualizar el artefacto a static del build
            ->  githubpages o firebase se puede implementar porque es todo estatico, no hace falta un servidor, tendría que haber una carpeta /build

    366. Building the Project
        corre el comando npm run build
        muestra la carpeta build que se creo con todo minimizado...

    367. Example: Deploying on Firebase
        En la consola de firebase > setup hosting > npm install -g firebase-tools > continue > firebase login > firebase init > firebase deploy
        hosting hay que elegir en login, después la carpeta build, si, es una SPA, no a sobreescribir el index y listo
        te genara un link tipo firebase.burgerApp.com bla entras y listo.

        parecido a heroku.

    368. Wrap Up
    369. Useful Resources & Links
        Useful Resources & Links
        Attached to this lecture, you'll find the module source code.

        Recursos de esta clase
        deployment--01-finished.zip

### Sección 22: Bonus: Working with Webpack

    370. Module Introduction
    371. Introducing Webpack

        Es un bundler, pero es mas que eso. Un bundler solo concatenaría archivos.

        También optimiza archivos, conectar complementos, loaders, transformarlos, transpilarlos, etc.

        La de gral es: tenes multiples archivos, js, css e imagenes, cualquier archivo y lo que hace webpack es analizar cada uno, bundlearlos pero a su vez, verificar cuales estan conectados (imports)...

    372. How Webpack works

        De tras de escena, webpack tiene 4 features importantes:

        1) Necesita al menos un entry point, por ej App.js
            Ya que ahí es donde se inserta todo en el dom y analiza este archivo verificando sus dependencias.

        2) Loaders:
            Esto esta en el medio, ej loaders (babel-loader, css-load). O sea, lo que vos le decis al loeader es como va a manejar todos los archivos de un determinado tipo, por ejemplo los de js van a ser manejados por tal package.

        3) Plugins:
            Concatenan los files, ej uglify, esta de manera global, minifica los archivos, optimizandolos.

        4) Analiza todas las dependencias y genera un unico archivo por ej dist/output.js, de manera ordenada y concatenadas.

    373. Basic Workflow Requirements

        Vamos a analizar los requesitos que tenemos:
            1) Compilar next-gen javascript features.
            2) Handle JSX, o sea, que podamos usar jsx.
            3) CSS Autoprefixing. O sea, manejar la mayor cantidad de sintaxis en los diferentes navegadores.
            4) Soportar imagenes. O sea, importarlas como si fuera un archivo.
            5) Optimizar el código (minificar los js)

    374. Project & npm Setup

        1) Crea un archivo .gitignore
            node_modules

        2) npm init
        3) npm install --save-dev webpack webpack-dev-server      -> Solo para desarrollo. Estos dos paquetes van de la mano.
        4)

    375. Creating a Basic Folder & File Structure

        Recrea algo semejante a la estructura de cra.

        src/
            assets/
            components/
            containers/
            index.css               --> para estilos globales.
            index.js
            index.html
                <div id="root">
            App.js                  --> Mi componente root.

    376. Creating the Basic React Application
        components/
            PizzaImage/
                PizzaImage.js
                PizzaImage.css

        containers
            Pizza.js
            Users.js

        assets/
            pizza.jpg


        hoc/
            asyncComponent.js       -> Usar el componente que ya creo antes, para cargar componentes de manera lazy.

        index.js
            Agrega BrowserRouter y envuelve <App /> y renderiza app con ReactDOM.

    377. Installing Production Dependencies

        Core dependencies:
            npm install --save react react-dom react-router-dom

    378. Setting Up the Basic Webpack Config

        Agregar en package.json un script para start

        1) "start": "webpack-dev-server"   -> Usa este package y ejecutalo (así tal cual no pasa nada. hay que instalar una dependencia mas, te lo dice en la consola).

        2) npm install --save-dev webpack-clic

        3) Si intentas correr npm start, te tira un error porque webpack no sabe que hacer con index.js no entiende que tiene que hacer.

           Agrega un archivo webpack.config.js provee la configuración para webpack.

           const path = require('path');    -> este paquete ya viene con node js.
           //__dirname  es una variable global que existe en node.

           module.expots = {
               mode: 'development',         -> le dice a webpack que optimizaciones hacer según el amb.
               entry: './src/index.js',
               output: {
                   path: path.resolve(__dirname, 'dist'),
                   filename: 'bundle.js',
                   publicPath: ''
               },
               devtool: 'cheap-module-eval-source-map'     -> controla como se genera el source map en debug x ej, si lo transforma o no. en la paguina oficial esta esto.
           };

    379. Adding File Rules & Babel

        Vamos a agregar para que entienda next-gen javascript, para eso tenemos que instalar Babel.

        Lo que hace Babel es transpilar los features nuevos de javascript a los viejos para que sean compatbiles en todos los navegadores.

        npm install --save-dev @babel/core @babel/preset-env @babel/preset-react @babel/preset-stage-2 babel-loader @babel/plugin-proposal-class-properties

        const path = require('path');    -> este paquete ya viene con node js.

           module.expots = {
               mode: 'development',         -> le dice a webpack que optimizaciones hacer según el amb.
               entry: './src/index.js',
               output: {
                   path: path.resolve(__dirname, 'dist'),
                   filename: 'bundle.js',
                   publicPath: ''
               },
               devtool: 'cheap-module-eval-source-map',     -> controla como se genera el source map en debug x ej, si lo transforma o no. en la paguina oficial esta esto.
               module: {
                   rules: [     -> cada regla es un objeto, donde vas a tener una propiedad test con una expression regular, donde vas a indicar que archivos van a estar alcanzados por cierta herramienta/plugin, por ej los archivos javascript, van a ser alcanzados por el loader y la herramienta va a ser babel-loader.
                       {
                           test: /\.js$/,
                           loader: 'babel-loader',
                           exclude: /node_modules/  -> no queremos que alcance la carpeta.
                       }
                   ]
               }
           };

            Creamos un nuevo archivo .babelrc es un archivo de confugración para babel que se escribe en formato JSON.
            Todo esto esta en la pagina oficial de Babel.

            {
                "presets": [ -> acá tenemos que aplicar todos los presets que queremos.
                    [
                        "@babel/preset-env",
                        {
                            "targets": {
                                "browsers": ["> 1%", "last 2 versions"] -> compila para que compile en estos browser.
                            }
                        }
                    ],
                    "@babel/preset-react"   -> no necesita ser un array porque no es necesario presets.
                ],
                "plugins": [    -> config extra o comportamiento.
                    "@babel/plugin-proposal-class-properties"   -> controla que sintaxis soporta.
                ]
            }

    380. Loading CSS Files

        npm install --save-dev style-loader css-loader (uno analiza los css y el otro toma los css y los inyecta en nuestro html. (style))

        agrega una regla al archivo webpack:

        {
            test: /\.css$/,
            exclude: /node_modules/,
            use: [
                { loader: 'style-loader' },
                {
                    loader: 'css-loader',
                    options: {  -> necesita config extra para aceptar css-modules.
                        importLoaders: 1,
                        modules: {
                            localIndentName: '[name]__[local]__[hash:base:5]'
                        }
                    }
                },
                {
                    loader: 'postcss-loader',  -> nos ayuda con el procesamiento de css y prefinxing para que pueda funcionar en navegadores viejos.
                    options: {
                        ident: 'postcsss',
                        plugins: () => [autoprefixer()]
                    }
                }

            ]
        }

        npm install --save-dev postcss-loader
        npm install --save-dev autoprefixer
            Abajo del import de path en el archivo webpack:

            const autoprefixer = require('autoprefixer');
                se agrega a la parte de plugins de postcssloader.

        en package.json agrega un script debajo de "licence"

        "browserslist": "> 1%, last 2 versions",

    381. Loading Images & Injecting into HTML Page

        Nos ayuda a cargar assets
            npm install --save-dev url-loader

        Dentro de webpackconfig
            {
                test: /\.(png|jpe?g'|gif)$/,
                loader: 'url-loader?limit=8000&name=images/[name].[ext]'
            }

        Para inyectar todas las transformaciones qe configuramos anteriormente en html:
            npm install --save-dev html-webpack-plugin
                arriba de todo abajo de autoprefixer
                    const HtmlWebpackPlugin = require('html-webpack-plugin');

            dentro del config de webpack, antes del } final:

            plugins: [
                new HtmlWebpackPlugin({
                    template: __dirname + '/src/index.html',
                    filename: 'index.html',
                    inject: 'body'
                })
            ]

        npm install --save-dev file-loader  -> otro package necesario para webpack.

    382. Production Workflow & Wrap Up

        Copiamos y pegamos el webpack config y creamos un webpack.config.prod.js

        modificamos el development mode: 'production', en devtool: 'none'
        Agregamos un script debajo de start:

            "build:prod": "webpack --config webpack.config.prod.js"

        npm start -> vemos como se genera la carpeta dsit y esta todo bundleado.

    383. Adding babel-polyfill

        The current setup won't support all browsers theoretically supported by React. Features like Promises and Object.assign() are missing in older browsers - especially in IE of course.

        If you need to support these browsers, you need to add a polyfill (a package which provides these features for older browsers).

        The Babel docs explain how you can take advantage of Babel's built-in "Polyfill auto injecting" feature: https://babeljs.io/docs/en/babel-polyfill

        Simply install two packages:

        npm install --save core-js

        and

        npm install --save regenerator-runtime

        Change the config of your @babel/preset-env  babel preset in the .babelrc  file:

        "presets": [
            ["@babel/preset-env", {
                "targets": {
                    "browsers": [
                        "> 1%",
                        "last 2 versions"
                    ]
                },
                "useBuiltIns": "usage"
            }],
            ...
        ],

    384. Useful Resources & Links
        Webpack Docs: https://webpack.js.org/concepts/
        More about Babel: https://babeljs.io/
        Recursos de esta clase
        webpack--01-basic-react-app.zip
        webpack--02-added-babel.zip
        webpack--03-finished.zip

### Sección 23: Bonus: Next.js

    385. Module Introduction

        Es una libreria basada en react, fuerza una estructura especifica y nos da server side rendering y configuración extra que no tenemos que hacer a mano.

        Server side rendering ayuda mucho a los search engine

    386. Understanding Server Side Rendering

        Server Side Rendering simplemente significa, cuando un usuario entre a una url, se va a estar pre-renderizando esa pagina, del lado del servidor y lo va a retornar ya "cocinado"

        O sea, el cliente hace un request al server, el server hace el fetch y renderiza la app, retorna renderizada la primer pagina + react app bundle y en el cliente se re-renderiza la SPA.

    387. Setting Up a Project
        Web Next js: https://nextjs.org/

        Esto que vamos a hacer lo hace con el paso a paso que esta en github
            https://github.com/zeit/next.js/

            Actualmente esto no esta mas en github, sino en la pagina oficial, hay ciertas partes que ya no estan igual, yo voy a seguir como lo da el en el curso:
                https://nextjs.org/learn/basics/getting-started

        1) .gitignore
        2) npm init
        3) npm install --save next react react-dom
        4) package.json

            "scripts": {
                "dev": "next",
                "build": "next build",
                "start": "next start"
            }

            No se usa react-router, se usa file-system es la API main de Next js. Basicamente lo que se usa es carpetas y archivos para ir ruteando nuestra url, next js parsea esto y usa su propio ruteador interno, pre renderiza y automaticamente splitea y con lazy load lo muestra.

        5) creamos:
            pages/
                auth/
                    index.js
                index.js

            * podes usar clases, funcional componentes, state, etc.

            index.js
                import React from 'react';

                const indexPage = () => {
                    <div>
                        <h1> Main Page </h1>
                    </div>
                };

                export default indexPage;

            auth/index.js
                import React from 'react';

                const indexPage = () => {
                    <div>
                        <h1> Auth index Page </h1>
                    </div>
                };

                export default indexPage;

        6) npm run dev

           En localhost vamos a ver main page y en localhost/auth vamos a ver auth index page :O

    388. Understanding the Basics

        import Link from 'next/link';
        import Router from 'next/router';

        <Link href="/auth"> Auth </Link>
        <button onClick={() => Router.push('/auth')}> Go to Auth </button>

    389. Next.js & Components & Pages

        components/
            User.js

        Al componente lo importamos en otro js como cualquier import.

    390. Styling our App in Next.js

        Next JS tiene su propia manera de estilar. Podemos usar Radium, podes usar estilos en linea, no podemos usar CSS Modules.

        Styled-jsx

        <style jsx> {`
            div {
                border: 1px solid black;
            }
        `} </style>

    391. Handling (404) Errors
        Next js tiene una pagina por default para esto, si se quiere sobreescribir hay que generar un archivo _error.js dentro de pages.

    392. A Special Lifecycle Hook

        Transforma el componente funcional en un componente de clase.

        usa una función nueva que también esta en functional components.

        Static puede ser llamado sin ser instanciado y es asincrono, retorna algo instantaneamente.
            Se puede usar async o no. *
        Sirve para inicializar tu app antes de que se cargue.
            Podríamos traer info de la bd x ej.

        static async getInitialProps(context){
            // console.log(context);
            const promise = new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve({appName: 'Super App});
                }, 1000);
            });
            return promise;
        }

        Después lo usamos en el retorno de jsx.
            <h1> this.props.appName </h1>

        Solo va a renderizar esa parte, cuando se retorne la promesa.

        * Hace el ejemplo también con functional components.

    393. Deploying our App

        npm run build   -> para buildear el proyecto para deployarlo.

    394. Useful Resources & Links
        Next.js Repo & Docs: https://github.com/zeit/next.js/
        Recursos de esta clase
        nextjs--01-finished.zip

### Sección 24: Bonus: Animations in React Apps

    395. Module Introduction

    396. Preparing the Demo Project

    397. Using CSS Transitions

    398. Using CSS Animations

    399. CSS Transition & Animations Limitations

    400. Using ReactTransitionGroup

    401. Using the Transition Component

    402. Wrapping the Transition Component

    403. Animation Timings

    404. Transition Events

    405. The CSSTransition Component

    406. Customizing CSS Classnames

    407. Animating Lists

    408. Alternative Animation Packages

    409. Wrap Up
    410. Useful Resources & Links
        More on CSS Transitions: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions
        More on CSS Animations: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations
        More on ReactTransitionGroup: https://github.com/reactjs/react-transition-group
        Alternative => React Motion: https://github.com/chenglou/react-motion
        Alternative => React Move: https://github.com/react-tools/react-move
        Animating Route Animations: https://github.com/maisano/react-router-transition

### Sección 25: Bonus: A Brief Introduction to Redux Saga

    411. Module Introduction

    412. Installing Redux Saga

    413. Creating our First Saga

    414. Hooking the Saga Up (to the Store and Actions)

    415. Moving Logic from the Action Creator to a Saga

    416. Moving More Logic Into Sagas

    417. Handling Authentication with a Saga

    418. Handling Auto-Sign-In with a Saga

    419. Moving the BurgerBuilder Side Effects into a Saga

    420. Moving the Orders Side Effects into Sagas

    421. Why Sagas can be Helpful

    422. Diving Deeper into Sagas

    423. Useful Resources & Links
        Find the module source code attached to this lecture.

        Useful Links:

        Redux Saga: Full Documentation => https://redux-saga.js.org/
        Advanced Concepts: https://redux-saga.js.org/docs/advanced/
        API Reference: https://redux-saga.js.org/docs/api/
        Pros & Cons for Redux Saga vs Thunks: https://stackoverflow.com/questions/34930735/pros-cons-of-using-redux-saga-with-es6-generators-vs-redux-thunk-with-es2017-asy/34933395
        Recursos de esta clase
        redux-saga--01-start.zip
        redux-saga--02-auth.zip
        redux-saga--03-burger-builder.zip
        redux-saga--04-orders.zip
        redux-saga--05-finished.zip

### Sección 26: React Hooks - 

    424. Introduction
    425. What are "React Hooks"?

        Nos ayuda a trabajar con nuestros componentes de una manera mas eficiente.

        1) Functional:
            Props in, JSX out
            Great for Presentational
            Focused on one/few purpose(s)

        2)  Funcional With Hooks
            Nos permite trabajar con functional components only.
            Hooks, reemplaza las funcionalidades de las clases (el manejo de estado)
                (que por eso las teníamos que usar, si bien podes crear clases, no es obligación.

        3) Class-based:
            Uses props and state
            Business logic goes in here
            Orchestates components.
            Lifecycle hooks (can be hard to use)

        - Para usar uno u otro, hay que convertirlos o desconvertirlos y es bastanta molesto.

        React hooks:
                Estan en React desde la versión 16.8
                Se llaman así porque "enganchas" un "function component", con cierta funcionalidad.
                simplemente funciones javascript.
                Los nombres de las funciones de React hooks arrancan con useAlgo()
                Con Hooks, podes hacer que todo sean functional components, no necesitas mas clases.

            Se pueden usar:
                dentro de funcional components.
                dentro de otros hooks.
                Son reutilizables e independientes de cada componente.

            También podemos:
                escribir nuestros propios hooks.
                Compartir la logica completa o sin estado entre multiples componentes.

            No son - no tienen que ver:
                No se pueden reemplazar los metodos de ciclo de vida con react hooks.

        La idea de los hooks, es que vos podes exponer cierta (posiblemente stateful funcionalities) a functions components, como manejar el estado, como el ciclo de vida de los componentes.

        
            Lifecycle hooks, son sinonimo de los metodos de ciclo de vida y solo se pueden usar en componentes basados en clases.

    426. The Starting Project

        Habla sobre el proyecto que dejó adjunto y sobre que no tiene ni una clase, son todos componentes de funciones.

    427. Getting Started with useState()
        Core Hook!

        Como usarlo:
            - Agregar al import de react, useState entre { }
            - useState() -> puede ser inicializado con cualquier tipo. No solo con un objeto como en las clases componentes.
            - Es mas facil inicialiarlos como string, ya que por mas que el input sea de otro tipo, el valor que se pone en el atributo value termina siendo siempre un string.
            - Devuelve una matriz con exactamente dos elemetos:

            1) el valor actual
            2) una función que te permite retornar el valor actualizado.

            const inputState = useState({title: '', amount: ''});

            en nuestro input:
                value={inputState[0].title}
                onChange={event => useState[1]({title: event.target.value})}

    428. More on useState() & State Updating
        https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures

        Los que nos enseño recién NO SIRVE, NO SE HACE ASÍ, porque se esta pisando la información, no actualizando la propiedad especifica del objeto, esta creando un objeto nuevo y perdiendo la información de amount o de title si es que empezas a escribir por amount.

        const inputState = useState({title: '', amount: ''});

        Se podría solucionar así, pero tampoco es la manera correcta, porque no podemos quedarnos tranquilos de que sea el ultimo snapshot del estado de los elementos.

            en nuestro input:
                value={inputState[0].title}
                onChange={event => inputState[1]({title: event.target.value, amount: useState[0].amount })}

        La solución es:
            value={inputState[0].title}
            onChange={event => {
                const newTitle = event.target.value;
                inputState[1](prevInputState => ({
                    title: newTitle,
                    amount: prevInputState.amount
                }));
            }}

    429. Array Destructuring

        const [ inputState, setInputState ] = useState({title: '', amount: ''});

        value={inputState.title}
        onChange={event => {
            const newTitle = event.target.value;
            setInputState(prevInputState => ({
                title: newTitle,
                amount: prevInputState.amount
            }));
        }}

    430. Multiple States
        La manera correcta ya que la otra es inmantenible y aparte si tenes mas de un input en el form te volves loco, es:
        const [ enteredTitle, setEnteredTitle ] = useState('');
        const [ enteredAmount, setEnteredAmount ] = useState('');

        value={enteredTitle}
        onChange={event => {
            setEnteredTitle(event.target.value);
        }}

    431. Rules of Hooks
        Entendiendo useState...

        - Podemos llamarlo con un estado inicial o no.
        - Se crea un estado que se maneja "detras de escena" por React, que sobrevive re-render cicles.
        - Lo que obtenemos es una matriz con dos elementos, el primero es un puntero a tu estado y es el segundo es    una función de update del estado.

        
        Hay dos reglas importantes que se aplican a todos los estados:
            1) Los hooks, solo se deben usar en componentes funcionales (functional components) o dentro de nuestros propios hooks personalizados.
            2) No podes usar un hook en una función anidada, siempre es en el componente root. Para que quede claro, esto no se puede hacer:

            const unaFuncion = () => {
                useState() -> usarlo acá adentro.
            }

    432. Passing State Data Across Components
        Explica como hacer para agregar ingredientes y pasarselo al otro componente.
        O sea, modifica el componente de Ingredientes, donde:
        Agrega el componente IngredientList y le pasa por prop el esado con los ingredients.
        Agrega una función addIngredientHandler y se la pasa al componente IngedienteForm

    Tarea 6: Time to Practice: Hooks Basics
        Deje la solución por la mitad.

    433. Sending Http Requests
        Creó un nuevo proyecto en Firebase.
        va a usar fetch y agrega la url del nuevo proyecto, configura el metodo como post, un body de lo que queres enviar (data en formato json), le envia el ingrediente sin id porque ahora eso lo va a generar firebase.

        
        Explica que en fetch es obligatorio poner el header de app/json para que parsee eso a json, en axios no es necesario.

        response.json() -> toma el body y lo convierte a json.

    434. useEffect() & Loading Data

        https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures

        Solo sepuede usar en componentes funcionales, y en el componente root.

        Side effect, basicamente significa que tenes cierta logica que afecta a tu aplicación.
        Por ejemplo, que dentro de la función estemos llamando a algo que no se termine en este ciclo de renderización o talvez afecta algo que esta afuera del alcance del código jsx.
        Por ejemplo setear el titulo del documento, algo así.

        useEffect se ejecuta después de que cada componente procesa su ciclo.
        O sea, después de que el componente donde se esta por usar se haya procesado por primera vez, la función que le pasas a useEffect, va a ser ejecutada.

        
        Se ejecuta cada vez que el componente se vaya a re-renderizar.

        Dentro de la función useEffect, hace un llamado a firebase con un get, para obtener los ingredientes.
         crea una variable para ir pusheando los ingredientes, como un objeto .push({ title: , description: }) bla bla.

         si no se usa useEffect, pasanlo un array, al hacer un fetch, se actualiza el estado, y como cada vez que se actualiza el estado, se re-renderiza el componente, useEffect genera un loop infinito porque siempre hace el fetch y siempre re-renderiza el estado.

        A tener en cuenta: useEffect actua como componentDidUpdate().

        En useEffect el primer parametro es la función que se ejecuta después de cada ciclo de renderizado, la segunda es una array con las dependencias de esa función, o sea, que solo va a correr la función cuando sus dependencias cambien. Para que corra solo una vez se agrega el array vacio, que no necesita dependencias, por ende solo ejecuta una vez.

    435. Understanding useEffect() Dependencies

        
        Se puede tener tantos useEffect como necesites, como useState.

        Si le pasamos una dependencia, useEffect va a correr solo cuando a esa dependencia se le cambie algo (State, props
        )

    436. More on useEffect()

        Va a usar useEffect para hacer un request a firebase cada vez que el usuario pulse una tecla.
        Por ende en vez de un array vacio, le pasa enteredFilter, que es el estado actualizado de las letras que se van escribiendo en el value.

        Al final de la llamada, usa props.onLoadIngredients(loadedIngredients), este ultimo es donde se va pusheando la info a cada respuesta del request.

        Así que le pasa al componente Search, la nueva prop onLoadIngredients={filteredIngredientsHandler}

        crea la funcion filteredIngredientsHandler, como props es una dependencia de useEffect, también hay que pasarla como parametro del array, pero como esto puede traer otros problemas, lo que se hace en realidad es oasar la funcion onLoadIngredients, y arriba de todo después de crearse la función, lo que se hace es extraer con destructuring, esa función de las props, const { onLoadIngredients } = props;
        Esto se hace para que useEffect se use solo cuando uno de los dos parametros que le psamos cambie.

        Firebase admite filtrado, así que arma una constante query con enteredFilter.lenght === 0 ? '' : `?orderBy="title"&equalTo="${enteredFilter}"

        eso se lo pasamos al final de la url en el fetch

        También hay que ir a rules, y habilitar filtering en firebase, ingredients: { ".indexOn": [ "title" ]}

        esto da un loop infinito, lo resuelve en el proximo video.

    437. What's useCallback()?

        Al re-renderizarse el componente, las funciones se vuelven a crear, es esto lo que esta causando el lopp infinito.

        Para prevenir esto, hay otro hook que se llama useCallback.

        Nos permite envolver nuestra función y pasarle un 2do argumento con las dependencias del argumento, como nuestra funcion setUserIngredients, no tiene dependencias, entonces le especificamos a useCallback un array vacio, como useeffect.

         Lo que hace useCallback es cachear la función y que sobreviva a las re-renderizaciones, o sea, no se va a recrear la funcion cuando el componente se re-renderice.

         Si bien elimina el loop infinito en la solapa de network verifica porque hay 2 peticiones.

         Una es para obtener los ingredientes, la otra es desde ingredientes.

    438. Working with Refs & useRef()

        Vamos a arreglar un problema, que es que cada vez que pulsamos una tecla se esta haciendo un request al servidor.
        Lo que quiere hacer es que después de un tiempo especifico se envie la consulta y no todo el tiempo.

        Con useRef(), podemos generar una variable de referencia.

        EL PROBLEMA DE ESTO ES QUE ESTAMOS GENERANDO UN NUEVO TIMEOUT TODO EL TIEMPO, PORQUE SE ACTUALIZA EL ESTADO CADA VEZ QUE TECLEAMOS. Y PORQUE ESTAMOS PASANDO DEPENDENCIAS A USEEFFECT.


        const inputRef = useRef();

        useEffect(() => {
            setTimeout(() => {
            if (enteredFilter === inputRef.current.value) {
                const query =
                enteredFilter.length === 0
                    ? ''
                    : `?orderBy="title"&equalTo="${enteredFilter}"`;
                fetch(
                'https://react-hooks-update.firebaseio.com/ingredients.json' + query
                )
                .then(response => response.json())
                .then(responseData => {
                    const loadedIngredients = [];
                    for (const key in responseData) {
                    loadedIngredients.push({
                        id: key,
                        title: responseData[key].title,
                        amount: responseData[key].amount
                    });
                    }
                    onLoadIngredients(loadedIngredients);
                });
            }
            }, 500);
        }, [enteredFilter, onLoadIngredients, inputRef]);

    439. Cleaning Up with useEffect()
        Acá la función ya esta arreglada, la arreglaba en el proximo video.

        Como setTimeout es un puntero a la función de timer, la guarda en una variable para después limpiarla con la función clearTimeout.

        const timer = setTimeout(() => {
        if (enteredFilter === inputRef.current.value) {
            const query =
            enteredFilter.length === 0
                ? ''
                : `?orderBy="title"&equalTo="${enteredFilter}"`;
            fetch(
            'https://react-hooks-update.firebaseio.com/ingredients.json' + query
            )
            .then(response => response.json())
            .then(responseData => {
                const loadedIngredients = [];
                for (const key in responseData) {
                loadedIngredients.push({
                    id: key,
                    title: responseData[key].title,
                    amount: responseData[key].amount
                });
                }
                onLoadIngredients(loadedIngredients);
            });
        }
        }, 500);
        return () => {
        clearTimeout(timer);
        };

    440. Deleting Ingredients
        Actualiza la función de eliminar ingredientes, para que los elimine de firebase

        const removeIngredientHandler = ingredientId => {
            setIsLoading(true);
            fetch(
            `https://react-hooks-update.firebaseio.com/ingredients/${ingredientId}.json`,
            {
                method: 'DELETE'
            }
            )
            .then(response => {
                setIsLoading(false);
                // setUserIngredients(prevIngredients =>
                //   prevIngredients.filter(ingredient => ingredient.id !== ingredientId)
                // );
                dispatch({ type: 'DELETE', id: ingredientId });
            })
            .catch(error => {
                setError('Something went wrong!');
                setIsLoading(false);h
            });
        };

    441. Loading Errors & State Batching
        Para mostrar un loading, genera un estado solo para eso, la actualiza en el comienzo de la llamada y en el final.

        importa el ErrorModal y en el catch de fetch, setea el error en un nuevo estado que genera especificamente para eso.

        De manera condicional utiliza el nuevo estado para verificar si tiene algo y sino muestra el modal, muestra un shortcut de ese if que es así:

        const clearError = () => {
            setError(null);
            setIsLoading(false)
        }

       {error && <ErrorModal onClose={clearError}>{error}</ErrorModal>}

        Explica que cuando hay 2 estados que se actualian al mismo tiempo, en realidad react lo que hace es acualizarlos de manera sincronica. O sea, uno por uno, pero después la actualización en si, se hace toda junta "de manera bath"
        De esta manera solo vamos a tener un solo evento de re-renderizado no dos.

    442. More on State Batching & State Updates
        React batches state updates - see: https://github.com/facebook/react/issues/10231#issuecomment-316644950

        That simply means that calling

        setName('Max');
        setAge(30);
        in the same synchronous (!) execution cycle (e.g. in the same function) will NOT trigger two component re-render cycles.

        Instead, the component will only re-render once and both state updates will be applied simultaneously.

        Not directly related, but also sometimes misunderstood, is when the new state value is available.

        Consider this code:

        console.log(name); // prints name state, e.g. 'Manu'
        setName('Max');
        console.log(name); // ??? what gets printed? 'Max'?
        You could think that accessing the name state after setName('Max'); should yield the new value (e.g. 'Max') but this is NOT the case. Keep in mind, that the new state value is only available in the next component render cycle (which gets scheduled by calling setName()).

        Both concepts (batching and when new state is available) behave in the same way for both functional components with hooks as well as class-based components with this.setState()!

    443. Understanding useReducer()
        Son funciones que toman algo y retornan algo. O sea, administran el/los estados y se encargan de retornarte uno.

        Un reducer se utiliza fuera del componente, ya que sino se estaría re-renderizando todo el tiempo. O sea, por fuera de la función (componente).

        state = que puede ser un estado en particular
        action = es la que se va a encargar de observar la acción y actualizar el estado.
        en el switch se maneja cada tipo a escuchar.

        const ingredientReducer = (state, action) => {
            switch(action.type){
                case 'ADD':
                    return action.ingredients;
                case 'SET':
                    return [...state, action.ingredient]; // esto depende que quieras hacer.
                case 'DELETE':
                    return currentIngridients.filter(ing => ing.id !== actions.id);
                default:
                    throw new Error("Should not get there");
            }
        }

        En el componente, debemos inicializar el reducer, utilizar la función useReducer()

        Le tenemos que pasar un estado incial en nuestro caso un array vacio porque la pimera vez el estado esta vacio.

        Es parecido a un state, primero el estado después la función que despacha cada acción. NO ES UN SET STATE.
        Se puede nombrar como se te canta.

        const [userIngredients, dispatch ] = useReducer(ingredientsReducer, [])

        Ahora todo lo que se manejaba por estado, se tiene que cambiar para usar reducer. O sea:

        Por ej:
        en vez de setUserIngrendients(filteredIngredients)

        Por:
        hay que pasarle un objeto a dispatch.

        dispatch({type: 'SET', ingredientes: filteredIngredients} )

        Las propiedades del objeto son las que utilizamos en el switch.-

        AL UTILIZAR USEREDUCER, EL COMPONENTE SOLO SE VA A RE-RENDERIZAR CUANDO ESTE RETORNE EL NUEVO ESTADO.

    444. Using useReducer() for the Http State
        Genera un reducer para los tipos de acciones al hacer algo http, como enviar, respuesta, error, etc:

        Solo manejamos estados, no es que vamos a hacer las llamadas ahí.

        const httpReducer = (curHttpState, action) => {
        switch (action.type) {
            case 'SEND':
            return { loading: true, error: null };
            case 'RESPONSE':
            return { ...curHttpState, loading: false };
            case 'ERROR':
            return { loading: false, error: action.errorMessage };
            case 'CLEAR':
            return { ...curHttpState, error: null };
            default:
            throw new Error('Should not be reached!');
        }
        };


         const [httpState, dispatchHttp] = useReducer(httpReducer, {
            loading: false,
            error: null
        });

        // const [isLoading, setIsLoading] = useState(false);
        // const [error, setError] = useState();

    445. Working with useContext()
        Crea una carpeta context (porque a el le gusta hacerlo así): de esta manera todos los componentes que esten envueltos en el componente AuthContext, van a "escuchar" las actualizaciones sobre los estados isAuth y login.

        auth-context.js
            import React, { useState } from 'react';

            export const AuthContext = React.createContext({
                isAuth: false,
                login: () => {}
            });

            const AuthContextProvider = props => {
                const [isAuthenticated, setIsAuthenticated] = useState(false);

                const loginHandler = () => {
                    setIsAuthenticated(true);
                };

                return (
                    <AuthContext.Provider
                    value={{ login: loginHandler, isAuth: isAuthenticated }}>
                        {props.children} // De esta manera decis que a este componente se le puede pasar cualquier otro componente, es un wrapper.
                    </AuthContext.Provider>
                );
            };

            export default AuthContextProvider;

        index.js

            <AuthContextProvider>
                <App />
            </AuthContextProvider>

        app.js
            En los componentes funionales, el contexto no se puede utilizar, deberíamos convertirlos a clases, pero, para no hacer eso, podemos usar el hoook useContext.

            import React, { useContext } from 'react';

            import Ingredients from './components/Ingredients/Ingredients';
            import Auth from './components/Auth';
            import { AuthContext } from './context/auth-context';

            const App = props => {
                const authContext = useContext(AuthContext);

                let content = <Auth />;
                if (authContext.isAuth) {
                    content = <Ingredients />;
                }

                return content;
            };

            export default App;

        Auth.js
            import React, { useContext } from 'react';

            import Card from './UI/Card';
            import { AuthContext } from '../context/auth-context';
            import './Auth.css';

            const Auth = props => {
            const authContext = useContext(AuthContext);

            const loginHandler = () => {
                authContext.login();
            };

            return (
                <div className="auth">
                <Card>
                    <h2>You are not authenticated!</h2>
                    <p>Please log in to continue.</p>
                    <button onClick={loginHandler}>Log In</button>
                </Card>
                </div>
            );
            };

            export default Auth;

        Cualquier cosa revisar la sección 7 donde explica mas sobre el contexto.

    446. Performance Optimizations with useMemo()

        Cuando el componente donde se aloja una función se re-renderiza, la función se vuelve a recrear, es por eso que necesitamos usar useCallback, para que no se recree nuevamente. No es que se  ejecuta, se vuelve a crear.

        useMemo es como useCallback pero con un valor.

        Lo que hace es cortar el componente IngridientList y usa useMemo. Lo que hace es que React memoriza el valor que queres retornar, en este caso es un component.

        useMemo también tiene segundo parametro como useCallback, solo que le dice a React, cuando debe volver a ejecutar la función para crear un nuevo objeto que debe memorizar, entonces le pasamos las dependencias para que sepa cuando ese componente se tiene que re-renderizar, que es cuando cambian alguno de los dos, un estado y una prop.

        A veces hay que analizar sivale la pena usar react.memo o useCallback o useMemo, porque capaz que son cosas chicas y no valenla pena, porque el costo re-renderizado al de chequeo constante puede ser menos.

    447. Getting Started with Custom Hooks

        Crea una carpeta hooks y un el archivo http.js, crea un custom hooks, siempre hay que arrancar el nombre con useAlgo, va a ser una función, como cualquier otra.
        Podes usar cualquier hook dentro de tu custom hook.

        Si se usa en diferentes componentes, no es que van a compartir los datos, sino que cada componente va a tener un snapshot del hook. O sea que compartis logica, pero no los datos.

        No se importa React, porque no se esta haciendo un componente.

        https.js:
            import { useReducer, useCallback } from 'react';

            const httpReducer = (curHttpState, action) => {
                switch (action.type) {
                        case 'SEND':
                            return {
                                loading: true,
                                error: null,
                                data: null,
                                extra: null,
                                identifier: action.identifier
                            };
                        case 'RESPONSE':
                            return {
                                ...curHttpState,
                                loading: false,
                                data: action.responseData,
                                extra: action.extra
                            };
                        case 'ERROR':
                            return { loading: false, error: action.errorMessage };
                        case 'CLEAR':
                            return { ...curHttpState, error: null };
                        default:
                            throw new Error('Should not be reached!');
                }
            };

            const useHttp = () => {
                const [httpState, dispatchHttp] = useReducer(httpReducer, {
                    loading: false,
                    error: null,
                    data: null,
                    extra: null,
                    identifier: null
                })
            };

            const sendRequest = useCallback((url, method, body, reqExtra, reqIdentifer) => {
                dispatchHttp({ type: 'SEND', identifier: reqIdentifer });
                    fetch(url, {
                        method: method,
                        body: body,
                        headers: {
                        'Content-Type': 'application/json'
                        }
                    })
                    .then(response => {
                        return response.json();
                    })
                    .then(responseData => {
                        dispatchHttp({
                            type: 'RESPONSE',
                            responseData: responseData,
                            extra: reqExtra
                        });
                    })
                    .catch(error => {
                        dispatchHttp({
                            type: 'ERROR',
                            errorMessage: 'Something went wrong!'
                        });
                    });
                },
                []
            );

            return {
                    isLoading: httpState.loading,
                    data: httpState.data,
                    error: httpState.error,
                    sendRequest: sendRequest,
                    reqExtra: httpState.extra,
                    reqIdentifer: httpState.identifier
                };
            };

            export default useHttp;

    448. Sharing Data Between Custom Hooks & Components
        Volver a ver.

    449. Using the Custom Hook
        Muestra como usa el hook que creo en las llamadas http del proyecto.

    450. Wrap Up

### Sección 27: Using Hooks in the Burger Builder

    451. Introduction

    452. Converting <App>

    453. Routing with React.lazy()

    454. Converting the Layout Component

    455. Converting withErrorHandler HOC

    456. Adjusting the Order & Checkout Containers

    457. Add Hooks to ContactData

    458. Converting the BurgerBuilder Container

    459. Adjusting Auth & Logout Components

    460. Using React.memo() & More!

    461. Adding a Custom Error Handling Hook

    462. Setting the right useEffect() Dependencies

    463. Working with useSelector() and useDispatch()

    464. Wrap Up
    465. Useful Resources & Links
        Official Hooks Docs: https://reactjs.org/docs/hooks-intro.html

        Recursos de esta clase
        hooks-prj-01-starting-project.zip
        hooks-prj-02-added-lazy-loading.zip
        hooks-prj-03-converted-hocs.zip
        hooks-prj-04-orders-contactdata.zip
        hooks-prj-05-burgerbuilder.zip
        hooks-prj-06-auth.zip
        hooks-prj-07-custom-error-handling-hook.zip
        hooks-prj-08-finished.zip

### Sección 28: Bonus: Replacing Redux with React Hooks

    466. Module Introduction
    467. Starting Project & Why You Would Replace Redux

        Hay dos approach uno bueno y uno que no debería usarse para cualquier opción.

    468. Alternative: Using the Context API

        La alternativa que no se debe usar siempre (o sea, para cualquier cosa).

        Crea una carpeta context > products-context.js

    469. Toggling Favorites with the Context API

    470. Context API Summary (and why NOT to use it instead of Redux)

    471. Getting Started with a Custom Hook as a Store

    472. Finishing the Store Hook

    473. Creating a Concrete Store

    474. Using the Custom Store

    475. Custom Hook Store Summary

    476. Optimizing the Custom Hook Store

    477. Bonus: Managing Multiple State Slices with the Custom Store Hook

    478. Wrap Up
    479. Useful Resources & Links
        Attached, you find the module source code.

        These resources might also be helpful:

        More on React Hooks: https://reactjs.org/docs/hooks-intro.html

        npm Custom Store Hook package: https://www.npmjs.com/package/use-global-hook

        Recursos de esta clase
        replace-redux-01-starting-project.zip
        replace-redux-02-use-context-api.zip
        replace-redux-03-started-work-on-custom-store-hook.zip
        replace-redux-04-finished-custom-hook.zip
        replace-redux-05-finished.zip
        replace-redux-06-bonus-multiple-slices.zip

### Sección 29: Bonus: Building the Burger CSS

    480. Building the Burger CSS Code
        Todo el video es sobre css y como crea el icono de hamburguesa, también esta el pdf adjunto: burger-css.pdf

### Sección 30: Course Roundup

    481. What Now? Next Steps You Could Take!
        ...

    482. Explore The React Ecosystem!
        Gatsby
        PREACT
        React Native
        
    483. Finishing Thoughts
        ...

    484. Bonus!

        With this course, you learned a lot about React!

        But the React ecosystem is huge and there are tons of things you can do and build with React, for example:

        Learn how to build server-side rendered (great for SEO!) or fullstack apps with Next.js & React: https://acad.link/nextjs

        Build mobile Android & iOS apps with React Native: https://acad.link/react-native

        Build fullstack MERN (MongoDB, ExpressJS, React, NodeJS) web apps: https://acad.link/mern

        Or dive into one of the many other courses I have on web development, JavaScript etc: https://academind.com/courses/

# Section 31: This Course Got Updated!

    485. Course Update Overview, Explanation & Migration Guide
        
        Porque React evoluciono y ahora el standar es functional component + react hooks...
        Porque el loco creció y con el feedback mejoró el curso y como explicaba.....

    486. Course Update & Migration Guide
        ***

        PLEASE READ THIS ENTIRE DOCUMENT CAREFULLY

        It contains detailed information on WHY the course is updated, WHAT changed and what that means for you and your course progress!

        FAQs (e.g. "How do I regain my course progress" can be found at the end of this document!)

        ***

        On April 12th 2021, I updated this entire course to make it future-proof and teach the latest version of React in the best-possible way.

        For that, I completely re-recorded this course - you get this brand-new course for free!

        In a nutshell, this means that this course switched from "class-based components for state management" to "using React Hooks with functional components right from the start".

        What you learned with the old course is not obsolete - I simply updated the course to make it future-proof and embrace modern React practices (specifically function components + hooks) right from the start!

        I re-recorded the entire course (i.e. I created a brand-new course), incorporating all the latest best practices and all the amazing feedback I got from you over the years.

        Here's what you need to know about this update (and what it means for you) - please read this article carefully!

        I completely re-recorded the course and therefore created a brand-new 40h+ course!

        You get this update 100% for free and you don't need to do anything for that!

        The new course is inserted into this existing course (in front of the old course) - i.e. lecture 1 in section 1 is the new course after April 12th

        The old course content will stay around for a short transitional period (planned to end on May 3rd) after which it will be removed

        You keep access to the old course though: Download links (to videos, VTT caption files and course attachments) are provided in the next lecture

        Details on how you should proceed (based on your current course progress) can be found below!

        Why did I update the course?
        Over the years and months, React evolved and today, you write React code slightly different than you did in the past. Most importantly, we nowadays use functional components + React Hooks instead of using class-based components for state management.

        Whilst I do cover React Hooks in-depth in this course, the course still starts with a strong focus on class-based components (just like the official docs still do by the way). That is not bad or incorrect but it doesn't reflect the future of React. And hence, to make this course future-proof and teach you React in the most modern way possible, I updated the course to fully embrace functional components + React Hooks.

        What changed?
        I also used the opportunity to improve the content in general and add some new content (besides the general restructuring due to the switch to "React Hooks first"):

        The single, large course project (the burger builder) will be replaced by multiple smaller, more focused (yet realistic) demo projects so that skipping modules or coming back to modules will be easier (and so that you got more variety!)

        A brand-new, in-depth introduction to Next.js (> 3h!) was added to the course

        A React summary module was added: You can use that after going through the course or as a "mini course" that teaches you the essence of React => Great if you have limited time and don't want to go through the full course right now

        Overall, explanations and examples were improved, as I had to create a brand-new course anyways (due to the switch to "React Hooks first")

        More new content (on React + TypeScript, Authentication, Testing) will be added after May 3rd (once the old lectures were removed) - I can't add that content yet since there is a "maximum number of lectures" limitation on Udemy

        What about the old course?
        As mentioned, the old content stays around for a short transitional period until May 3rd - thereafter it will be removed. You will keep access to it thereafter via download links though (see next lecture).

        Because Udemy has a lecture limit (max amount of published lectures), I also had to remove some less important old content right away: The Webpack section, the old, short Next.js section, the old Deployment section, the Redux Saga section.

        All those sections are of course still available via download!

        How should you proceed?
        How you should proceed depends on your current status:

        You haven't started the course yet or you haven't progressed much yet ("NOT STARTED")

        You are well into the course already and you're currently doing the course ("WELL INTO THE COURSE")

        You completed the course in the past or you haven't visited it for a longer time period ("COMPLETED / PAUSED")

        NOT STARTED

        Simply restart with the updated course (i.e. take lecture 1 in section 1 to start the new course)

        Ignore the old course content, the new course will teach you everything in a better way

        WELL INTO THE COURSE

        Consider restarting if you have the time: The new course will contain sharpened explanations, new demos and examples and is arguably a bit better than the old one

        But you can also just finish the existing course (in the transitional period until May 3rd or by downloading the old course content, see next lecture)

        You will still learn React in a best-practice way! You will learn all about React Hooks => It's just the strong focus on class-based components which is not as important anymore

        Definitely explore the recommended new content you find below!

        COMPLETED / PAUSED

        You can ignore the update in general as you did still learn React in a best-practice way! You did learn all about React Hooks => It's just the strong focus on class-based components which is not as important anymore

        If you have the time, definitely consider taking the full course again: It will contain sharpened explanations, new demos and examples and simply is better than the old one!

        Definitely explore the recommended new content you find below!

        New Content Which You Definitely Should Explore
        The new first ("Getting Started") module to get an overview of the new course

        The Next.js introduction module

        The React.js summary module

        The new Routing ("Building a Multi-Page SPA with React Router") module

        The new Redux sections => They now also include Redux Toolkit!

        The new Testing section (released on May 3rd)

        The new Authentication section (released on May 3rd)

        The new React + TypeScript section (released on May 3rd)

        All the new "Project" or "Practice" course sections where we build demo apps

        Frequently asked questions
        What about my course progress / course completion certificate?

        Unfortunately, since the new course was inserted into this existing course, your course progress is reset / diluted.

        But you get a complete new course with many improvements for free! It's probably worth it ;-)

        To regain your course progress and certificate, you can simply mark lectures as completed manually. It's annoying but will only take a few minutes.

        What about my notes or existing threads in the Q&A section (for the old content)?

        Unfortunately, notes and existing Q&A threads will be lost, once the old content is removed (i.e. lectures are unpublished). Udemy doesn't offer a way of saving that data at the moment - that is beyond my control.

        Why didn't you create a new course?

        I wanted to make this update available for free!

        There also is no possible way on Udemy to offer a brand-new course for free (without leaking it to the entire world) anymore, hence this is the best approach going forward. It also ensures that no student misses this update!

        Will you remove the old content?

        Yes, please see above.

        Why will you remove the old content?

        Because it unnecessarily bloats the course, makes it look bigger than it is and forces students to go through two courses instead of one. Keeping it around therefore is only a temporary workaround.

        I have another question!

        If it wasn't answered in this article already, feel free to ask in the Q&A - I'll do my best to help there! :)

        Resources for this lecture
        course-update-udemy.pdf

    487. Old Course Content Download
        Attached to this lecture you find download links to the old course content (by sections).

        Each ZIP file contains the videos, VTT captions and code attachments for the section.

        You should ignore that old course content if you took / are taking the updated course - the new course is more detailed and simply better.

        Unfortunately, Udemy messed up the attachment order (and I can't change that order), so don't get confused by that :)

        Resources for this lecture
        01 Getting Started.zip
        02 JS Refresher.zip
        02 Base Syntax.zip
        05 Styling.zip
        06 Debugging.zip
        07 Component Deep Dive.zip
        10 Http Project.zip
        09 Http.zip
        08 Project Burger Builder Start part 1.zip
        08 Project Burger Builder Start part 2.zip
        12 Routing Project.zip
        14 Redux Basics.zip
        11 Routing.zip
        13 Forms.zip
        15 Redux Project.zip
        04 Lists & Conditionals.zip
        zz Bonus Next.js.zip
        zz Bonus Redux Saga.zip
        zz React Hooks part 2.zip
        zz React Hooks Burger Builder.zip
        zz Bonus Burger Builder CSS.zip
        20 Testing.zip
        17 Advanced Redux Project.zip
        zz Bonus Animations.zip
        zz Bonus Webpack.zip
        19 Burger Improvements.zip
        zz React Hooks part 1.zip
        22 Roundup.zip
        18 Authentication.zip
        16 Advanced Redux.zip
        21 Deployment.zip
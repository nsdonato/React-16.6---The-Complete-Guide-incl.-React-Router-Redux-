## SECCION 1 ##

    1. Introduction
    2. What is React?

        Que, como y porque:
            Una libreria de JavaScript para crear interfaces de usuario (Componentes)
            Corre en el navegador.
            Podemos reusar componentes.
    3. Join our Online Learning Community
        As a student of this course you also get free access to our "Academind Community" on Discord: https://discord.gg/gxvEWGU

        There, you can find like-minded people, discuss issues, help each other, share progress, successes and ideas and simply have a good time!

        I believe that you learn the most if you don't learn alone but find learning partners and other people with similar interests. Our community is a great place for this - it's the perfect complimentary resource for this course.

        Joining it is of course free and 100% optional.
    4. Real-World SPAs & React Web Apps

        Adding the Right React Version to Codepen

        In the next lecture, we'll write our first React code in Codepen, an online editor (it's only getting used in the next lecture).
        Currently, there seems to be a bug if you add React as shown in the next video.
        To fix it, replace the automatically added import paths (you'll see what I mean) with these:
            https://cdnjs.cloudflare.com/ajax/libs/react/15.6.1/react.min.js 
            https://cdnjs.cloudflare.com/ajax/libs/react/15.6.1/react-dom.min.js 
        This should fix. And don't worry about the React version, the entire rest of the course uses 16+ :)

    5. Writing our First React Code
        
        Crear una aplicación en Codepen.
            Cuando se repite un elemento pero tiene diferente información adentro, esto ya se puede entender como un componente.

        - Importar React:
            https://cdnjs.cloudflare.com/ajax/libs/react/15.6.1/react.min.js 

        - Importar React DOM, la logica para crear los componentes en el DOM real.
            https://cdnjs.cloudflare.com/ajax/libs/react/15.6.1/react-dom.min.js 

        - Para utilizar las últimas caracteristicas de React --> Babel

        // Tiene que comenzar con mayuscula para que funcione bien.
        function Person(){
            return (
                <div className="person">
                    <h1>Max</h1>
                    <p>Your Age: 28</p>
                </div>
            );// Sintaxis JSX, para renderizar el DOM.
        }

        ReactDOM.render(<Person />, document.querySelector('#p1')); 

        // el metodo render nos permite representar una función de JavaScript como componente del DOM real, y tratarlo como un componente.
        // le decimos que renderice como html ese objeto Person.
        // le decimos en donde queremos que se vea ese componente.

        * las clases en el codigo html se tienen que escribir className en vez de class. Porque React renderiza ese html como un componente JavaScript (que usa la propiedad className)

        // Le agrega un argumento que es propio de react
        // los datos dinamicos se encierran entre { }
        
        function Person(props){
            return (
                <div className="person">
                    <h1>{props.name}</h1>
                    <p>{props.age}</p>
                </div>
            );// Sintaxis JSX, para renderizar el DOM.
        }

        ReactDOM.render(<Person name="Max" age="28"/>, document.querySelector('#p1')); 
        ReactDOM.render(<Person name="Manu" age="29"/>, document.querySelector('#p2')); 

        En vez tener un elemento div con la clase p1, ahora solo vamos a tener uno con id Apps
        HTML:
        <div id="app"></div>

        JS:
        function Person(props){
            return (
                <div className="person">
                    <h1>{props.name}</h1>
                    <p>{props.age}</p>
                </div>
            );// Sintaxis JSX, para renderizar el DOM.
        }

        var app = (
            <div>
                <Person name="Max" age="28" />
                <Person name="Manu" age="29" />
            </div>
        );

        // En vez de tener dos elementos, tengo uno solo que tenga los 2.
        ReactDOM.render(<app/>, document.querySelector('#app')); 

        * Este es el mejor modo para crear SAP. Single Page Applications.

    6. Why should we choose react?

        Porque en aplicaciones grandes es dificil de manejar el ESTADO.
        Aparte si tenes que cambiar los elementos de lugar y puede que tengas que cambiar cosas y estas usando querySelector.
        
        React nos permite enfocarnos en nuestra logica de negocios, envitando que nuestra app explote.
        Supuestamente como React tiene una comunidad zarpada, el codigo es excelente.
        Aparte de tener un gran ecosistema, comunidad activa y alta performance.

    7. React alternatives.

        Angular y Vue.js
            Te sirve para enforcarte en la logica y en el modelo de negocio, y no tanto en el aspecto del elemento en particular que        querías cambiar (como en react)

    8. Understanding Single Page Applications and Multi Page Applications.

        SAP:
            Solo recuperamos un solo archivo html, el contenido es renderizado en el cliente.
            Esta construidda por componentes, y cada componente es un componente React, también es mantenida por un componente root de React, que esta bajo el cotnrol de React.
            Tipicalmente tenemos una llamada reactDOM.render(), se necesita una sola porque tenemos un componente raiz, que esta montado en el DOM que tiene todo el resto de componentes.

        MPA:
            Recuperamos varias paginas determinadas, donde cada pagina tiene el contenido para una ruta determinada, y el contenido es renderizado en el servidor.
            Algunas partes de la pagina son componentes React.
            Los widgets individuales no conocen la existencia de otros.
            Vamos a tener varios reactDOM.render para los diferentes componentes, en difernetes lugares de la app.

    9. Course outline.

        Getting started.
            Usar JavaScript moderno porque mantiene limpio y es un estandar para react, funciones de flechas, etc.
        
        React basics.
            Como crear componentes reacts, ver las diferentes maneras que hay de hacerlo y como comunicarse entre componentes.
            Como podemos generar listas, o como podemos presentar contenido de forma condicional.

        Debug
            Como debuggear react.

        Styling componentes 
            Como darle estilo a los componentes y como podemos asegurarnos de que el estilo que aplicamos a un componente, solo se aplique a ese componente y no a todos.

        Componentes Deep Dive
            Pronfudización en los componentes, ya que tendremos mucho conocimiento de ellos, vamos a aprender cual es su ciclo de vida.
            Como comprobar actualizaciones a menudo o no.

        HTTP Request
            Como conectarla con el mundo exterior, como obtener datos de un servidor o subirlos al servidor.

        Routing.
            Es una caracteristica del Core de las SAP, porque con routing, podemos manejar diferentes urls, /productos /usuarios  diferentes paginas, aunque tengamos un solo HTML, y en realidad
            lo que hacemos es analizar la url y renderizar las diferentes partes que necesitamos, para mostrar "una nueva pagina".
        
        Forms and validation.
            validación de entrada de datos de los usuarios, etc.

        Redux
            es una biblioteca de terceros pero se usa muchisimo con react.
            acciones asincronas, etc.

        Authentication
            login de usuario.

        Testing
            Introducción a como probar app de react.

        Deployment
            Como publicar en producción

        Bonus: aplicaciones de react animadas, ubicación de reactores, webpack, etc.
            NextJs, una libreria construida bajo react, donde construimos nuestro propio flujo de trabajo, etc.
        
    10. How to get the Most out of This Course

        Como sacarle provecho al curso:
            Codificar solo.
            Si algo no funciona, chequear contra su codigo.
            Si estas atascado, usar lar parte donde se hacen las preguntas, primero buscar porque seguro alguien ya pregunto.
            Practicar.

    11. Useful Resources & Links

        Documentación de React: https://reactjs.org/
        El codepen, hecho por él: https://codepen.io/anon/pen/MELQaQ


### Sección: 2 - Refreshing Next Generation JavaScript (Optional) ###

    12. Module Introduction
        Next-Gen Javascript, para refrescar. React usa esto, así que, hay que saberlo.

    13. Understanding "let" and "const"
        let = var (cambia el tema del scope, porque ahora es de bloque.)
        const = para info que no va a cambiar.

    14. Arrow Functions
        antes:
            function myFuncion() {
                ...
            } 

        ahora:
            const myFuncion = () => {
                ...
            }

        * Arrow functions, mejoran el problema de que this, no siempre apuntaba al contexto de ejecución, sino al objeto global.
        * Si no tiene parametros, va solo parentesis
        * Si tiene uno, es param => 
        * Si tiene mas de uno, es (param1,param2) =>
        * Si la parte de retorno solo tiene una linea, se puede escribir así: const multiplicar = number => number * 2;

    15. Exports and Imports

        Para codigo modular, para dividir los archivos js en varios archivos.
            Si bien ya se puede (porque agregas diferentes archivos en el html, de manera ordenada)
            Lo que pasa ahora es que desde un js, se puede usar info de otro js.

        EXPORTAR
            person.js
                const person = {
                    name: 'Max'
                } 
                export default person

                // export: sirve para exportar esa función, objeto, etc, desde un archivo.
                // default: que esa funcion, obj, etc, va a ser la predeterminada.
                // person: en este caso es el objeto 

            utility.js
                export const clean = () => { ... }
                export const baseData = 10;

        IMPORTAR
            app.js
                // Se pone de alguna de las dos maneras, ya que hace referencia a lo único que se exporto (default)

                    import person from './person.js' 
                    import prs from './person.js'   

                // Al ser exportada como diferentes constantes, se usa las { }  para "mejorar el codigo", diciendo que se esta exportando algo especifico
                // Tiene que respetar el nombre que se le puso en el archivo donde se la exporta obj
                // se puede ponerle un alias, como en la segunda linea

                    import { baseData } from './utility.js' 
                    import { baseData as bd } from './utility.js' 

                // También se podría hacer de esta manera.

                    import { baseData, clean } from './utility.js' 

    16. Understanding Classes

        - Los metodos son como: funciones atachados a esa clase/objetos,
        - las propiedades son como: variables, atachadas a esa clase/objetos,

        class Human {
            constructor(){
                this.gender = 'male';
            }

            printGender(){
                consoe.log(this.gender);
            }
        }

        // Herencia
        class Person extends Human{
            constructor(){
                super();
                this.name = 'Max';
                this.gender = 'female'; // pero no es correcto usar así.
            }
            
            printMyname (){
                console.log(this.name);
            }
        }

        // Instanciar un objeto de esa clase.
        const miPersona = new Person();
        miPersona.printMyname();
        miPersona.printGender();    

    17. Classes, Properties and Methods

        ES6
            constructor() {
                this.myProperty = 'value'
            }

            miMetodo () {
                ...
            }

        ES7
            myProperty = 'value'; // Si, no hay un "constructor" en si.

            miMetodo = () => {
                ...
            }
            
        * Es mejor usar ambos opciones de ES7, para esto si o si hay que usar ES6/Babel.

    18. The Spread & Rest Operator  

        // Operator Spread o Rest (depende de donde se use)
        ...

        Spread: (división de las propiedades de un objeto o un array.)

                Se usa para dividir elementos de un array o propiedades de un objeto.
                Por ejemplo, si tenemos una matriz antigua y queremos agregar todos los elementos de esa matriz anterior a una nueva matriz y,
                además, agregar un 1 en un elemento dos, este primer índice sería lo que tenía tres puntos delante
                de toda la matriz. simplemente extraiga todos los elementos y agregue a la nueva matriz que
                creamos con corchetes.

                // Idem object pero array
                    const oldArray = [3,4,5];
                    const newArray = [...oldArray,1,2];
                    console.log(newArray);
                    // 3,4,5,1,2

                // Lo probé, lo que hace es agarrar las propiedades/funciones del objeto viejo, y ponerselo al nuevo y suma la nueva prop/func.
                const oldObject = {
                    name: "Noe";
                }

                const newObject = { ...oldObject, newProp: 5 }
                console.log(newO)
        Rest: (Fusión de elementos en un array)
            
            Se utiliza con menos frecuencia.

            Se usa para mergear una lista de argumentos de funciones en una matriz.
            O sea, lo usamos en el parametro de una función. ej:

            // Recibe una lista ilimitada de argumentos, y todos se fusionan en un array.
            // O sea, en vez de dividir, los une.
            function sortArgs(...args){
                return args.sort[]; 
            }
        
        * Hay que tener en cuenta que si el numero o propiedad / funcion, ya existia en el objeto actual, lo sobreescribe.
        
        array.filter()  // ejecuta una función en cada elemento de la matriz y se verifica si existe un elemento en ella, ej:
        const filter = (...args) => {
            return args.filter(el => el === 1);
        }

        console.log(filter(1,2,3));
        // [1]

    18. Destructuring

        Permite extraer facilmente elementos de una matriz o propiedades de objetos y guardarlos en variables.
        ej:

        array:
            [nombre, apellido] = ['Noe','Donato'];
            console.log(nombre); // Noe
            console.log(apellido); // Donato

            const numbers = [1,2,3];
            [num1, num2] = numbers;
            console.log(num1,num2); // 1 2

            [num1, ,num3] = numbers;
            console.log(num1,num3); // 1 3

        object:
            { name } = { name: 'Noe', age: '32' };
            console.log(name); // Noe
            console.log(age); // undefined

    19. Reference and Primitive Types Refresher

        Primitivos
        * Copia el valor de su variable en otra, osea hay 2.
        number, boolean, string

        Referencia
        * No copia, sino que hace referencia al puntero en memoria del otro objeto.
        Object, arrays.

            const person = {
                name: 'Max'
            };
            const secPerson = person;
            person.name = 'Manu';

            console.log(secPerson); // 'Manu'

        Para copiar un objeto, o sea generar uno nuevo, deberíamoshacer:
            const person = {
                name: 'Max'
            };
            const secPerson = {
                ...person
            };
            person.name = 'Manu';

            console.log(secPerson); // 'Max'

    20. Refreshing Array Functions

        const numbers = [1,2,3];

        // La función se va a ejecutar por cada elemento
        // Al parametro le ponemos num, porque esta recorriendo numeros, como para ser claros.
        const numbers = [1,2,3];
        const doubleNumArray = numbers.map((num) => num * 2 );
        console.log(doubleNumArray); // [2,4,6]

    21. Wrap Up

        Basicamente que cualquier cosa, se puede volver a esas clases para refrescar por si te olvidaste algo.

    22. Next-Gen JavaScript - Summary

        Me la pase resumiendo y lo dejó él, acá: 

        Descargar el pdf o en mi caso ver:
            file:///C:/Users/Noe/Downloads/next-gen-js-summary.pdf
            
    23. JS Array Functions

        En realidad, no la próxima generación de JavaScript, pero también es importante: un arreglo de funciones de JavaScript, como map() , filter() , reduce()  etc.
        Me verás usarlos bastante ya que muchos conceptos de React se basan en trabajar con arreglos (de manera inmutable).

        La siguiente página ofrece una buena descripción general de los diversos métodos que puede utilizar en el prototipo de matriz. No dude en hacer clic en ellos y actualizar sus conocimientos según sea necesario:  
            https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array
            
        Particularmente importantes en este curso son:

        map()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
        find()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
        findIndex()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
        filter()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
        reduce()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce?v=b
        concat()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat?v=b
        slice()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice
        splice()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice

### Sección 3 - Understanding the Base Features & Syntax ###

    25. Module Introduction

        Que es, como usarlo, nuestra primera app react, conceptos generales, sintaxis basicas, etc.

    26. The Build Workflow

                    Recomendado para SPA y MPAs

        Porque?     
                - Optimización de codigo en grandes apps, para tener también el menor codigo postible, considerando el peso de las app también.

                - Usar nex-gen JS. Mejoramos como desarrolladores, y funcionan mejor las app, porque basicamente usar esto es "comprometerse con las mejores practicas"
                    Como no en todos los browsers se soporta esto, se debe usar un flujo de trabajo diferente, para poder compilar next-gen javascript y usarlo.

                - Ser mas productivo. 
                    Incluir, auto-prefixing de CSS. 
                    Linting: una herramienta que te dice si estas escribiendo mal codigo o podes hacer mas optimo algún codigo especifico.
        
        Como?       
                - Gestor de dependencias: npm o yarn (3ty parth libraries)
                - Bundler "Controlador", recomendado: webpack
                    Para escribir codigo modular, para tener una tarea/enfoque claro y nos resulte mas facil de mantener y administrar.
                - Compilador (para next-gen), recomendado: Babel + presets
                - Un Web Server de desarrollo. 
                
        * Nos va a enseñar una herramienta de desarrollo que hace todo esto menos engorroso y no tenemos qe andar configurando todo, es una herramienta que generó el equipo de React de facebook.
        * En otro modulo enseña como hacer una desde 0 igual.

    27. Using Create React App

        Es la herramienta recomendada para crear proyectos de React. "Create React App"

        - Instalar Node JS.
        > npm install -g create-react-app // Instalar globalmente, para poder llamarla desde cualquier lado.
        > create-react-app react-guia-completa // El segundo parametro es el nombre de la app.
        > cd react-guia-completa
        > npm start

    28. Understanding the Folder Structure
        C:\Cursos\React-16.6---The-Complete-Guide-incl.-React-Router-Redux-\info_gral_curso\27\ide-setup.pdf

        package.json
            Donde estan las dependencias y los diferentes scripts que podemos ejecutar para correr diferentes tareas. Dependencias productivas y de desarrollo.

        node_modules
            Donde estan las dependencias de cada paquete, y los paquetes en si de Node.
        
        public
            Es la carpeta raiz, donde van a estar todos los archivos que se le sirven al cliente.
            
            index.html 
                Es la única que tenemos y la única que vamos a tener. NUNCA TENEMOS QUE AGREGAR PAGINAS.
                Si es una MPA (Multi Page Application), el Workflow va a tener que ser diferente.
                Si queremos agregar otro css, va ahí.
                No metamos html dentro del html
            
            manifest.json
                Nos brinda una aplicación web progresiva, lista para usar.

        scr
            Ahí van los archivos que podemos editar.

            index.js
                obtiene acceso al elemento raiz de nuestro DOM del arch html, para que dentro del elemento con id="root" se renderice nuestra aplicación react.
            
            App.js 
                Actualmente ahí tenemos nuestro primer componente.
        
            registerServiceWorker.js (En la ultima versión no esta este archivo, esta: serviceWorker)
                Es importante para registrar un service worker, que es generado automaticamente, relacionado a la PWA
                Basicamente, pre-cachea los archivos scripts.

            App.test.js
                Nos permite crear pruebas unitarias para los diferentes componentes en nuestra app.

        - Eliminar el logo de react.svg y la linea que importa el logo.
        - Eliminar del archivo css, todo menos la parte de .App
        
    29. Understanding Component Basics
        file:///C:/Cursos/React-16.6---The-Complete-Guide-incl.-React-Router-Redux-/info_gral_curso/28/components-learning-card.pdf

        index.js
            import React from 'react';
            import ReactDOM from 'react-dom';
            import './index.css';
            import App from './App';
            import * as serviceWorker from './serviceWorker';

            // Siempre vamos a tener un elemento donde van a estar todos los componentes
            // y que lo vamos a renderizar en un id x ej root.
            ReactDOM.render(<App />, document.getElementById('root'));

        app.js
            import React, { Component } from 'react';
            import './App.css';

            class App extends Component {
                render() {
                    return (
                        <div className="App">
                            <h1>Hola, soy una App React</h1>
                        </div>
                    );
                }
            }

            export default App;

        - Para definir un componente, hay 2 maneras.
            1) 
                1.1) Creamos una clase y lo hacemos heredar de Component, 
                    
                    que se importa de la libreria de react.
                    React, se importa porque es necesario para renderizar el componente y el objeto componente.
                
                1.2) el metodo render() 
                        sirve para renderizar JSX en la pantalla.

            2)
        - 

        * Por lo general cuando se elige el nombre de un componente, se usa ese nombre para la variable a importar, para el archivo y para el elemento.
        * Los archivos también podrían llamarse JSX, pero se usa js por convención.
            JSX en realidad es lo que llaman syntactic sugar. Es una sintaxis dentro de un lenguaje de programación, diseñado para ser mas facil de leer o expresarse.
            Es como "mas dulce para que lo use una persona"

    30. Understanding JSX

        class App extends Component {
            render() {
                // Podemos usar el objeto de React para crear un elemento.
                // createElement, toma infinitos argumentos, pero el primero es o un elemento o un componente.
                // 2 arg: puede ser un objeto, aunque es opcional, por lo tanto pasamos null
                // 3 arg, los hijos: a partir de ese, van separados por comas, y basicamente s todo lo que va a ir, adentro del primer arg, el div en este caso.
                    1 linea: como el comportamiento por default es tomar todo por texto, va a imprimir en pantalla, h1Iamreactapp, 
                    2 lines: así que hay que usar otro react.createelement...
                    3 linea: Para pasarle estilo

                //return React.createElement('div', null, 'h1','I\'m a React App!!!!');
                //return React.createElement('div', null, React.createElement('h1',null,'I\'m a React App!!!!'));
                return React.createElement('div', { className: 'App'}, React.createElement('h1',null,'I\'m a React App!!!!'));

            }
        }

        * NO SE USA CREAR LOS ELEMENTOS ASÍ, es para que sepamos que existe esto y no es lo correcto.
        Para eso se genera el "HTML, que en realidad es JSX" = javascript.

    31. JSX Restrictions

        Como en realidad el html que vemos es JSX, no podemos usar palabras claves como class, debemos en este caso, por ej usar className, en el elemento.
        No podemos devolver elementos que no tienen un padre. Por ej, no podemos poner un elemento hermano al div root.
        Es buena practica, es meter todo dentro de un contenedor a devolver.

    32. Creating a Functional Component

        vamos a crear un componente:
            src/
                Person/
                    Person.js
            Por convención el nombre comienza con mayus.
            Por convención las funciones van en minuscula.
        
        La gran mayor cantidad de tiempo los componentes se crean como el de app, pero por lo general son solo funciones.
        
        Para crear un componente entonces (que no derive de Component): 
            Generamos una función.
            La exportamos como default.
            Retornamos JSX

        Para usar en nuestro component App:
            Importamos el componente.
            Dentro del html que estamos retornando, agregamos el tag con nuestro componente.

        <Person /> // lo podemos dejar así ya que no tenemos que anidar nada adentro.

    33. Components & JSX Cheat Sheet
        Descargar pdf o file:///C:/Users/Noe/Downloads/components.Pronfudización

        Los componentes son el componente básico de las aplicaciones React . En realidad, React realmente es solo una biblioteca para crear componentes en su núcleo.

        Por lo tanto, una aplicación React típica podría representarse como un árbol de componentes : tiene un componente raíz ("Aplicación") y luego una cantidad potencialmente infinita de componentes secundarios anidados.
        Cada componente debe devolver / generar algún  código JSX ; define qué código HTML React debe procesar al DOM real al final.
        JSX NO es HTML pero se parece mucho a eso. Sin embargo, se pueden ver las diferencias cuando se mira de cerca (por ejemplo, className en JSX vs class en "HTML normal"). JSX es solo azúcar sintáctica para JavaScript, lo que le permite escribir código HTML en lugar de llamadas React.createElement (...) anidadas.
        
        Al crear componentes, puede elegir entre dos formas diferentes:
            Componentes funcionales (también conocidos como componentes de "presentación", "tontos" o "sin estado"; más información sobre esto más adelante en el curso) =>  
                const cmp = () => {
                    return <div>some JSX</div> 
                } 
                (se recomienda usar las funciones de flecha de ES6 como se muestra aquí, pero es opcional)

            Componentes basados ​​en clase (también conocidos como componentes "contenedores", "inteligentes" o "con estado") => 
                class Cmp extends Component { 
                        render () { 
                            return <div>some JSX</div> 
                            } 
                } 
        
        Por supuesto, nos sumergiremos en la diferencia a lo largo de este curso. Ya puede notar que debe usar 1) con la mayor frecuencia posible. Es la mejor práctica.

    34. Working with Components & Re-Using Them

        Trabajar componentes en archivos separados, hace que el codigo sea mas mantenible.
        Aparte se lo puede configurar y reutilizar.
        return (
            <div className="App">
            <h1>Hola, soy una App React</h1>
            <Person />
            <Person />
            <Person />
            </div>
        ); 

        * Esto no es dinamico, así que en el proximo vamos a ver como hacerlo..

    35. Outputting Dynamic Content

        Para que el js, no sea interpretada como texto, se debe usar ${js que quiera}
            return <p>Soy una persona and I am {Math.floor(Math.random() * 30)} years old! </p>

        Esto se usa para simples calculos o llamadas a funciones, pero nada mas, debería ser solo una linea de codigo

    36. Working with Props
        Descargar pdf o file:///C:/Users/Noe/Downloads/props-learning-card.pdf

        return (
            <div className="App">
            <h1>Hola, soy una App React</h1>
            <Person name="Max" age="28"/>
            <Person name="Manu" age="29"/>
            <Person name="Noe" age="32"/>
            </div>
        ); 
        
        Del componente principal, se le pasa al componente que corresponde el valor de las propiedades.

        Person.js
            #IMPORTANTE: El argumento es un objeto con toda la info que se le pasa al componente, se puede llamar props, como se puede llamar pepito.

            const person = (props) => {
                return <p>Hola! Soy {props.name} y tengo {props.age} años! </p>
            }

        #IMPORTANTE: Cuanto se usa en una clase-componente (como app), se tiene que usar this.props

    37. Understanding the Children Property
        en esta carpeta: base-syntax--01-props-custom-cmp.zip

        <div>
            <p>I'm {props.name} and I am {props.age} years old!</p>
            <p>{props.children}</p>
        </div>

        Si queremos pasar algo entre la etiqueta de apertura y cierre, tenemos que envolver eso en un elemento padre y usar children.

        <div className="App">
            <h1>Hola, soy una App React</h1>
            <Person name="Max" age="28"/>
            <Person name="Manu" age="29">My hobbies: Racing</Person>
            <Person name="Noe" age="32"/>
        </div>

    38. Understanding & Using State

        <button>Cambiar de nombre</button>

        State:
            #IMPORTANTE: 
                - SOLO SE PUEDE USAR: En las clases-componentes
                - es una propiedad especial, donde se establecen y pasan props desde afuera como name, age etc, y que se gestionan dentro del componente.
                    Si cambiamos algo que use esta propiedad, va a renderizar nuevamente el dom/componente.

                Se inicializa como un objeto.
                    state = {}
                Se le pueden agrengar, array objetos:
                    state = {
                        persons: [
                            { name: 'Noe', age: 32 },
                            { name: 'Gabu', age: 29 },
                            { name: 'Nany', age: 33 },
                        ]
                    }

                Una vez que hacemos esto, la podemos usar en nuestro metodo dinamico.

                <div className="App">
                <h1>Hola, soy una App React</h1>
                <button>Cambiar de nombre</button>
                <Person name={this.state.persons[0].name} age={this.state.persons[0].age}/>
                <Person name={this.state.persons[1].name} age={this.state.persons[1].age}>My hobbies: Racing</Person>
                <Person name={this.state.persons[2].name} age={this.state.persons[2].age}/>
                </div>

                props.children mostraría por ej en el componente Person "My hobbies: Racing"

            this, hace referencia a la clase donde se esta usando 
    39. Props & State
        file:///C:/Users/Noe/Downloads/props-state.pdf

        props  y state  son los conceptos CORE de React. Solo props  y/o state activa React para volver a renderizar sus componentes y potencialmente actualizar el DOM en el navegador 

        Props
            props: le permite pasar datos de un componente principal (container) a un componente secundario (embebido).

        Ejemplo:
            AllPosts Component:
                const posts = () => {
                    return (
                        <div>
                            <Post title="My first Post" />
                        </div>
                    );
                }

            Aquí title  está la propiedad personalizada ( prop ) configurada en el Post  componente personalizado . Básicamente, replicamos el comportamiento del atributo HTML predeterminado que ya conocemos (por ejemplo, <input type="text">  le informamos al navegador acerca de cómo manejar esa entrada).

            Post Component:
                const post = ( props ) => {   
                    volver ( 
                        <div>
                            <h1> { props . título } </ h1 >
                        </ div >
                    );
                }

            El Post  componente recibe el props  argumento. Por supuesto, puede nombrar este argumento como desee: es la definición de su función, ¡a React no le importa! Pero React pasará un argumento a su función de componente => Un objeto, que contiene todas las propiedades que configuró <Post ... /> .
            {props.title}  luego genera dinámicamente la title  propiedad del props  objeto, que está disponible ya que configuramos la title  propiedad dentro del AllPosts  componente (ver arriba).


        State:
            Mientras props le permiten pasar datos al árbol de componentes (y, por lo tanto, desencadenar una actualización de la interfaz de usuario), el estado se usa para cambiar el componente, bueno, el estado desde dentro. Los cambios en el estado también activan una actualización de la interfaz de usuario.

        Ejemplo:
            NewPost Component:
                ¡La clase NewPost extiende el Componente { // estado solo se puede acceder en los componentes basados ​​en clase!     
                
                class NewPost extends Component { // state can only be accessed in class-based components!
                    state = {
                        counter: 1
                    };  
                
                    render () { // Needs to be implemented in class-based components! Needs to return some JSX!
                        return (
                            <div>{this.state.counter}</div>
                        );
                    }
                }

            Por supuesto, puede pasar state  a componentes funcionales, pero estos no pueden editarlo directamente.
            state  => 
                Simplemente es una propiedad de la clase de componente, debes llamarlo state, obligatoriamente. 
                Luego, puede acceder a él a través this.state  de su código JSX de clase (que devuelve en el render()  método requerido ).
                Cada vez que state  cambia, el componente se volverá a representar y reflejará el nuevo estado. 
                
                La diferencia con props es que esto sucede dentro de un mismo componente: ¡no recibe datos nuevos ( props ) de fuera!

    40. Handling Events with Methods
        // en JSX es con la C mayus.
        <button onClick=>Cambiar de nombre</button>

        es buena practica ponerle al final Handler, a la función que haga de handler.

        switchNameHanlder = () => {
            console.log("click");
        }
        
        a la función no hay que ponerle los () para que no lo llame en ese mismo momento.

        <button onClick={this.switchNameHanlder}>Cambiar de nombre</button>

    41. To Which Events Can You Listen?

        En la última conferencia, vimos que puedes reaccionar ante el evento onClick, pero ¿a qué otros eventos puedes escuchar? Puede encontrar una lista de eventos compatibles aquí:  https://reactjs.org/docs/events.html#supported-events

        Clipboard Events
            Event names:
                onCopy onCut onPaste
            Properties:
                DOMDataTransfer clipboardData
        
        Composition Events
            Event names:
                onCompositionEnd onCompositionStart onCompositionUpdate
            Properties:
                string data
            
        Keyboard Events
            Event names:
                onKeyDown onKeyPress onKeyUp
            
            Properties:
                boolean altKey
                number charCode
                boolean ctrlKey
                boolean getModifierState(key)
                string key
                number keyCode
                string locale
                number location
                boolean metaKey
                boolean repeat
                boolean shiftKey
                number which

        Focus Events
            Event names:
                onFocus onBlur
            
            These focus events work on all elements in the React DOM, not just form elements.

            Properties:
                DOMEventTarget relatedTarget
        
        Form Events
            Event names:
                onChange onInput onInvalid onSubmit
            
            For more information about the onChange event, see Forms.

        Mouse Events
            Event names:
                onClick onContextMenu onDoubleClick onDrag onDragEnd onDragEnter onDragExit
                onDragLeave onDragOver onDragStart onDrop onMouseDown onMouseEnter onMouseLeave
                onMouseMove onMouseOut onMouseOver onMouseUp
            
            The onMouseEnter and onMouseLeave events propagate from the element being left to the one being entered instead of ordinary bubbling and do not have a capture phase.

            Properties:
                boolean altKey
                number button
                number buttons
                number clientX
                number clientY
                boolean ctrlKey
                boolean getModifierState(key)
                boolean metaKey
                number pageX
                number pageY
                DOMEventTarget relatedTarget
                number screenX
                number screenY
                boolean shiftKey
        Selection Events
            Event names:
                onSelect
        
        Touch Events
            Event names:
                onTouchCancel onTouchEnd onTouchMove onTouchStart

            Properties: 
                boolean altKey
                DOMTouchList changedTouches
                boolean ctrlKey
                boolean getModifierState(key)
                boolean metaKey
                boolean shiftKey
                DOMTouchList targetTouches
                DOMTouchList touches
        
        UI Events
            Event names:
                onScroll
            Properties:
                number detail
                DOMAbstractView view

        Wheel Events
            Event names:
                onWheel
            Properties:
                number deltaMode
                number deltaX
                number deltaY
                number deltaZ
        
        Media Events
            Event names:
                onAbort onCanPlay onCanPlayThrough onDurationChange onEmptied onEncrypted
                onEnded onError onLoadedData onLoadedMetadata onLoadStart onPause onPlay
                onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend
                onTimeUpdate onVolumeChange onWaiting

        Image Events
            Event names:
                onLoad onError
        
        Animation Events
            Event names:
                onAnimationStart onAnimationEnd onAnimationIteration
            Properties:
                string animationName
                string pseudoElement
                float elapsedTime

        Transition Events
            Event names:
                onTransitionEnd
            Properties:
                string propertyName
                string pseudoElement
                float elapsedTime
        Other Events
            Event names:
                onToggle

    42. Manipulating the State
        file:///C:/Users/Noe/Downloads/state-learning-card.pdf

        switchNameHanlder = () => {
            // No hay que mutar de esta manera (cambiar de estado), va a dar un error.
            //this.state.persons[0].name = 'Noelia';
            this.setState({
                persons: [
                    { name: 'Noeñs', age: 32 },
                    { name: 'Gabuns', age: 29 },
                    { name: 'Nanys', age: 33 },
                ]
            )
        }

        setState:
            Esta disponible solo en clases basadas en componentes.

            Este es un método que nos permite actualizar esta propiedad state, después
            nos aseguramos de que react conozca como la actualización y react actualice el DOM.

            // Toma un objeto como argumento y fusionara (sobreescribe) eso con nuestro estado actual
            switchNameHanlder = () => {
                this.setState({
                    persons: [
                        { name: 'Noels', age: 32 },
                        { name: 'Gabuns', age: 29 },
                        { name: 'Nanys', age: 33 },
                    ]
                })
            }

            * Solo se pueden cambiar props y state 

    43. Function Components Naming

        En la próxima conferencia, aprenderemos a administrar el estado en componentes funcionales (en lugar de componentes basados en clases).

        En caso de que esté obteniendo un error con el código que se muestra en la siguiente clase, simplemente asigne un nombre de variable en mayúscula a la variable que contiene su componente funcional.

        Ejemplo:
            Utilizar
                const App = () => {...}
                en lugar de

                const app = () => {...}

        Técnicamente, eso no es necesario, pero dependiendo de la configuración de su proyecto, el indicador incorporado (una herramienta de verificación de la calidad del código) que viene con la aplicación crear-reaccionar puede no gustarle el nombre de la variable en minúscula.

        También puede evitar esto creando proyectos con la versión correcta de react-scripts, que recomendaría para este curso de todos modos (vea el video de instalación, conferencia 26)

        create-react-app my-app --scripts-version 1.1.5

    44. Using the useState() Hook for State Manipulation
        base-syntax--02-state-events.zip

        Hasta React 16.8 setState era la unica manera de manejar estados en las aplicaciones de React.

        Ahora hay una característica llamada React Hooks, se utiliza mas que nada en los componentes de funciones.

        IMPORTANTE: El va a seguir enseñando la manera tradicional (clases basadas en componentes) porque en las compañias ya tienen proyectos hechos basados en esto.
        
        Si bien desde React 16.8 podemos usar componentes funcionales para todo, vamos a mantenernos en las clases basadas en componentes, porque el dice que en los laburos se usa mas eso.
        
        "react hooks"  
            Es una colección de funciones expuestas por React para que puedas en componentes funcionales y demás, una de ellas es useState.

            Cambia el componente app por uno funcional o sea, 
                const app = props => {
                    useState({
                        mete el array de persons
                    });

                    return() { JSX } 
                }

            Este es un componente funcional normal, pero ahora puede usar la función de "react hooks" o una de las funciones de React.
            --> Para eso hay que importarlo:  import React, { useState } from 'react' (React ya lo teníamos, solo agregamos { useState })

            UseState:
                Devuelve una matriz con exactamente dos elementos y siempre dos elementos que son importantes.

                    // Usamos destructuración [ param1, param 2] , lo que hace que useState ponga la info en donde corresponda.
                    const [ currentState, updateCurrentState ] = useState({});

                    1) Ahora el primer elemento que recibimos siempre será nuestro estado actual.
                    2) El segundo elemento en la matriz de estado siempre será una función que nos permita actualice este estado para que react lo sepa y volverá a procesar este componente
                        IMPORTANTE: La 2da función no mergea los cambios, pisa el objeto con el nuevo estado.

                    3) Si estabamos usando this.state ahora debemos cambiarlo por currentState 
                    
    45. Stateless vs Stateful
        
        Functional (Stateless) vs class (Stateful) Components
        La mayoria de las veces vamos a usar funciones stateless, las que reciben props.
        
        La mayor parte de la app, no debería cambiar el estado de la aplicación, se supone que solo va a cambiar en ciertos componentes,
            conocidos como "contenedores" Statefull Components. ej app.js
        
    46. Passing Method References Between Components
        base-syntax--02-state-events.zip

        en el padre, al hijo embebido, le generamos un atributo donde le podemos pasar un metodo, entonces en el archivo del hijo, usando prop podemos utilizarlo.

        o sea, el hijo termina usando un metodo que esta en el padre.

        Si necesitamos pasar parametros hay que usar bind.
        
        this.metodo.bind(this, param)
        
        si en vez de usar esa manera, usamos una funcion de flecha anonima, tenemos que tener en cuenta que cuando escribimos la función en una linea:
            onClick={() => this.metodo()}

            adelante del this, si bien no lo pone, hay un RETURN.

        Idealmente es mejor usar bind, porque la función anonima es ineficiente.

    47. Adding Two Way Binding

        En el padre, generamos el metodo que va a cambiar el estado, por parametro le pasamos un event.

        dentro del elemento hijo, agregamos un parametro onChange, para pasarle a ese componente ese metodo, y usamos props.change (que es el atributo donde pusimos el metodo.)

        IMPORTANTE: Si usamos un input siempre le tenemos que poner un onChange o readonly

    48. Adding Styling with Stylesheets

        hay que poner un archivo .css en la misma carpeta que el componente e importarlo en el componente.js 

    49. Working with Inline Styles
        
        Para usar inline styles, se usa javascript en camelCase, ej lo que en css es background-color, aca es backgroundColor o marginLeft, etc.. en el JSX se usa 
        
        Dentro de render () 
        const style = {
            backgroundColor: color,
        }

        <a style={style}></a>
        
        Tarea 1: Time to Practice - The Base Syntax

    50. [OPTIONAL] Assignment Solution

        base-syntax--01-props-custom-cmp.zip
        base-syntax--02-state-events.zip
        base-syntax--03-finished.zip
        base-syntax--assignment-solution.zip

        Solución de la tarea.

    51. Useful Resources & Links

        create-react-app: https://github.com/facebookincubator/create-react-app
        Introducing JSX: https://reactjs.org/docs/introducing-jsx.html
        Rendering Elements: https://reactjs.org/docs/rendering-elements.html
        Components & Props: https://reactjs.org/docs/components-and-props.html
        Listenable Events: https://reactjs.org/docs/events.html
        Recursos de esta clase
        base-syntax--01-props-custom-cmp.zip
        base-syntax--02-state-events.zip
        base-syntax--03-finished.zip
        base-syntax--assignment-solution.zip

###  Sección 4: Working with Lists and Conditionals

    52. Module Introduction
    53. Rendering Content Conditionally

        envolver un elemento con { para poder escribir javascript }
        por ejemplo para mostrar o dejar de mostrar un div.

        IMPORTANTE: Hay que usar el operador ternario

        Dentro de JSX no se puede poner el if comun.

        ej:
        { this.showParrafo === true ?
            <p>hola</p>
        :
        null 
        }

        significa que o muestro o el parrafo o no muestro (renderizo nada)

    54. Handling Dynamic Content "The JavaScript Way"

        Dentro de render, antes de retornar algo, podemos poner variables javascript, ya que ahí podemos usar js normalmente.

        ej:

        render (){
            let person = null;

            if(this.person == null) {
                person = ( // esto es como crear un elemento 
                    metemos el html aca que queremos ocultar o no
                );
            }

            return (
                html..
                {person} // person es la variable null o la variable donde guardamos el html a renderizar.
            )
        }

    55. Outputting Lists (Intro)

        Explica que las listas asi hardcodeadas como estan se romperían si se elimina un elemento. Y que se soluciona con lo que se va a seguir en el curso (re al pedo este modulo.)

    56. Outputting Lists

        
        .map mapea elementos en un array dado (en este caso "elArray"), ejecuta un metodo en cada elemento del array
            el metodo/funcion, es pasado a mapa dentor de los ().
            - .map retorna un nuevo array, react lo que intenta hacer al retornarlo es renderizarlo otra vez en el DOM (si es un JSX valido)

        esa función que se le pasa a map, se ejecuta en cada elemento del array.
        map tiene un segundo parametro que es el index del elemento.

        {this.state.elArray.map(elementoDelArray => {
            return <Person name="person.name" age="person.age" />;                                    // Lo que quiero mapear dentro de cada elemento.
        })}

        * El elemento key en este ejemplo falta, esta en el 58 y se tiene que poner para que funcione todo correctamente, explicación ahí.

    57. Lists & State
        deletePersonHandler = (personIndex) => {
            
            const persons = this.state.persons; // Me guardo el array de personas.
            persons.splice(personIndex, 1); // Splice, sirve para eliminar elementos del array, acá le decimos que elimine 1 solo, y un index en particular.
            this.setState({persons: persons})

        }
        
        {this.state.elArray.map( ( elementoDelArray, index ) => {
            return <Person click={this.deletePersonHandler} name="person.name" age="person.age" />;                                   
        })}

        Supuestamente esto tiene una falla, en el proximo  modulo se va a demostrar esto.

    58. Updating State Immutably

        Lo que se hizo antes es una mala practica. Ya que esta apuntando al state original, y si ese se modifica, también explotaría acá.
        Lo que hay que hacer primero es una copia del array, utilizando slice.

        slice() sin argumentos copia el array completo y retorna uno nuevo en la variable, entonces ahora si no habría ningún problema.

            const persons = this.state.persons.slice();

        Hay una alternativa (equivalente) a esto, que es usar el operador spread: ... / Si son tres puntos.
        Spread: ... despliega los elementos del array en una lista de elementos, que se agrega a esa matriz, de modo que ahora tenemos una matriz,
            nueva matriz con los objetos viejos de la matriz vieja, pero no la matriz vieja en si misma.   
            
            const persons = [...this.state.persons] 

        Por ende:
            1) Crear una copia
            2) Actualizar esa
            3) updatear el state

    59. Lists & Keys

        React exige escribir el elemento key, ya que esto le deja comparar el dom virtual con el dom real, y de esta manera identifica
            que elemento cambió y debe actualizar y no así toda la lista.
            se tiene que poner el id de los elementos.

            {this.state.elArray.map( ( elementoDelArray, index ) => {
                return <Person click={this.deletePersonHandler} name="person.name" age="person.age" key="person.id" />;                                   
            })}

    60. Flexible Lists

        1) Le agrega id al array de persons, apenas lo setea 
        2) modifica el elemento Person para que tenga el evento change, pasandole el evento y el id:

            {this.state.elArray.map( ( elementoDelArray, index ) => {
                return <Person 
                            click={this.deletePersonHandler} 
                            name="person.name" 
                            age="person.age" 
                            key="person.id"
                            change="{(event) => { this.nameChangeHandler(event, person.id)}} // A la función anonima hay que pasarle el param event, para que después se lo pueda pasar a la función nameChangeHandler

                            />;                                   
            })}

        3) Actualiza la función nameChangeHandler, para que seactualice el elemento especifico.

            nameChangeHandler = (event, id) => {
                
                // Obtenemos el index del elemento en la matriz, findIndex retorna true o false si no lo encontró.
                const personIndex = this.state.persons.findIndex(p => {
                    return p.id === id;
                });

                // Creamos un nuevo objeto para poder quedarnos con el que queremos una vez que lo encontramos.
                const person = {
                    ...this.state.persons[personIndex]
                }
                
                // Otra manera de hacerlo sería:
                // Pasamos un objeto vacio, y como 2do param, el objeto que queremos asignarle.
                // const person = Object.assign({}, this.state.persons[person]); 

                // Ya conseguí la copia (no el objeto original)
                person.name = event.target.name;

                // Pongo los elementos viejos del state en uno nuevo, y actualizo el array con la nueva persona a la que actualizamos el nombre anteriormente.
                const persons = [...this.state.persons];
                persons[personIndex] = person;

                // Finalmente actualizamos el estado con el nuevo array actualizado.
                this.setState({ persons: persons)}
            

            // findIndex como map, recorre cada elemento y busca el index que le pasamos.

    61. Wrap Up
        Tarea 2: Time to Practice - Lists & Conditionals

    62. [OPTIONAL] Assignment Solution
    63. Useful Resources & Links

        Conditional Rendering: https://reactjs.org/docs/conditional-rendering.html
        Lists & Keys: https://reactjs.org/docs/lists-and-keys.html

        Recursos de esta clase
            lists-conditionals--01-conditional-content.zip
            lists-conditionals--lists-finished.zip
            lists-conditionals--assignment-solution.zip

###  Sección 5: Styling React - Components & Elements

    64. Module Introduction
    65. Outlining the Problem Set
    66. Setting Styles Dynamically

        render () {
            // Agrega esto
            const style = {
                backgroundColor: 'green',
                color: 'white',
                font: 'inherit',
                border: '1px solid blue',
                padding: '8px',
                cursor: 'pointer'
            }

            let persons = null;

            if ( this.state.showPersons ) {
            persons = (
                <div>
                {this.state.persons.map((person, index) => {
                    return <Person
                    click={() => this.deletePersonHandler(index)}
                    name={person.name} 
                    age={person.age}
                    key={person.id}
                    changed={(event) => this.nameChangedHandler(event, person.id)} />
                })}
                </div>
            );

            style.backgroundColor = 'red'; // Agrega esto
        }

    67. Setting Class Names Dynamically

        // Agrega las clases:

        App.css 
            .red {
                color: red;
            }

            .bold {
                font-weight: bold;
            }
        
        App.js
            // Esto usa las clases que declaramos y las une con un espacio en el medio.
            let classes = ['red','bold'].join(' ');

            return (
                <div className="App">
                    <h1>Hi, I'm a React App</h1>
                    <p className={classes}>This is really working!</p>

    68. Adding and Using Radium
        
        // Sirve para poder usar, inline styles, pseudo selectores y media queries:
            Para extender el alcance de un componente o cambiarlo dinamicamente.

        1) > npm install --save Radium
        2) import Radium from 'radium'; 
        3) export default Radium(App); // Higher order component, se puede usar en todo tipo de componentes.

        const style = {
        backgroundColor: 'green',
        color: 'white',
        font: 'inherit',
        border: '1px solid blue',
        padding: '8px',
        cursor: 'pointer',
        ':hover': {
            backgroundColor: 'yellow',
            color: 'black'
        }
        };

        style.backgroundColor = 'red';
        style[':hover'] = {
            backgroundColor: 'brown',
            color: 'black'
        };

        IMPORTANTE: Todo esto es porque si bien podemos poner el codigo en el css, no va a aplicar solo al componente que queremos sino a todos los componentes.

    69. Using Radium for Media Queries

        // Actualemente no es necesario importar ni usar usar: </StyleRoot>
            no hay errores.
        Person.js
        const style = {
            '@media (min-width: 580px': {
                
            }
        };
# TODO: Actualizar esta sección a partir de acá:
    70. MUST READ: Enabling CSS Modules

        // Para habilitar CSS Modules:
        1) commitear los cambios que puedas tener
        2) npm run eject
        3) Vamos a ver nuevas carpetas: 
            /config -->
            /scripts --> Tiene un script por cada comando en scripts a ejecutar 

        4) Modificar el archivo en config/webpack.config.js 

        test: cssRegex,
                exclude: cssModuleRegex,
                use: getStyleLoaders({
                    importLoaders: 1,
                    modules: true,
                    localIdentName: '[name]__[local]__[hash:base64:5]',
                    sourceMap: isEnvProduction && shouldUseSourceMap,
                }),

            debería modificarse también en el de prod, pero no lo tengo.. igual que otros archivos que el tiene y yo no.
        5) Modificamos el import del css: import clases from './App.css' 
            las clases que tenemos en el archivo pasan a ser propiedades :O
        6) Cambiamos 
            <div className="App">
            por:
            <div className={clases.App}>

            Transforma la info que esta en la clase en unica.
        7) Si revisamos el html vemos que tiene un nombre de clase super extraño :D

    71. Enabling & Using CSS Modules

        // Para habilitar CSS Modules:
        1) commitear los cambios que puedas tener
        2) npm run eject
        3) Vamos a ver nuevas carpetas: 
            /config -->
            /scripts --> Tiene un script por cada comando en scripts a ejecutar 

        4) Modificar el archivo en config/webpack.config.js 

        test: cssRegex,
                exclude: cssModuleRegex,
                use: getStyleLoaders({
                    importLoaders: 1,
                    modules: true,
                    localIdentName: '[name]__[local]__[hash:base64:5]',
                    sourceMap: isEnvProduction && shouldUseSourceMap,
                }),

            debería modificarse también en el de prod, pero no lo tengo.. igual que otros archivos que el tiene y yo no.
        5) Modificamos el import del css: import clases from './App.css' 
            las clases que tenemos en el archivo pasan a ser propiedades :O
        6) Cambiamos 
            <div className="App">
            por:
            <div className={clases.App}>

            Transforma la info que esta en la clase en unica.
        7) Si revisamos el html vemos que tiene un nombre de clase super extraño :D

    72. More on CSS Modules

        CSS Modules are a relatively new concept (you can dive super-deep into them here: https://github.com/css-modules/css-modules). With CSS modules, you can write normal CSS code and make sure, that it only applies to a given component.

        It's not using magic for that, instead it'll simply automatically generate unique CSS class names for you. And by importing a JS object and assigning classes from there, you use these dynamically generated, unique names. So the imported JS object simply exposes some properties which hold the generated CSS class names as values.

        Example:

        In Post.css File

        .Post {
            color: red;
        }
        In Post Component File

        import classes from './Post.css';
        
        const post = () => (
            <div className={classes.Post}>...</div>
        );
        Here, classes.Post  refers to an automatically generated Post  property on the imported classes  object. That property will in the end simply hold a value like Post__Post__ah5_1 .

        So your .Post  class was automatically transformed to a different class (Post__Post__ah5_1 ) which is unique across the application. You also can't use it accidentally in other components because you don't know the generated string! You can only access it through the classes  object. And if you import the CSS file (in the same way) in another component, the classes  object there will hold a Post  property which yields a different (!) CSS class name. Hence it's scoped to a given component.

        By the way, if you somehow also want to define a global (i.e. un-transformed) CSS class in such a .css  file, you can prefix the selector with :global .

        Example:

        :global .Post { ... } 

        Now you can use className="Post"  anywhere in your app and receive that styling.
        
    73. Adding Pseudo Selectors

        Elimina todo el css que andaba por los archivos. Lo voy a eliminar cualquier cosa ver commit "elime css por curso 72"

        .App button {
            border: 1px solid blue;
            padding: 16px;
            background-color : green;
            font: inherit;
        }

        Sigue funcionando todo porque:
        <div className={classes.App}>
            <button
        </div


        btnClass = classes.Red;
        <button
            className={btnClass}

    74. Working with Media Queries

        Person.css
        @media (min-width: 500px) {
            .Person {
                width: 450px;
            }
        }

        no se que pasa que no funciona.

    75. Useful Resources & Links

        Useful Resources & Links
        Using CSS Modules in create-react-app Projects: https://medium.com/nulogy/how-to-use-css-modules-with-create-react-app-9e44bec2b5c2
        More information about CSS Modules: https://github.com/css-modules/css-modules
        Recursos de esta clase
        styling--01-radium.zip
        styling--02-css-modules-finished.zip

###  Sección 6: Debugging React Apps

    75. Module Introduction
    76. Understanding Error Messages

        Como ver en la consola el error y en que linea esta.

    77. Finding Logical Errors by using DevTools & Sourcemaps

        Enseña como poner un debug en la consola de chrome.

    78. Working with the React Developer Tools

        Instala la extensión de chrome, muestra la solapa React en la consola de Chrome.

    79. Using Error Boundaries (React 16+)

        throw new Error("hubo un error");
        
        IMPORTANTE: key, siempre tiene que estar en el elemento "padre";

        Crea un componente ErrorBoundary

        import React, { Component } from 'react;
        class ErrorBoundary extends Component{
            state = {
                hasError: false,
                errorMessage:
            }

            componentDidCatch = (error, info ) => {
                this.setState({hasError: true, errorMessage: error});
            }

            render () {
                if(this.state.hasError){
                    return <h1>{this.state.errorMessage}</h1>;
                }else{
                    return.this.props.children;
                }
            }
        }

        export default ErrorBoundary;

        IMPORTANTE: hay que usar este componente para envolver algo que tenga realmente sentido.
                    en development el error es sobreescrito por lo que informa React, no así en prod.

    80. Wrap Up
    81. Useful Resources & Links

        Error Boundaries: https://reactjs.org/docs/error-boundaries.html
        Chrome Devtool Debugging: https://developers.google.com/web/tools/chrome-devtools/javascript/
        Recursos de esta clase
        debugging--01-finished.zip

###  Sección 7: Diving Deeper into Components & React Internals

        82. Module Introduction
        83. A Better Project Structure

            Los componentes a generar deben tener sentido. Por ej si queremos tener algo generico como un input que se use en varias partes, ahí si valdría la pena hacer un solo componente por eso.
            Los componentes que manejan estados, no deberían comprometerse mucho con la renderización de otros, o sea no tener mucho JSX.

            En src, genera:
                /components  --> cada componente
                /assets      --> imagenes y css
                /containers  --> los componentes principales (como App)

        84. Splitting an App Into Components

            // Si hacemos esto, no es necesario poner el return, gracias a ES6
            const persons = (props) => (
                Podemos poner JSX
            );

            Lo que no entiendo es que al final le saco los parentesis y puso javascript de una.
                Al parecer cuando no retorn JSX, estás retornando una función normal.
                es por eso que o usas => ( y lo que queremos renderizar) o => () {}

            Resumen: Hay que tener containers donde se manejen estados y el resto deberían ser funcional components donde 
                    solamente se pasen props.

        85. Comparing Stateless and Stateful Components

            Presentational component (stateless components) = functional component que no maneja estados

        86. Class-based vs Functional Components

                A los containers se les puede pasar props desde index.js al renderizarlos.

        87. class Component Lifecycle Overview

            - Solo esta disponible en class Component.
            - Hay un monton de metodo, que react corre por nosotross, ej:
            contructor(), getDerivedStateFromProps()...

            IMPORTANTE: no realizar "side effects" en el construtor, como:
                http request, store aglo en la base. Usar solo para inicializar variables.

        Ejemplos de llamados de metodos en orden:
            1) constructor
            2) getDerivedStateFromProps
                Cuando las props cambien para la clase. Idem constructor, no side effects acá.
            3) render
                prepara y estructura tu jsx para retornarlo.
            4) Child components:
                Se renderizan estos components.
            5) ComponentDidMount()
                Acá se pueden generar "side effects"
                NO ACTUALIZAR EL ESTADO ACA. Salvo que se cumpla una promesa sobre un llamado http.

        88. Component Creation Lifecycle in Action

            mediante console log, muestra como se van ejecutando en orden las cosas.

        89. Component Update Lifecycle (for props Changes)

            1) getDerivedStateFromProps
            2) 
            
            TODO:

        90. Component Update Lifecycle (for state Changes)

            lo pase.

        91. Using useEffect() in Functional Components

            import React, { useEffect } import 'react'

            Toma una función que corre en cada ciclo de renderizado.
            useEffect(() => {

            })

            useEffect combina dos :
            componentDidMount y componentDidUpdate.

        92. Controlling the useEffect() Behavior

            1) Que haga algo solo la primera vez. Se pone un array vacio [] y corre una sola vez y nunca mas.
                useEffect(() => {

                },[])
            
            2) cuando se actualiza un estado.
                Lo que hay que hacer sería lo siguiente:

                useEffect(() => {

                },[props.persons])

            IMPORTANTE: En el caso de necesitar lo mismo para otra prop, hay que volver a escribir useEffect y pasarle esa prop.

        93. Cleaning up with Lifecycle Hooks & useEffect()

            componentWillUnmount, se ejecuta cuando se remueve el componente, en el caso del toggle persons por ej cuando haces clic otra vez para ocultarlo.

            Dentro del mismo useEffect, se puede retornar algo mediante una función anonima, para limpiar algo.

        94. Cleanup Work with useEffect() - Example
        95. Using shouldComponentUpdate for Optimization

            shouldComponentUpdate -> se renderizan todos los componentes, pero lo podemos modificar para que se renderice solo el que se actualizó:

            shouldComponentUpdate(nextProps, nextState){
                if(nextProps.persons !== this.props.persons){
                    return true;
                }else{
                    return false;
                }

                return true;
            }

            IMPORTANTE: Para ver que se refresca en la pantalla > F12 > clic en los 3 puntos > More Tools > Rendering > chequear la opción Paint Flashing
                        Ojo porque a veces parece que refresca la pantalla, pero en realidad esta refrescando el dom virtual.
            
        96. Optimizing Functional Components with React.memo()

            En cockppit por ejemplo, al exportar el componente, utilizaríamos memo.
            Lo que hace es tomar un snapshot del componente y lo re-renderiza, si y solo si, el input cambia.

            export default React.memo(cockpit);

            El problema es que en cockpit, hay una propiedad que cambia siempre que es persons, por ende hay que hacer un mini fix en la manera de pasarselo en App.
                le pasamos solo el lenght de cockpit, en vez de que lo resuelva el adentro.

        97. When should you optimize?
        98. PureComponents instead of shouldComponentUpdate
            
            Si queremos chequear si alguna de todas las propiedades cambió, no nos conviene usar shouldComponentUpdate.
            Para eso tenemos que extender de otro componente:

            import React, { PureComponent } from 'react'

            PureComponent, ya implementa shouldComponentUpdate con un completo chequeo de todas las props.

        99. How React Updates the DOM

            render() --> No actualiza inmediatamente al DOM real. Aplica a todo tipo de componentes. 
                        Este puede llegar a dar el mismo resultado que antes, es por eso que se usa shouldComponentUpdate, para manejar que es lo que realmente se debería renderizar.

                        Lo que hace es compara el viejo DOM con el nuevo DOM (virtuals)
                            Hace esto porque es mas rapido que el DOM real.

                        DOM Virtual, es una representación del DOM en Javascript.
                        El future DOM, es el que se crea cuando render es llamado, recordemos que render no llama inmediatamente al DOM real sin antes comparar (el viejo con el futuro para ver si hay diferencias.)
                        Una vez que termina llama al DOM real y lo actualiza, y no lo re-renderiza por completo, solo lo que fue detectado para updetear.

                        Si no encuentra diferencias, se ejecuta render y ahí es donde shouldComponentUpdate debería prevenir que llame al dom real, si realmente nada cambio.
                        
        100. Rendering Adjacent JSX Elements

            En vez de envolver los elementos en un div, podemos usar:

                return [
                    <h1></h1>,
                    <p></p>
                ]

                El tema es que hay que generar una key, para cada elemento, si no tenes que generar identificadores unico igual.

            Otra manera de hacer esto es:
            
                Crear una carpeta hoc (High order component)
                Después hay que crear un archivo Aux.js (mac) Auxiliary.js (Windows) 

                import React from 'react';

                const aux = props => props.children;

                export default aux;

                IMPORTANTE: Children es una propiedad especial, que lo que sea que entre, lo pone entre tags cerrados.

        101. Windows Users Must Read

            On Windows, the Aux.js  filename is not allowed in ZIP archives. Hence when extracting the attached source code, you might get prompted to rename the Aux.js  file. You might also face difficulties creating an Aux folder and Aux.js file.

            I really apologize for that inconvenience, Windows is really doing an amazing job here ;-).

            Follow these fixes:

            1) Problems when unzipping the attached file:
            Simply skip this step (e.g. by pressing "No") and ignore the upcoming error message.

            In the extracted folder, you'll then find all source files EXCEPT for the Aux.js  file. In later course modules (where we work on the course project), the Aux.js  file can be found in an Aux/  subfolder inside hoc/ .

            Make sure to take the Aux.js  file attached to this lecture and place it inside the hoc/  or hoc/Aux/  folder (which ever of the two you got).

            2) Problems with the creation of an Aux folder and/ or file:
            Simply name both differently. For example, you may create an Auxiliary  folder and name the file inside of it Auxiliary.js . Make sure to then adjust your imports (import Aux from './path/to/Auxiliary/Auxiliary' ) and you should be fine.



            Recursos de esta clase
            Aux.js
            Auxiliary.js

        102. Using React.Fragment

            En vez de usar Aux, se puede usar <React.Fragment> si no queremos usarlo así (separado por el punto, hay que importar Fragment)
            import React, { Fragment} from 'react' 

            Hace lo mismo que Aux.

        103. Higher Order Components (HOC) - Introduction
            
            Se llama así porque contiene un componente, no hace nada.

            También puede haber componentes HOC:
                Puede ser por ej el div con className App.

            Otro ejemplo:
                Crea el archivo /hoc/WithClass.js

                import React from 'react';

                const withClass = props => {
                    <div className={props.classes}>
                        {props.children}
                    </div>
                };

                export default withClass;

            CONVENCIÓN: Los archivos de hoc, tienen que tener With adelante.
            
            Cambia el div de app por este withClass y le pasa classes por props.

        104. Another Form of HOCs

            Existe otra manera de crear las clases tipo withClass.
            
            Devolver una función comun de Javascript.
            1) parametro que debe arrancar con mayuscula
            2) algo que necesitemos en el componente hoc.
            3) Puede tener n parametros (obvio los que necesitas nada mas.)

            const withClass = (WrappedComponent, className) => {
                // Retorno un componente funcional.
                return props => (
                    <div className={className}>
                    <WrappedComponent></WrappedComponent>
                    </div>
                );
            };
            
            4) Usamos el componente Aux en App y cambiamos el nombre del js a tener w minuscula, porque ahora estamos devolviendo una función no un componente.
            5) modificamos el export de App:
                export default withClass(App, classes.App);

                Esto se usa dependiendo de que necesitemos.

        105. Passing Unknown Props

            Si lo hacemos en el componente de Person no tenemos prop, entonces hay qu tocar la función, para que dentro delc omponente, haga un spread de props, así después los demas componentes que la quieren usar no tienen ningun problema.

        106. Setting State Correctly

            Esto que muestra es solo para clases basadas en componentes.

            Hay que actualizar el estado así:
                this.setState((prevState, props) => {
                    return {
                        persons: persons,
                        changeCounter: prevState.changeCounter + 1;
                    }
                })

            NO ASÍ:
                this.setState({
                    persons: persons,
                    changeCounter: this.state.changeCounter + 1;
                })

            Porque cuando se usa de la ultima forma, React no te garantiza que ese sea realmente el último estado.

        107. Using PropTypes

            No necesariamente son necesarias, pero cuando trabaja en un equipo grande o que queres distribuir lo que estás haciendo, evitas que la gente pase mal las propiedades.

            Hay que:
            
                1) Instalar prop-types
                    > npm install --save prop-types
                2) Importarlo: 
                    import PropTypes from 'prop-types';
                3) Agregar antes del export:
                    
                    NOTA: va con minuscula acá:

                    Person.propTypes = {
                        click: PropTypes.func,
                        name: PropTypes.string,
                        age: PropTypes.number
                    }
            
            IMPORTANTE: 
                - Funciona en cualquier tipo de componente.
                - Te avisa si estas pasando una propiedad incorrecta EN DEVELOPMENT MODE.
                - Podes usarlo en el componente que creas necesario.

        108. Using Refs

            Solo funciona en componentes basados en clases.
            Ejemplo para ponerle el foco en el ultimo elemento de una lista de 3 elementos input:
            
            ref:
                es una key especial, que le podes pasar a cualquier componente.
                Se puede usar de varias maneras, una es esta:

                    Lo usas con una función anonima en la que obtenes tenes la referencia, de donde pongas ref.
                    y le pones el nombre que quieras, por ej inputEl, 
                    en el cuerpo de la función podes asignar ese elemento a una nueva propiedad de clase 

                    ComponentDidMount() {
                        this.inputElement.focus();
                    }

                    <input 
                        ref={ ( inputEl ) => { this.inputElement = inputEl }}
                    />
                
                Otra es:
                    constructor() {
                        super(props);
                        this.inputElementRef = react.createRef();
                    }

                    ComponentDidMount() {
                        this.inputElementRef.current.focus();
                    }

                    <input 
                        ref={ this.inputElementRef }
                    />

        109. Refs with React Hooks

            Como usar algo parecido a Refs, con React Hooks en functional components.

            import React, { useRef } from 'react'
            const toggleBtnRef = React.createRef(null);

            y hay que usar dentro de useEffect: toggleBtnRef.current.click()

        110. Understanding Prop Chain Problems

            Hace un ejemplo donde pasa una propiedad por varios componentes y que si tenes un componente que es reutilizable vas a tener que estar haciendo cosas demas para poder usarlo solo por eso,
            explica que esto lo resuelve

        111. Using the Context API

            Agrega una nueva carpeta /context y después un archivo aux-context.js
            import React from 'react';

            const authContext = React.createContext({
                authenticated: false,
                login: () => {}
            });

            App.js
                Lo importamos.
                Envolvemos los componentes que queremos con el componente que creamos:
                    // value, se setea cuando vos no seteas ningun otro valor.
                    <AuthContext.Provider value={authenticated: this.state.authenticated, login: this.loginHandler  } >

            Persons.js
                Como acá lo queremos consumir, tenemos que, después del return, poner:
                <AuthContext.Consumer>
                {context => <button onClick...}
                </ AuthContext.Consumer>

            IMPORTANTE: lo que se cambie en ese contexto, no va a generar una re-renderización.

            export default authContext;

        112. contextType & useContext()

            
            COMPONENTES BASADOS EN CLASES:

                Como en ComponentDidMount, puede que tengas que hacer un llamado HTTP y necesites el context y ahí no se puede obtener la info como la aprendimos.
                A partir de react 16.6 hay una variable estatica contextType.

                static contextType = authContext;

                Esto habilita a que detrás de escena, el metodo ComponentDidMount, se comunique con la variable estatica, ya que ahora tenes dentro del metodo:
                this.context.login por ej.
                this.context.authenticated
                También podemos modificar el elemento AuthContext.Consumer por this.context.authenticated

            FUNCTIONAL COMPONENTS
                import AuthContext from 'context/aut-context';
                import React, {useContext} from 'react'

                const authContext = useContext(AuthContext);

                authContext.authenticated

                en coockpit, cambias el elemento por esto y listo. 

        113. Wrap Up

        114. Useful Resources & Links

            More on useEffect(): https://reactjs.org/docs/hooks-effect.html

            State & Lifecycle: https://reactjs.org/docs/state-and-lifecycle.html

            PropTypes: https://reactjs.org/docs/typechecking-with-proptypes.html

            Higher Order Components: https://reactjs.org/docs/higher-order-components.html

            Refs: https://reactjs.org/docs/refs-and-the-dom.html

            Recursos de esta clase
            cmp-deep-dive-01-creation-lifecycle.zip
            cmp-deep-dive-02-updating-lifecycle-props.zip
            cmp-deep-dive-03-updating-lifecycle-state.zip
            cmp-deep-dive-04-finished-useeffect.zip
            cmp-deep-dive-05-shouldcomponentupdate-memo.zip
            cmp-deep-dive-06-aux.zip
            cmp-deep-dive-07-withclass.zip
            cmp-deep-dive-08-finished-hocs.zip
            cmp-deep-dive-09-updating-state.zip
            cmp-deep-dive-10-proptypes.zip
            cmp-deep-dive-11-refs.zip
            cmp-deep-dive-12-finished.zip

        115. MUST READ: Legacy Lectures
            DON'T SKIP THIS!

            ---

            With React 16.8, a new feature called "React Hooks" was introduced. This course already covers this feature and this module, up to this point, is 100% up-to-date with that feature (e.g. you learned about useEffect()).

            The upcoming lectures marked as "[LEGACY]" are only there to allow existing students who started this module before the update (on February 6th) to continue smoothly.

            You can skip all remaining lectures in this module (i.e. the lectures with "[LEGACY]") if you watched all the other lectures prior to this one.

            116. [LEGACY] Splitting an App Into Components
            117. [LEGACY] Comparing Stateless and Stateful Components
            118. [LEGACY] Understanding the Component Lifecycle
            119. [LEGACY] Converting Stateless to Stateful Components
            120. [LEGACY] Component Creation Lifecycle in Action
            121. [LEGACY] componentWillUnmount()
            122. [LEGACY] Component Updating Lifecycle Hooks
            123. [LEGACY] Component Updating Lifecycle in Action
            124. [LEGACY] Updating Lifecycle Hooks (Triggered by State Changes)
            125. [LEGACY] Performance Gains with PureComponents
            126. [LEGACY] How React Updates the App & Component Tree
            127. [LEGACY] Understanding React's DOM Updating Strategy
            128. [LEGACY] Windows Users Must Read - File Downloads
            129. [LEGACY] Returning Adjacent Elements (React 16+)
            130. [LEGACY] React 16.2 Feature: Fragments
            131. [LEGACY] Understanding Higher Order Components (HOCs)
            132. [LEGACY] A Different Approach to HOCs
            133. [LEGACY] Passing Unknown Props
            134. [LEGACY] Using setState Correctly
            135. [LEGACY] Validating Props
            136. [LEGACY] Available PropTypes
            137. [LEGACY] Using References ("ref")
            138. [LEGACY] More on the React ref API (16.3)
            139. [LEGACY] The Context API (React
            140. [LEGACY] More on the Context API (16.6)
            141. [LEGACY] Updated Lifecycle Hooks (React 16.3)
            142. [LEGACY] The "memo" Method (16.4)
            143. [LEGACY] Wrap Up
            144. [LEGACY] Useful Resources &

        TODO: Falta toda la info de la parte LEGACY

###  Sección 8: A Real App: The Burger Builder (Basic Version)

    145. About React Hooks

        As mentioned before, we'll build the course project without React Hooks for now (React Hooks are a new feature, introduced with React 16.8, I'll introduce them in-depth later).
        Towards the end of the course, we'll have an entire module where we convert it to use React Hooks though (after having yet another Hooks deep-dive module of course).

    146. Module Introduction
    147. Planning an App in React - Core Steps

        Como planear una applicación React: Pasos Core

        1) Estructura (planificar el árlbol de componentes)
        2) Estado (State)
        3) Componentes vs Contenedores (cuales tienen que mantener el estado y cuales no)
            Es normal que a veces cambiemos sobre la marcha, porque nos damos cuenta que es mejor otra cosa..

    148. Planning our App - Layout and Component Tree

        Modela como va a ser la pagina, y los componentes que va a necesitar.

    149. Planning the State

        Identificar donde necesitamos state, va a ayudar a saber que va a ser un componente o no

        State
            -Ingredients
                -carne
                -queso
            -comprado: true/false
            -totalPrice: 0
            ...
    152. MUST READ: Enabling CSS Modules

        MUST READ (at least the first few paragraphs ... ;-))

        In the next lecture, we'll use a styling solution named "CSS modules". We already had a look at that in the "Styling" section earlier in the course.

        In the next lecture, we'll enable CSS modules and depending on the project setup you're using, the exact steps shown there might not work for you.

        At least if you're not using the starting project you also find attached to the next lecture. If you DO use that, you should be able to continue without issues (and you can skip the rest of this text lecture here).

        ***

        In more recent project versions created by CRA, support for CSS modules is already built-in and you can use that feature without ejecting, please see: https://facebook.github.io/create-react-app/docs/adding-a-css-modules-stylesheet

        I also showed this built-in support in the "Styling" section earlier in the course.

        If you use this approach, you DON'T need to eject. But please don't skip the next videos though, I do explain what CSS modules are and why + how we use them there!

        ***

        Optional:

        If you still want to eject and manually adjust the Webpack config (as we do it in the new videos - which you don't need to do if you follow the approach described in the link above), you should take the below comments into account in case your webpack config (after ejecting) doesn't look the same as it does in my videos:

        After ejecting, we edit a Webpack config file that's made available by ejecting. This file might look slightly different for you.

        In the video, I'll look for an entry that starts like this (in the webpack.config.js file):

        {
        test: /\.css$/,
        ...
        }
        and I then edit this entry.

        This entry now looks slightly different. You'll have to find the following part in your webpack.config.js file:

        {
        test: cssRegex,
        exclude: cssModuleRegex,
        ...
        }
        and then edit that entry.

        Finally, it should look like this:

        {
        test: cssRegex,
        exclude: cssModuleRegex,
        use: getStyleLoaders({
            importLoaders: 1,
            modules: true,
            localIdentName: '[name]__[local]__[hash:base64:5]'
        }),
        }
        You can ignore me editing the webpack.config.prod.js file - with the latest version of create-react-app, ejecting only gives you ONE webpack config file (which you edit as described above).
    150. Setting up the Project
        Habilita Csss Modules, que ahora ya esta habilitada desde la nueva versión.
        Agrega el css de una tipografia y nadamas..

    151. Creating a Layout Component
        Crea las carpetas de componentes/contenedores.
        Crea el componente layout y comenta que usa props.children porque de esa manera va a ir mostrando las cosas en pantalla que esten por debajo de ese componente ??¿¿

        crea una carpeta hoc y adentro un componente aux, que va a utilizar para envolver elementos adyacentes.
            const aux = (props) => props.childre;
            export default aux;

    152. Starting Implementation of The Burger Builder Container
        para agregar estilo, se pone el css y después se importa donde se necesita el estilo y con js se agrega, ej:
        
        import classes from './Layout/Layout.css'
        className={classes.laClaseQueHice}

    153. Adding a Dynamic Ingredient Component
        Si queremos tener un poco de logica nuestra función tiene que arrancar con llaves, sino directamente con parentesis.
        
        Arma toda la parte de los ingredientes de la hamburguesa con una clase de css que el tenía.

    154. Adding Prop Type Validation
        npm install --save prop-types 

        sirve para validar lo que le pasamos a las properties sea lo que realmente esperamos.

        Componente.propTypes = {
            type: PropTypes.string,isRequired;
        }

    155. Starting the Burger Component
        Estila Burger.css 

        En el componente BurgerBuilder, agrega el componente Burger.

    156. Outputting Burger Ingredients Dynamically
        Hace toda una función para mostrar pseudo dinamicament los ingredientes de la hamburgeusa (heardcoders), pero recorre todo el objeto.

    157. Calculating the Ingredient Sum Dynamically
        .reduce((previosValue, currentValue) => {
            return previosValue.concat(currentValue)
        }, [])

        hace esto para poder verificar si no hay ingredientes y mostrar un texto para que el usuario empiece a agregarlos.

    158. Adding the Build Control Component
        Agrega un BuildControls y crea un componente BuildControl, lo estila..

    159. Outputting Multiple Build Controls

    160. Connecting State to Build Controls
    161. Removing Ingredients Safely
    162. Displaying and Updating the Burger Price
    163. Adding the Order Button
    164. Creating the Order Summary Modal
    165. Showing & Hiding the Modal (with Animation!)
    166. Implementing the Backdrop Component
    167. Adding a Custom Button Component
    168. Implementing the Button Component
    169. Adding the Price to the Order Summary
    170. Adding a Toolbar
    171. Using a Logo in our Application
    172. Adding Reusable Navigation Items
    173. Creating a Responsive Sidedrawer
    174. Working on Responsive Adjustments
    175. More about Responsive Adjustments
    176. Reusing the Backdrop
    177. Adding a Sidedrawer Toggle Button
    178. Adding a Hamburger Icon
    179. Improving the App - Introduction
    180. Prop Type Validation
    181. Improving Performance
    182. Using Component Lifecycle Methods
    183. Changing the Folder Structure
    184. Wrap Up
    185. Useful Resources & Links

###  Sección 9: Reaching out to the Web (Http / Ajax)

    189. Module Introduction
    190. Understanding Http Requests in React
        explica como funciona cuando un cliente hace un request mediante el navegador y que responde el servidor..

    191. Understanding our Project and Introducing Axios
        Habla de que se puede hacer algo con Javascript, pero ya existen paquetes que hacen todo mas facil, como axios.

        npm install axios --save

    192. Creating a Http Request to GET Data
        simula llamadas a una api, con json placeholder

        axios.get(url)
            .then(response => {
                console.log(response);
            }) // cuando se resuelva la promesa, cae en then.


    193. Rendering Fetched Data to the Screen
        guarda la info que retorna la api en el state, y después con map genera los componentes necesarios dependiendo de cuanta info vino en el repsonse.

    194. Transforming Data
        usa slice para en vez de mostrar todos los elementos del response, mostrar solo los primeros 4.
        Envia por atributos/props la info y arregla el componente para que muestre bien todo.
        

    195. Making a Post Selectable   
        Hace una función y se la pasa al componente que termina renderizando un mensaje o la info que seleccionaste.

    196. Fetching Data on Update (without Creating Infinite Loops)
        Valida que el fetch se haga si y solo si, el id que esta queriendo cargar es difernete al que esta cargado.
        Sino esto genera un loop infinito de requests.

    197. POSTing Data to the Server
        axios.post(url, data)
            .then(response => {
                console.log(response);
            })

    198. Sending a DELETE Request
        axios.delete(url, this.props.id)
            .then(response => {
                console.log(response);
            })

    199. Fixing a Bug
        arregla un temita que no se había dado cuenta, que era que cuando hacia click en un post se mostraba el titulo y no el contendido, nad amas.

    200. Handling Errors Locally
        

    201. Adding Interceptors to Execute Code Globally

    202. Removing Interceptors

    203. Setting a Default Global Configuration for Axios

    204. Creating and Using Axios Instances

    205. Wrap Up

    206. Useful Resources & Links

#### Sección 11: Multi-Page-Feeling in a Single-Page-App: Routing

    217. Module Introduction
    218. Routing and SPAs
        El enrutamiento se trata de poder mostrar difernetes paginas a el usuario.
                        
                        Router Package:
        Parsear url / path -> configurar las rutas ->  renderiza / carga el jsx apropiado / componente

    219. Setting Up Links
        Agrega un nav y los links necesarios.
        
    220. Setting Up the Router Package
        npm install --save react-router react-router-dom

        importamos BrowserRouter y envolvemos el div de app por ej.

        import { BrowserRouter } from 'react-router-dom';
        <BrowserRouter>
        ...
        </BrowserRouter>

    221. react-router vs react-router-dom

        We installed both react-router  and react-router-dom . Technically, only react-router-dom  is required for web development. It wraps react-router  and therefore uses it as a dependency. 

        We don't need to install react-router  on our own for it to work. You can omit this installation step, I left it in there for historic reasons and because I like to emphasize that the main package is named react-router. If you ever search for assistance, you probably want to search for "react router" - that's the name of the package.

    222. Preparing the Project For Routing
        Modifica la estructura, cambiando componentes de lugar Post lo saca de adentro de blog...

    223. Setting Up and Rendering Routes
        En Blog, importa Route de react-router-dom

        render -> se le pasa una función por esta prop, dentro de la función se debe retornar jsx
        exact -> prop booleana que exije que se muestre la ruta que realmente es actualmente

        <Route path="/" render={() => <h1>Home</h1>}>

    224. Rendering Components for Routes
        component tiene que hacer referencia a la función o clase que queremos usar por ej Post dentro de Blog.
        En render no debería renderizarse componentes enteros, porque es dificil de mantener después.

        <Route path="/" component={Post}>

    225. Switching Between Pages
        <Route path="/" component={NewPost}>

        Si bien funciona, al pasar de una pagina a otra se recarga toda la pagina y por lo tanto se pierde el state, en el prox muestra como soucionar esto.

    226. Using Links to Switch Pages
        Comenta que no es correcto usar Route, sino que hay que importar y usar Link

        Para eso modifica en en el nav, los a por el componente link
        React router genera la etiqueta de anclaje y previene el reload, por lo tanto
        to, apate de ser un string, también se le puede pasar una función, un objeto...

        hash -> esto sirve para si hay algún id con submit, directamente vaya a esa pagina.
        search -> nos habilita a pasar parametros por query
        
        <Link to="/"> Home</Link>
        
        Son ejemplos para que sepamos que existen, pero no lo vamos a usar así.
        <Link to={{
            pathname: '/new-post',
            hash: '#submit', 
            search: '?quick-submit=true', 
        }}> New Post</Link>

        Si hacemos click ahora vamos a ver que no se actualiza la pagina entera (se nota en el icono de reload del navegador, que no se mueve esta vez-)

    227. Using Routing-Related Props

    228. The "withRouter" HOC & Route Props
    229. Absolute vs Relative Paths
    230. Absolute vs Relative Paths (Article)
    231. Styling the Active Route
    232. Passing Route Parameters
    233. Extracting Route Parameters
    234. Parsing Query Parameters & the Fragment
    235. Using Switch to Load a Single Route
    236. Navigating Programmatically
    237. Additional Information Regarding Active Links
    238. Understanding Nested Routes
    239. Creating Dynamic Nested Routes
    240. Redirecting Requests
    241. Conditional Redirects
    242. Using the History Prop to Redirect (Replace)
    243. Working with Guards
    244. Handling the 404 Case (Unknown Routes)
    245. Loading Routes Lazily
    246. Lazy Loading with React Suspense (16.6)
    247. Routing and Server Deployment
    Tarea 3: Time to Practice - Routing
    248. Wrap Up
    249. Useful Resources & Links
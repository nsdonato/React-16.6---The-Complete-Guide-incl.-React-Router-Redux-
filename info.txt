…or create a new repository on the command line
    echo "# React-16.6---The-Complete-Guide-incl.-React-Router-Redux-" >> README.md
    git init
    git add README.md
    git commit -m "first commit"
    git remote add origin https://github.com/nsdonato/React-16.6---The-Complete-Guide-incl.-React-Router-Redux-.git
    git push -u origin master
    
…or push an existing repository from the command line
    git remote add origin https://github.com/nsdonato/React-16.6---The-Complete-Guide-incl.-React-Router-Redux-.git
    git push -u origin master

## SECCION 1 ##

1. Introduction
2. What is React?

    Que, como y porque:
        Una libreria de JavaScript para crear interfaces de usuario (Componentes)
        Corre en el navegador.
        Podemos reusar componentes.

3. Real-World SPAs & React Web Apps

    Mas frula sobre componentes, nada interesante.

4. Adding the Right React Version to Codepen

    In the next lecture, we'll write our first React code in Codepen, an online editor (it's only getting used in the next lecture).
    Currently, there seems to be a bug if you add React as shown in the next video.
    To fix it, replace the automatically added import paths (you'll see what I mean) with these:
        https://cdnjs.cloudflare.com/ajax/libs/react/15.6.1/react.min.js 
        https://cdnjs.cloudflare.com/ajax/libs/react/15.6.1/react-dom.min.js 
    This should fix. And don't worry about the React version, the entire rest of the course uses 16+ :)

5. Writing our First React Code
    
    Crear una aplicación en Codepen.
        
        Cuando se repite un elemento pero tiene diferente información adentro, esto ya se puede entender como un componente.

    - Importar React:
        https://cdnjs.cloudflare.com/ajax/libs/react/15.6.1/react.min.js 

    - Importar React DOM, la logica para crear los componentes en el DOM real.
        https://cdnjs.cloudflare.com/ajax/libs/react/15.6.1/react-dom.min.js 

    - Para utilizar las últimas caracteristicas de React --> Babel

    // Tiene que comenzar con mayuscula para que funcione bien.
    function Person(){
        return (
            <div className="person">
                <h1>Max</h1>
                <p>Your Age: 28</p>
            </div>
        );// Sintaxis JSX, para renderizar el DOM.
    }

    ReactDOM.render(<Person />, document.querySelector('#p1')); 

    // el metodo render nos permite representar una función de JavaScript como componente del DOM real, y tratarlo como un componente.
    // le decimos que renderice como html ese objeto Person.
    // le decimos en donde queremos que se vea ese componente.

    * las clases en el codigo html se tienen que escribir className en vez de class. Porque React renderiza ese html como un componente JavaScript (que usa la propiedad className)

    // Le agrega un argumento que es propio de react
    // los datos dinamicos se encierran entre { }
     function Person(props){
        return (
            <div className="person">
                <h1>{props.name}</h1>
                <p>{props.age}</p>
            </div>
        );// Sintaxis JSX, para renderizar el DOM.
    }

    ReactDOM.render(<Person name="Max" age="28"/>, document.querySelector('#p1')); 
    ReactDOM.render(<Person name="Manu" age="29"/>, document.querySelector('#p2')); 

    En vez tener un elemento div con la clase p1, ahora solo vamos a tener uno con id Apps
    HTML:
    <div id="app"></div>

    JS:
     function Person(props){
        return (
            <div className="person">
                <h1>{props.name}</h1>
                <p>{props.age}</p>
            </div>
        );// Sintaxis JSX, para renderizar el DOM.
    }

    var app = (
         <div>
            <Person name="Max" age="28" />
            <Person name="Manu" age="29" />
         </div>
    );

    // En vez de tener dos elementos, tengo uno solo que tenga los 2.
     ReactDOM.render(<app/>, document.querySelector('#app')); 

     * Este es el mejor modo para crear SAP. Single Page Applications.

6. Why should we choose react?

    Porque en aplicaciones grandes es dificil de manejar el ESTADO.
    Aparte si tenes que cambiar los elementos de lugar y puede que tengas que cambiar cosas y estas usando querySelector.
     
    React nos permite enfocarnos en nuestra logica de negocios, envitando que nuestr app explote.
    Supuestamente como React tiene una comunidad zarpada, el codigo es excelente.
    Aparte de tener un gran ecosistema, comunidad activa y alta performance.

7. React alternatives.

    Angular y Vue.js
        Te sirve para enforcarte en la logica y en el modelo de negocio, y no tanto en el aspecto del elemento en particular que querías cambiar (cmo en react)

8. Understanding Single Page Applications and Multi Page Applications.

    SAP:
         Solo recuperamos un solo archivo html, el contenido es renderizado en el cliente.
         Esta construidda por componentes, y cada componente es un componente React, también es mantenida por un componente root de React, que esta bajo el cotnrol de React.
         Tipicalmente tenemos una llamada reactDOM.render(), se necesita una sola porque tenemos un componente raiz, que esta montado en el DOM que tiene todo el resto de componentes.

    MPA:
        Recuperamos varias paginas determinadas, donde cada pagina tiene el contenido para una ruta determinada, y el contenido es renderizado en el servidor.
        Algunas partes de la pagina son componentes React.
        Los widgets individuales no conocen la existencia de otros.
        Vamos a tener varios reactDOM.render para los diferentes componentes, en difernetes lugares de la app.

9. Course outline.

     Getting started.
        Usar JavaScript moderno porque mantiene limpio y es un estandar para react, funciones de flechas y esas cosas.
    
    React basics.
        Como crear componentes reacts, ver las diferentes maneras que hay de hacerlo y como comunicarse entre componentes.
        Como podemos generar listas, o como podemos presentar contenido de forma condicional.

    Debug
        Como debuggear react.

    Styling componentes 
        Como darle estilo a los componentes y como podemos asegurarnos de que el estilo que aplicamos a un componente, solo se aplique a ese componente y no a todos.

    Componentes Deep Dive
        Pronfudización en los componentes, ya que tendremos mucho conocimiento de ellos, vamos a aprender cual es su ciclo de vida.
        Como comprobar actualizaciones a menudo o no.

    HTTP Request
        Como conectarla con el mundo exterior, como obtener datos de un servidor o subirlos al servidor.

    Routing.
        Es una caracteristica del Core de las SAP, porque con routing, podemos manejar diferentes urls, /productos /usuarios  diferentes paginas, aunque tengamos un solo HTML, y en realidad
        lo que hacemos es analizar la url y renderizar las diferentes partes que necesitamos, para mostrar "una nueva pagina".
    
    Forms and validation.
        validación de entrada de datos de los usuarios, etc.

    Redux
        es una biblioteca de terceros pero se usa muchisimo con react.
        acciones asincronas, etc.

    Authentication
        login de usuario.

    Testing
         Introducción a como probar app de react.

    Deployment
        Como publicar en producción

    Bonus: aplicaciones de react animadas, ubicación de reactores, webpack, etc.
        NextJs, una libreria construida bajo react, donde contrustruimos nuestro propio flujo de trabajo, etc.

    
10. How to get the Most out of This Course

    Como sacarle provecho al curso:
        Codificar solo.
        Si algo no funciona, chequear contra su codigo.
        Si estas atascado, usar lar parte donde se hacen las preguntas, primero buscar porque seguro alguien ya pregunto.
        Practicar.

11. Useful Resources & Links

    Documentación de React: https://reactjs.org/
    El codepen, hecho por él: https://codepen.io/anon/pen/MELQaQ


### Sección: 2 - Refreshing Next Generation JavaScript (Optional) ###

12. Module Introduction
    Next-Gen Javascript, para refrescar. React usa esto, así que, hay que saber.

13. Understanding "let" and "const"
    let = var (cambia el tema del scope, porque ahora es de bloque.)
    const = para info que no va a cambiar.

14. Arrow Functions
    antes:
        function myFuncion() {
            ...
        } 

    ahora:
        const myFuncion = () => {
            ...
        }

    * Arrow functions, mejoran el problema de que this, no siempre apuntaba al contexto de ejecución, sino al objeto global.
    * Si no tiene parametros, va solo parentesis
    * Si tiene uno, es param => 
    * Si tiene mas de uno, es (param1,param2) =>
    * Si la parte de retorno solo tiene una linea, se puede escribir así: const multiplicar = number => number * 2;

15. Exports and Imports

    Para codigo modular, para dividir los archivos js en varios archivos.
        Si bien ya se puede (porque agregas diferentes archivos en el html, de manera ordenada)
        Lo que pasa ahora es que desde un js, se puede usar info de otro js.

    EXPORTAR
        person.js
            const person = {
                name: 'Max'
            } 
            export default person

            // export: sirve para exportar esa función, objeto, etc, desde un archivo.
            // default: que esa funcion, obj, etc, va a ser la predeterminada.
            // person: en este caso es el objeto 

        utility.js
            export const clean = () => { ... }
            export const baseData = 10;

    IMPORTAR
        app.js
            // Se pone de alguna de las dos maneras, ya que hace referencia a lo único que se exporto (default)

                import person from './person.js' 
                import prs from './person.js'   

            // Al ser exportada como diferentes constantes, se usa las { }  para "mejorar el codigo", diciendo que se esta exportando algo especifico
            // Tiene que respetar el nombre que se le puso en el archivo donde se la exporta obj
            // se puede ponerle un alias, como en la segunda linea

                import { baseData } from './utility.js' 
                import { baseData as bd } from './utility.js' 

            // También se podría hacer de esta manera.

                import { baseData, clean } from './utility.js' 

    
16. Understanding Classes

    - Los metodos son como: funciones atachados a esa clase/objetos,
    - las propiedades son como: variables, atachadas a esa clase/objetos,

    class Human {
        constructor(){
            this.gender = 'male';
        }

        printGender(){
            consoe.log(this.gender);
        }
    }

    // Herencia
    class Person extends Human{
        constructor(){
            super();
            this.name = 'Max';
            this.gender = 'female'; // pero no es correcto usar así.
        }
        
        printMyname (){
            console.log(this.name);
        }
    }

    // Instanciar un objeto de esa clase.
    const miPersona = new Person();
    miPersona.printMyname();
    miPersona.printGender();    

17. Classes, Properties and Methods

    ES6
        constructor() {
            this.myProperty = 'value'
        }

        miMetodo () {
            ...
        }

    ES7
        myProperty = 'value'; // Si, no hay un "constructor" en si.

        miMetodo = () => {
            ...
        }
        
    * Es mejor usar ambos opciones de ES7, para esto si o si hay que usar ES6/Babel.

18. The Spread & Rest Operator  

    // Operator Spread o Rest (depende de donde se use)
    ...

    Spread: (división de las propiedades de un objeto o un array.)

            Se usa para dividir elementos de un array o propiedades de un objeto.
            Por ejemplo, si tenemos una matriz antigua y queremos agregar todos los elementos de esa matriz anterior a una nueva matriz y,
            además, agregar un 1 en un elemento dos, este primer índice sería lo que tenía tres puntos delante
            de toda la matriz. simplemente extraiga todos los elementos y agregue a la nueva matriz que
            creamos con corchetes.

            // Idem object pero array
                const oldArray = [3,4,5];
                const newArray = [...oldArray,1,2];
                console.log(newArray);
                // 3,4,5,1,2

            // Lo probé, lo que hace es agarrar las propiedades/funciones del objeto viejo, y ponerselo al nuevo y suma la nueva prop/func.
            const oldObject = {
                name: "Noe";
            }

            const newObject = { ...oldObject, newProp: 5 }
            console.log(newO)
    Rest: (Fusión de elementos en un array)
          
          Se utiliza con menos frecuencia.

          Se usa para mergear una lista de argumentos de funciones en una matriz.
          O sea, lo usamos en el parametro de una función. ej:

          // Recibe una lista ilimitada de argumentos, y todos se fusionan en un array.
          // O sea, en vez de dividir, los une.
          function sortArgs(...args){
              return args.sort[]; 
          }

    
    
    * Hay que tener en cuenta que si el numero o propiedad / funcion, ya existia en el objeto actual, lo sobreescribe.
    
    array.filter()  // ejecuta una función en cada elemento de la matriz y se verifica si existe un elemento en ella, ej:
    const filter = (...args) => {
        return args.filter(el => el === 1);
    }

    console.log(filter(1,2,3));
    // [1]

19. Destructuring

    Permite extraer facilmente elementos de una matriz o propiedades de objetos y guardarlos en variables.
    ej:

    array:
        [nombre, apellido] = ['Noe','Donato'];
        console.log(nombre); // Noe
        console.log(apellido); // Donato

        const numbers = [1,2,3];
        [num1, num2] = numbers;
        console.log(num1,num2); // 1 2

        [num1, ,num3] = numbers;
        console.log(num1,num3); // 1 3

    object:
        { name } = { name: 'Noe', age: '32' };
        console.log(name); // Noe
        console.log(age); // undefined

20. Reference and Primitive Types Refresher

    Primitivos
    * Copia el valor de su variable en otra, osea hay 2.
    number, boolean, string

    Referencia
    * No copia, sino que hace referencia al puntero en memoria del otro objeto.
    Object, arrays.

        const person = {
            name: 'Max'
        };
        const secPerson = person;
        person.name = 'Manu';

        console.log(secPerson); // 'Manu'

    Para copiar un objeto, o sea generar uno nuevo, deberíamoshacer:
        const person = {
            name: 'Max'
        };
        const secPerson = {
            ...person
        };
        person.name = 'Manu';

        console.log(secPerson); // 'Max'

21. Refreshing Array Functions

    const numbers = [1,2,3];

    // La función se va a ejecutar por cada elemento
    // Al parametro le ponemos num, porque esta recorriendo numeros, como para ser claros.
    const numbers = [1,2,3];
    const doubleNumArray = numbers.map((num) => num * 2 );
    console.log(doubleNumArray); // [2,4,6]

22. Wrap Up

    Basicamente que cualquier cosa, se puede volver a esas clases para refrescar por si te olvidaste algo.

23. Next-Gen JavaScript - Summary

    Me la pase resumiendo y lo dejó él, acá: 

    Descargar el pdf o en mi caso ver:
        file:///C:/Users/Noe/Downloads/next-gen-js-summary.pdf
        
24. JS Array Functions

    En realidad, no la próxima generación de JavaScript, pero también es importante: un arreglo de funciones de JavaScript, como map() , filter() , reduce()  etc.
    Me verás usarlos bastante ya que muchos conceptos de React se basan en trabajar con arreglos (de manera inmutable).

    La siguiente página ofrece una buena descripción general de los diversos métodos que puede utilizar en el prototipo de matriz. No dude en hacer clic en ellos y actualizar sus conocimientos según sea necesario:  
         https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array
         
    Particularmente importantes en este curso son:

    map()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
    find()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
    findIndex()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
    filter()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
    reduce()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce?v=b
    concat()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat?v=b
    slice()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice
    splice()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice

### Sección 3 - Understanding the Base Features & Syntax ###

25. Module Introduction

    Que es, como usarlo, nuestra primera app react, conceptos generales, sintaxis basicas, etc.

26. The Build Workflow

                Recomendado para SPA y MPAs

    Porque?     
            - Optimización de codigo en grandes apps, para tener también el menor codigo postible, considerando el peso de las app también.

            - Usar nex-gen JS. Mejoramos como desarrolladores, y funcionan mejor las app, porque basicamente usar esto es "comprometerse con las mejores practicas"
                Como no en todos los browsers se soporta esto, se debe usar un flujo de trabajo diferente, para poder compilar next-gen javascript y usarlo.

            - Ser mas productivo. 
                Incluir, auto-prefixing de CSS. 
                Linting: una herramienta que te dice si estas escribiendo mal codigo o podes hacer mas optimo algún codigo especifico.
    
    Como?       
            - Gestor de dependencias: npm o yarn (3ty parth libraries)
            - Bundler "Controlador", recomendado: webpack
                Para escribir codigo modular, para tener una tarea/enfoque claro y nos resulte mas facil de mantener y administrar.
            - Compilador (para next-gen), recomendado: Babel + presets
            - Un Web Server de desarrollo. 
            
    * Nos va a enseñar una herramienta de desarrollo que hace todo esto menos engorroso y no tenemos qe andar configurando todo, es una herramienta que generó el equipo de React de facebook.
    * En otro modulo enseña como hacer una desde 0 igual.

27. Using Create React App

    Es la herramienta recomendada para crear proyectos de React. "Create React App"

    - Instalar Node JS.
    > npm install -g create-react-app // Instalar globalmente, para poder llamarla desde cualquier lado.
    > create-react-app react-guia-completa // El segundo parametro es el nombre de la app.
    > cd react-guia-completa
    > npm start

28. Understanding the Folder Structure
    ide-setup.pdf

    package.json
        Donde estan las dependencias y los diferentes scripts que podemos ejecutar para correr diferentes tareas. Dependencias productivas y de desarrollo.

    node_modules
        Donde estan las dependencias de cada paquete, y los paquetes en si de Node.
    
    public
        Es la carpeta raiz, donde van a estar todos los archivos que se le sirven al cliente.
        
        index.html 
            Es la única que tenemos y la única que vamos a tener. NUNCA TENEMOS QUE AGREGAR PAGINAS.
            Si es una MPA (Multi Page Application), el Workflow va a tener que ser diferente.
            Si queremos agregar otro css, va ahí.
            No metamos html dentro del html
        
        manifest.json
            Nos brinda una aplicación web progresiva, lista para usar.

    scr
        Ahí van los archivos que podemos editar.

        index.js
            obtiene acceso al elemento raiz de nuestro DOM del arch html, para que dentro del elemento con id="root" se renderice nuestra aplicación react.
        
        App.js 
            Actualmente ahí tenemos nuestro primer componente.
    
        registerServiceWorker.js (En la ultima versión no esta este archivo, esta: serviceWorker)
            Es importante para registrar un service worker, que es generado automaticamente, relacionado a la PWA
            Basicamente, pre-cachea los archivos scripts.

        App.test.js
            Nos permite crear pruebas unitarias para los diferentes componentes en nuestra app.

    - Eliminar el logo de react.svg y la linea que importa el logo.
    - Eliminar del archivo css, todo menos la parte de .App
    

29. Understanding Component Basics
    Descargar pdf o file:///C:/Users/Noe/Downloads/components-learning-card.pdf

    index.js
        import React from 'react';
        import ReactDOM from 'react-dom';
        import './index.css';
        import App from './App';
        import * as serviceWorker from './serviceWorker';

        // Siempre vamos a tener un elemento donde van a estar todos los componentes
        // y que lo vamos a renderizar en un id x ej root.
        ReactDOM.render(<App />, document.getElementById('root'));

    app.js
        import React, { Component } from 'react';
        import './App.css';

        class App extends Component {
            render() {
                return (
                    <div className="App">
                        <h1>Hola, soy una App React</h1>
                    </div>
                );
            }
        }

        export default App;

    - Para definir un componente, hay 2 maneras.
        1) 
            1.1) Creamos una clase y lo hacemos heredar de Component, 
                 que se importa de la libreria de react.
                 React, se importa porque es necesario para renderizar el componente y el objeto componente.
            1.2) el metodo render() 
                    sirve para renderizar JSX en la pantalla.

        2)
    - 

    * Por lo general cuando se elige el nombre de un componente, se usa ese nombre para la variable a importar, para el archivo y para el elemento.
    * Los archivos también podrían llamarse JSX, pero se usa js por convención.
        JSX en realidad es lo que llaman syntactic sugar. Es una sintaxis dentro de un lenguaje de programación, diseñado para ser mas facil de leer o expresarse.
        Es como "mas dulce para que lo use una persona"

30. Understanding JSX

    class App extends Component {
        render() {
            // Podemos usar el objeto de React para crear un elemento.
            // createElement, toma infinitos argumentos, pero el primero es o un elemento o un componente.
            // 2 arg: puede ser un objeto, aunque es opcional, por lo tanto pasamos null
            // 3 arg, los hijos: a partir de ese, van separados por comas, y basicamente s todo lo que va a ir, adentro del primer arg, el div en este caso.
                1 linea: como el comportamiento por default es tomar todo por texto, va a imprimir en pantalla, h1Iamreactapp, 
                2 lines: así que hay que usar otro react.createelement...
                3 linea: Para pasarle estilo

            //return React.createElement('div', null, 'h1','I\'m a React App!!!!');
            //return React.createElement('div', null, React.createElement('h1',null,'I\'m a React App!!!!'));
            return React.createElement('div', { className: 'App'}, React.createElement('h1',null,'I\'m a React App!!!!'));

        }
    }

    * NO SE USA CREAR LOS ELEMENTOS ASÍ, es para que sepamos que existe esto y no es lo correcto.
    Para eso se genera el "HTML, que en realidad es JSX" = javascript.

31. JSX Restrictions

    Como en realidad el html que vemos es JSX, no podemos usar palabras claves como class, debemos en este caso, por ej usar className, en el elemento.
    No podemos devolver elementos que no tienen un padre. Por ej, no podemos poner un elemento hermano al div root.
    Es buena practica, es meter todo dentro de un contenedor a devolver.

32. Creating a Functional Component

    vamos a crear un componente:
        src/
            Person/
                Person.js
        Por convención el nombre comienza con mayus.
        Por convención las funciones van en minuscula.
    
    La gran mayor cantidad de tiempo los componentes se crean como el de app, pero por lo general son solo funciones.
    
    Para crear un componente entonces (que no derive de Component): 
        Generamos una función.
        La exportamos como default.
        Retornamos JSX

    Para usar en nuestro component App:
        Importamos el componente.
        Dentro del html que estamos retornando, agregamos el tag con nuestro componente.

    <Person /> // lo podemos dejar así ya que no tenemos que anidar nada adentro.

33. Components & JSX Cheat Sheet
    Descargar pdf o file:///C:/Users/Noe/Downloads/components.Pronfudización

    Los componentes son el componente básico de las aplicaciones React . En realidad, React realmente es solo una biblioteca para crear componentes en su núcleo.

    Por lo tanto, una aplicación React típica podría representarse como un árbol de componentes : tiene un componente raíz ("Aplicación") y luego una cantidad potencialmente infinita de componentes secundarios anidados.
    Cada componente debe devolver / generar algún  código JSX ; define qué código HTML React debe procesar al DOM real al final.
    JSX NO es HTML pero se parece mucho a eso. Sin embargo, se pueden ver las diferencias cuando se mira de cerca (por ejemplo, className en JSX vs class en "HTML normal"). JSX es solo azúcar sintáctica para JavaScript, lo que le permite escribir código HTML en lugar de llamadas React.createElement (...) anidadas.
    
    Al crear componentes, puede elegir entre dos formas diferentes:
        Componentes funcionales (también conocidos como componentes de "presentación", "tontos" o "sin estado"; más información sobre esto más adelante en el curso) =>  
            const cmp = () => {
                 return <div>some JSX</div> 
            } 
            (se recomienda usar las funciones de flecha de ES6 como se muestra aquí, pero es opcional)

        Componentes basados ​​en clase (también conocidos como componentes "contenedores", "inteligentes" o "con estado") => 
            class Cmp extends Component { 
                    render () { 
                        return <div>some JSX</div> 
                        } 
            } 
    
    Por supuesto, nos sumergiremos en la diferencia a lo largo de este curso. Ya puede notar que debe usar 1) con la mayor frecuencia posible. Es la mejor práctica.

34. Working with Components & Re-Using Them

    Trabajar componentes en archivos separados, hace que el codigo sea mas mantenible.
    Aparte se lo puede configurar y reutilizar.
    return (
        <div className="App">
          <h1>Hola, soy una App React</h1>
          <Person />
          <Person />
          <Person />
        </div>
    ); 

    * Esto no es dinamico, así que en el proximo vamos a ver como hacerlo..

35. Outputting Dynamic Content

    Para que el js, no sea interpretada como texto, se debe usar ${js que quiera}
        return <p>Soy una persona and I am {Math.floor(Math.random() * 30)} years old! </p>

    Esto se usa para simples calculos o llamadas a funciones, pero nada mas, debería ser solo una linea de codigo

36. Working with Props
    Descargar pdf o file:///C:/Users/Noe/Downloads/props-learning-card.pdf

     return (
        <div className="App">
          <h1>Hola, soy una App React</h1>
          <Person name="Max" age="28"/>
          <Person name="Manu" age="29"/>
          <Person name="Noe" age="32"/>
        </div>
    ); 
    
    Del componente principal, se le pasa al componente que corresponde el valor de las propiedades.

    Person.js
        #IMPORTANTE: El argumento es un objeto con toda la info que se le pasa al componente, se puede llamar props, como se puede llamar pepito.

        const person = (props) => {
            return <p>Hola! Soy {props.name} y tengo {props.age} años! </p>
        }

    #IMPORTANTE: Cuanto se usa en una clase-componente (como app), se tiene que usar this.props

37. Understanding the Children Property
    en esta carpeta: base-syntax--01-props-custom-cmp.zip

    <div>
        <p>I'm {props.name} and I am {props.age} years old!</p>
        <p>{props.children}</p>
    </div>

    Si queremos pasar algo entre la etiqueta de apertura y cierre, tenemos que envolver eso en un elemento padre y usar children.

    <div className="App">
        <h1>Hola, soy una App React</h1>
        <Person name="Max" age="28"/>
        <Person name="Manu" age="29">My hobbies: Racing</Person>
        <Person name="Noe" age="32"/>
    </div>

38. Understanding & Using State

    <button>Cambiar de nombre</button>

    State:
        #IMPORTANTE: 
            - SOLO SE PUEDE USAR: En las clases-componentes
            - es una propiedad especial, donde se establecen y pasan props desde afuera como name, age etc, y que se gestionan dentro del componente.
                Si cambiamos algo que use esta propiedad, va a renderizar nuevamente el dom/componente.

            Se inicializa como un objeto.
                state = {}
            Se le pueden agrengar, array objetos:
                state = {
                    persons: [
                        { name: 'Noe', age: 32 },
                        { name: 'Gabu', age: 29 },
                        { name: 'Nany', age: 33 },
                    ]
                }

            Una vez que hacemos esto, la podemos usar en nuestro metodo dinamico.

            <div className="App">
            <h1>Hola, soy una App React</h1>
            <button>Cambiar de nombre</button>
            <Person name={this.state.persons[0].name} age={this.state.persons[0].age}/>
            <Person name={this.state.persons[1].name} age={this.state.persons[1].age}>My hobbies: Racing</Person>
            <Person name={this.state.persons[2].name} age={this.state.persons[2].age}/>
            </div>

    
39. Props & State
    file:///C:/Users/Noe/Downloads/props-state.pdf

    props  y state  son los conceptos CORE de React. En realidad, solo se realizan cambios props  y / o se state  activa React para volver a renderizar sus componentes y potencialmente actualizar el DOM en el navegador (en la sección 6 se proporciona una descripción detallada de cómo React verifica si se debe tocar realmente el DOM real).
    Props
        props  le permite pasar datos de un componente principal (ajuste) a un componente secundario (incorporado).

    Ejemplo:
        AllPosts Component:
            const posts = () => {
                return (
                    <div>
                        <Post title="My first Post" />
                    </div>
                );
            }

        Aquí title  está la propiedad personalizada ( prop ) configurada en el Post  componente personalizado . Básicamente, replicamos el comportamiento del atributo HTML predeterminado que ya conocemos (por ejemplo, <input type="text">  le informamos al navegador acerca de cómo manejar esa entrada).

        Post Component:
            const post = ( props ) => {   
                volver ( 
                    <div>
                        <h1> { props . título } </ h1 >
                    </ div >
                );
            }

        El Post  componente recibe el props  argumento. Por supuesto, puede nombrar este argumento como desee: es la definición de su función, ¡a React no le importa! Pero React pasará un argumento a su función de componente => Un objeto, que contiene todas las propiedades que configuró <Post ... /> .
        {props.title}  luego genera dinámicamente la title  propiedad del props  objeto, que está disponible ya que configuramos la title  propiedad dentro del AllPosts  componente (ver arriba).


    Estado
        Mientras que los accesorios le permiten pasar datos al árbol de componentes (y, por lo tanto, desencadenar una actualización de la interfaz de usuario), el estado se usa para cambiar el componente, bueno, el estado desde dentro. Los cambios en el estado también activan una actualización de la interfaz de usuario.

    Ejemplo:
        NewPost Component:
            ¡La clase NewPost extiende el Componente { // estado solo se puede acceder en los componentes basados ​​en clase!     
            
            class NewPost extends Component { // state can only be accessed in class-based components!
                state = {
                    counter: 1
                };  
            
                render () { // Needs to be implemented in class-based components! Needs to return some JSX!
                    return (
                        <div>{this.state.counter}</div>
                    );
                }
            }

        Aquí, el NewPost  componente contiene state . Solo los componentes basados ​​en clases pueden definir y usar state .    Por supuesto, puede pasar state  a componentes funcionales, pero estos no pueden editarlo directamente.
        state  Simplemente es una propiedad de la clase de componente, state  aunque debe llamarlo , el nombre no es opcional. Luego, puede acceder a él a través this.state  de su código JSX de clase (que devuelve en el render()  método requerido ).
        Cada vez que state  cambia (se enseña en las próximas conferencias), el componente se volverá a representar y reflejará el nuevo estado. La diferencia props  es que esto sucede dentro de un mismo componente: ¡no recibe datos nuevos ( props ) de fuera!

40. Handling Events with Methods
    // en JSX es con la C mayus.
    <button onClick=>Cambiar de nombre</button>

    es buena practica ponerle al final Handler, a la función que haga de handler.

    switchNameHanlder = () => {
        console.log("click");
    }
    
    a la función no hay que ponerle los () para que no lo llame en ese mismo momento.

    <button onClick={this.switchNameHanlder}>Cambiar de nombre</button>


41. To Which Events Can You Listen?

    En la última conferencia, vimos que puedes reaccionar ante el evento onClick, pero ¿a qué otros eventos puedes escuchar? Puede encontrar una lista de eventos compatibles aquí:  https://reactjs.org/docs/events.html#supported-events

    Clipboard Events
        Event names:
            onCopy onCut onPaste
        Properties:
            DOMDataTransfer clipboardData
    
    Composition Events
        Event names:
            onCompositionEnd onCompositionStart onCompositionUpdate
        Properties:
            string data
        
    Keyboard Events
        Event names:
            onKeyDown onKeyPress onKeyUp
        
        Properties:
            boolean altKey
            number charCode
            boolean ctrlKey
            boolean getModifierState(key)
            string key
            number keyCode
            string locale
            number location
            boolean metaKey
            boolean repeat
            boolean shiftKey
            number which

    Focus Events
        Event names:
            onFocus onBlur
        
        These focus events work on all elements in the React DOM, not just form elements.

        Properties:
            DOMEventTarget relatedTarget
    
    Form Events
        Event names:
            onChange onInput onInvalid onSubmit
        
        For more information about the onChange event, see Forms.

    Mouse Events
        Event names:
            onClick onContextMenu onDoubleClick onDrag onDragEnd onDragEnter onDragExit
            onDragLeave onDragOver onDragStart onDrop onMouseDown onMouseEnter onMouseLeave
            onMouseMove onMouseOut onMouseOver onMouseUp
        
        The onMouseEnter and onMouseLeave events propagate from the element being left to the one being entered instead of ordinary bubbling and do not have a capture phase.

        Properties:
            boolean altKey
            number button
            number buttons
            number clientX
            number clientY
            boolean ctrlKey
            boolean getModifierState(key)
            boolean metaKey
            number pageX
            number pageY
            DOMEventTarget relatedTarget
            number screenX
            number screenY
            boolean shiftKey
    Selection Events
        Event names:
            onSelect
    
    Touch Events
        Event names:
            onTouchCancel onTouchEnd onTouchMove onTouchStart

        Properties: 
            boolean altKey
            DOMTouchList changedTouches
            boolean ctrlKey
            boolean getModifierState(key)
            boolean metaKey
            boolean shiftKey
            DOMTouchList targetTouches
            DOMTouchList touches
    
    UI Events
        Event names:
            onScroll
        Properties:
            number detail
            DOMAbstractView view

    Wheel Events
        Event names:
            onWheel
        Properties:
            number deltaMode
            number deltaX
            number deltaY
            number deltaZ
    
    Media Events
        Event names:
            onAbort onCanPlay onCanPlayThrough onDurationChange onEmptied onEncrypted
            onEnded onError onLoadedData onLoadedMetadata onLoadStart onPause onPlay
            onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend
            onTimeUpdate onVolumeChange onWaiting

    Image Events
        Event names:
            onLoad onError
    
    Animation Events
        Event names:
            onAnimationStart onAnimationEnd onAnimationIteration
        Properties:
            string animationName
            string pseudoElement
            float elapsedTime

    Transition Events
        Event names:
            onTransitionEnd
        Properties:
            string propertyName
            string pseudoElement
            float elapsedTime
    Other Events
        Event names:
            onToggle

42. Manipulating the State
    file:///C:/Users/Noe/Downloads/state-learning-card.pdf

    switchNameHanlder = () => {
        // No hay que mutar de esta manera (cambiar de estado), va a dar un error.
        this.state.persons[0].name = 'Noelia';
        this.setState({
            persons: [
                { name: 'Noeñs', age: 32 },
                { name: 'Gabuns', age: 29 },
                { name: 'Nanys', age: 33 },
            ]
        )
    }

    setState:
        Este es un método que nos permite actualizar esta propiedad state, después
        nos aseguramos de que react conozca como la actualización y react actualice el DOM.

        // Toma un objeto como argumento y fusionara (sobreescribe) eso con nuestro estado actual
        switchNameHanlder = () => {
            this.setState({
                persons: [
                    { name: 'Noels', age: 32 },
                    { name: 'Gabuns', age: 29 },
                    { name: 'Nanys', age: 33 },
                ]
            })
        }

        * Solo se pueden cambiar props y state 

43. Functional (Stateless) vs class (Stateful) Components
    
    Functional (Stateless)
        La mayoria de las veces vamos a usar funciones stateless, las que reciben props.
        Solo renderizan cosas al DOM, son dinamicos, pueden tener logica, pero no manipulan el estado de la aplicación.


    Class (Stateful) Components 
        La mayor parte de la app, no debería cambiar el estado de la aplicación, se supone que solo va a cambiar en ciertos componentes,
            conocidos como "contenedores" ej app.js
    
    * Vamos a ver como se puede cambiar el estado desde otro componente.
    
44. Passing Method References Between Components
    base-syntax--02-state-events.zip

    No se puede pasar un manejador de eventos de un archivo a otro, así que se puede pasar como propiedad. props.
    
    Esto es un patrón comun:
        Le pasamos el eventHandler por propiedad. 
        El nombre de la prop es el que nosotros queramos.
        Se lo pasamos por "referencencia"

    App.js
        <div className="App">
            <button onClick={this.switchNameHanlder}>Cambiar de nombre</button>
            <Person 
                name={this.state.persons[2].name} 
                age={this.state.persons[2].age}
                click={this.switchNameHanlder}/>
        </div>

    Person.js
        <p onClick={props.click}>I'm {props.name} and I am {props.age} years old!</p>
        
    También podemos pasarle datos al evento:

        1) Pasado un argumento, con bind

            switchNameHanlder = (newName) => {
                this.setState({
                persons: [
                    { name: newName, age: 32 },
                    ]
                })
            }

            <button onClick={this.switchNameHanlder.bind(this,'Maximilian!!')}>Switch Name</button>

            <Person
                name={this.state.persons[1].name}
                age={this.state.persons[1].age}
                click={this.switchNameHanlder.bind(this, 'Max!')}>
                My Hobbies: Racing
            </Person>

        2) Con una arrow function
            
            <button onClick={() => this.switchNameHanlder()}>Switch Name</button>
        
        * Recomienda usar la primera porque con la segunda puede que react, renderce cosas innecesarias. 
            PUEDE SER INEFICIENTE.

45. Adding Two Way Binding

    Agrega un input en person, para reflejar lo que el usuario escribe ahí.
    Agrega un nuevo handler nameChangedHandler, solo va a cambiar el nombre de uno solo porque no aprendimos LISTAS todavía.
    


46. Adding Styling with Stylesheets

47. Working with Inline Styles
    Tarea 1: Time to Practice - The Base Syntax

48. Useful Resources & Links
    base-syntax--01-props-custom-cmp.zip
    base-syntax--02-state-events.zip
    base-syntax--03-finished.zip
    base-syntax--assignment-solution.zip
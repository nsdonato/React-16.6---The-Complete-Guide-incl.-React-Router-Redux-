…or create a new repository on the command line
    echo "# React-16.6---The-Complete-Guide-incl.-React-Router-Redux-" >> README.md
    git init
    git add README.md
    git commit -m "first commit"
    git remote add origin https://github.com/nsdonato/React-16.6---The-Complete-Guide-incl.-React-Router-Redux-.git
    git push -u origin master
    
…or push an existing repository from the command line
    git remote add origin https://github.com/nsdonato/React-16.6---The-Complete-Guide-incl.-React-Router-Redux-.git
    git push -u origin master

## SECCION 1 ##

1. Introduction
2. What is React?

    Que, como y porque:
        Una libreria de JavaScript para crear interfaces de usuario (Componentes)
        Corre en el navegador.
        Podemos reusar componentes.

3. Real-World SPAs & React Web Apps

    Mas frula sobre componentes, nada interesante.

    Adding the Right React Version to Codepen

    In the next lecture, we'll write our first React code in Codepen, an online editor (it's only getting used in the next lecture).
    Currently, there seems to be a bug if you add React as shown in the next video.
    To fix it, replace the automatically added import paths (you'll see what I mean) with these:
        https://cdnjs.cloudflare.com/ajax/libs/react/15.6.1/react.min.js 
        https://cdnjs.cloudflare.com/ajax/libs/react/15.6.1/react-dom.min.js 
    This should fix. And don't worry about the React version, the entire rest of the course uses 16+ :)

4. Writing our First React Code
    
    Crear una aplicación en Codepen.
        
        Cuando se repite un elemento pero tiene diferente información adentro, esto ya se puede entender como un componente.

    - Importar React:
        https://cdnjs.cloudflare.com/ajax/libs/react/15.6.1/react.min.js 

    - Importar React DOM, la logica para crear los componentes en el DOM real.
        https://cdnjs.cloudflare.com/ajax/libs/react/15.6.1/react-dom.min.js 

    - Para utilizar las últimas caracteristicas de React --> Babel

    // Tiene que comenzar con mayuscula para que funcione bien.
    function Person(){
        return (
            <div className="person">
                <h1>Max</h1>
                <p>Your Age: 28</p>
            </div>
        );// Sintaxis JSX, para renderizar el DOM.
    }

    ReactDOM.render(<Person />, document.querySelector('#p1')); 

    // el metodo render nos permite representar una función de JavaScript como componente del DOM real, y tratarlo como un componente.
    // le decimos que renderice como html ese objeto Person.
    // le decimos en donde queremos que se vea ese componente.

    * las clases en el codigo html se tienen que escribir className en vez de class. Porque React renderiza ese html como un componente JavaScript (que usa la propiedad className)

    // Le agrega un argumento que es propio de react
    // los datos dinamicos se encierran entre { }
     function Person(props){
        return (
            <div className="person">
                <h1>{props.name}</h1>
                <p>{props.age}</p>
            </div>
        );// Sintaxis JSX, para renderizar el DOM.
    }

    ReactDOM.render(<Person name="Max" age="28"/>, document.querySelector('#p1')); 
    ReactDOM.render(<Person name="Manu" age="29"/>, document.querySelector('#p2')); 

    En vez tener un elemento div con la clase p1, ahora solo vamos a tener uno con id Apps
    HTML:
    <div id="app"></div>

    JS:
     function Person(props){
        return (
            <div className="person">
                <h1>{props.name}</h1>
                <p>{props.age}</p>
            </div>
        );// Sintaxis JSX, para renderizar el DOM.
    }

    var app = (
         <div>
            <Person name="Max" age="28" />
            <Person name="Manu" age="29" />
         </div>
    );

    // En vez de tener dos elementos, tengo uno solo que tenga los 2.
     ReactDOM.render(<app/>, document.querySelector('#app')); 

     * Este es el mejor modo para crear SAP. Single Page Applications.

5. Why should we choose react?

    Porque en aplicaciones grandes es dificil de manejar el ESTADO.
    Aparte si tenes que cambiar los elementos de lugar y puede que tengas que cambiar cosas y estas usando querySelector.
     
    React nos permite enfocarnos en nuestra logica de negocios, envitando que nuestr app explote.
    Supuestamente como React tiene una comunidad zarpada, el codigo es excelente.
    Aparte de tener un gran ecosistema, comunidad activa y alta performance.

6. React alternatives.

    Angular y Vue.js
        Te sirve para enforcarte en la logica y en el modelo de negocio, y no tanto en el aspecto del elemento en particular que querías cambiar (cmo en react)

7. Understanding Single Page Applications and Multi Page Applications.

    SAP:
         Solo recuperamos un solo archivo html, el contenido es renderizado en el cliente.
         Esta construidda por componentes, y cada componente es un componente React, también es mantenida por un componente root de React, que esta bajo el cotnrol de React.
         Tipicalmente tenemos una llamada reactDOM.render(), se necesita una sola porque tenemos un componente raiz, que esta montado en el DOM que tiene todo el resto de componentes.

    MPA:
        Recuperamos varias paginas determinadas, donde cada pagina tiene el contenido para una ruta determinada, y el contenido es renderizado en el servidor.
        Algunas partes de la pagina son componentes React.
        Los widgets individuales no conocen la existencia de otros.
        Vamos a tener varios reactDOM.render para los diferentes componentes, en difernetes lugares de la app.

8. Course outline.

     Getting started.
        Usar JavaScript moderno porque mantiene limpio y es un estandar para react, funciones de flechas y esas cosas.
    
    React basics.
        Como crear componentes reacts, ver las diferentes maneras que hay de hacerlo y como comunicarse entre componentes.
        Como podemos generar listas, o como podemos presentar contenido de forma condicional.

    Debug
        Como debuggear react.

    Styling componentes 
        Como darle estilo a los componentes y como podemos asegurarnos de que el estilo que aplicamos a un componente, solo se aplique a ese componente y no a todos.

    Componentes Deep Dive
        Pronfudización en los componentes, ya que tendremos mucho conocimiento de ellos, vamos a aprender cual es su ciclo de vida.
        Como comprobar actualizaciones a menudo o no.

    HTTP Request
        Como conectarla con el mundo exterior, como obtener datos de un servidor o subirlos al servidor.

    Routing.
        Es una caracteristica del Core de las SAP, porque con routing, podemos manejar diferentes urls, /productos /usuarios  diferentes paginas, aunque tengamos un solo HTML, y en realidad
        lo que hacemos es analizar la url y renderizar las diferentes partes que necesitamos, para mostrar "una nueva pagina".
    
    Forms and validation.
        validación de entrada de datos de los usuarios, etc.

    Redux
        es una biblioteca de terceros pero se usa muchisimo con react.
        acciones asincronas, etc.

    Authentication
        login de usuario.

    Testing
         Introducción a como probar app de react.

    Deployment
        Como publicar en producción

    Bonus: aplicaciones de react animadas, ubicación de reactores, webpack, etc.
        NextJs, una libreria construida bajo react, donde contrustruimos nuestro propio flujo de trabajo, etc.

    
9. How to get the Most out of This Course

    Como sacarle provecho al curso:
        Codificar solo.
        Si algo no funciona, chequear contra su codigo.
        Si estas atascado, usar lar parte donde se hacen las preguntas, primero buscar porque seguro alguien ya pregunto.
        Practicar.

10. Useful Resources & Links

    Documentación de React: https://reactjs.org/
    El codepen, hecho por él: https://codepen.io/anon/pen/MELQaQ


### Sección: 2 - Refreshing Next Generation JavaScript (Optional) ###

11. Module Introduction
    Next-Gen Javascript, para refrescar. React usa esto, así que, hay que saber.

12. Understanding "let" and "const"
    let = var (cambia el tema del scope, porque ahora es de bloque.)
    const = para info que no va a cambiar.

13. Arrow Functions
    antes:
        function myFuncion() {
            ...
        } 

    ahora:
        const myFuncion = () => {
            ...
        }

    * Arrow functions, mejoran el problema de que this, no siempre apuntaba al contexto de ejecución, sino al objeto global.
    * Si no tiene parametros, va solo parentesis
    * Si tiene uno, es param => 
    * Si tiene mas de uno, es (param1,param2) =>
    * Si la parte de retorno solo tiene una linea, se puede escribir así: const multiplicar = number => number * 2;

14. Exports and Imports

    Para codigo modular, para dividir los archivos js en varios archivos.
        Si bien ya se puede (porque agregas diferentes archivos en el html, de manera ordenada)
        Lo que pasa ahora es que desde un js, se puede usar info de otro js.

    EXPORTAR
        person.js
            const person = {
                name: 'Max'
            } 
            export default person

            // export: sirve para exportar esa función, objeto, etc, desde un archivo.
            // default: que esa funcion, obj, etc, va a ser la predeterminada.
            // person: en este caso es el objeto 

        utility.js
            export const clean = () => { ... }
            export const baseData = 10;

    IMPORTAR
        app.js
            // Se pone de alguna de las dos maneras, ya que hace referencia a lo único que se exporto (default)

                import person from './person.js' 
                import prs from './person.js'   

            // Al ser exportada como diferentes constantes, se usa las { }  para "mejorar el codigo", diciendo que se esta exportando algo especifico
            // Tiene que respetar el nombre que se le puso en el archivo donde se la exporta obj
            // se puede ponerle un alias, como en la segunda linea

                import { baseData } from './utility.js' 
                import { baseData as bd } from './utility.js' 

            // También se podría hacer de esta manera.

                import { baseData, clean } from './utility.js' 

    
15. Understanding Classes

    - Los metodos son como: funciones atachados a esa clase/objetos,
    - las propiedades son como: variables, atachadas a esa clase/objetos,

    class Human {
        constructor(){
            this.gender = 'male';
        }

        printGender(){
            consoe.log(this.gender);
        }
    }

    // Herencia
    class Person extends Human{
        constructor(){
            super();
            this.name = 'Max';
            this.gender = 'female'; // pero no es correcto usar así.
        }
        
        printMyname (){
            console.log(this.name);
        }
    }

    // Instanciar un objeto de esa clase.
    const miPersona = new Person();
    miPersona.printMyname();
    miPersona.printGender();    

16. Classes, Properties and Methods

    ES6
        constructor() {
            this.myProperty = 'value'
        }

        miMetodo () {
            ...
        }

    ES7
        myProperty = 'value'; // Si, no hay un "constructor" en si.

        miMetodo = () => {
            ...
        }
        
    * Es mejor usar ambos opciones de ES7, para esto si o si hay que usar ES6/Babel.

17. The Spread & Rest Operator  

    // Operator Spread o Rest (depende de donde se use)
    ...

    Spread: (división de las propiedades de un objeto o un array.)

            Se usa para dividir elementos de un array o propiedades de un objeto.
            Por ejemplo, si tenemos una matriz antigua y queremos agregar todos los elementos de esa matriz anterior a una nueva matriz y,
            además, agregar un 1 en un elemento dos, este primer índice sería lo que tenía tres puntos delante
            de toda la matriz. simplemente extraiga todos los elementos y agregue a la nueva matriz que
            creamos con corchetes.

            // Idem object pero array
                const oldArray = [3,4,5];
                const newArray = [...oldArray,1,2];
                console.log(newArray);
                // 3,4,5,1,2

            // Lo probé, lo que hace es agarrar las propiedades/funciones del objeto viejo, y ponerselo al nuevo y suma la nueva prop/func.
            const oldObject = {
                name: "Noe";
            }

            const newObject = { ...oldObject, newProp: 5 }
            console.log(newO)
    Rest: (Fusión de elementos en un array)
          
          Se utiliza con menos frecuencia.

          Se usa para mergear una lista de argumentos de funciones en una matriz.
          O sea, lo usamos en el parametro de una función. ej:

          // Recibe una lista ilimitada de argumentos, y todos se fusionan en un array.
          // O sea, en vez de dividir, los une.
          function sortArgs(...args){
              return args.sort[]; 
          }

    
    
    * Hay que tener en cuenta que si el numero o propiedad / funcion, ya existia en el objeto actual, lo sobreescribe.
    
    array.filter()  // ejecuta una función en cada elemento de la matriz y se verifica si existe un elemento en ella, ej:
    const filter = (...args) => {
        return args.filter(el => el === 1);
    }

    console.log(filter(1,2,3));
    // [1]

18. Destructuring

    Permite extraer facilmente elementos de una matriz o propiedades de objetos y guardarlos en variables.
    ej:

    array:
        [nombre, apellido] = ['Noe','Donato'];
        console.log(nombre); // Noe
        console.log(apellido); // Donato

        const numbers = [1,2,3];
        [num1, num2] = numbers;
        console.log(num1,num2); // 1 2

        [num1, ,num3] = numbers;
        console.log(num1,num3); // 1 3

    object:
        { name } = { name: 'Noe', age: '32' };
        console.log(name); // Noe
        console.log(age); // undefined

19. Reference and Primitive Types Refresher

    Primitivos
    * Copia el valor de su variable en otra, osea hay 2.
    number, boolean, string

    Referencia
    * No copia, sino que hace referencia al puntero en memoria del otro objeto.
    Object, arrays.

        const person = {
            name: 'Max'
        };
        const secPerson = person;
        person.name = 'Manu';

        console.log(secPerson); // 'Manu'

    Para copiar un objeto, o sea generar uno nuevo, deberíamoshacer:
        const person = {
            name: 'Max'
        };
        const secPerson = {
            ...person
        };
        person.name = 'Manu';

        console.log(secPerson); // 'Max'

20. Refreshing Array Functions

    const numbers = [1,2,3];

    // La función se va a ejecutar por cada elemento
    // Al parametro le ponemos num, porque esta recorriendo numeros, como para ser claros.
    const numbers = [1,2,3];
    const doubleNumArray = numbers.map((num) => num * 2 );
    console.log(doubleNumArray); // [2,4,6]

21. Wrap Up

    Basicamente que cualquier cosa, se puede volver a esas clases para refrescar por si te olvidaste algo.

22. Next-Gen JavaScript - Summary

    Me la pase resumiendo y lo dejó él, acá: 

    Descargar el pdf o en mi caso ver:
        file:///C:/Users/Noe/Downloads/next-gen-js-summary.pdf
        
23. JS Array Functions

    En realidad, no la próxima generación de JavaScript, pero también es importante: un arreglo de funciones de JavaScript, como map() , filter() , reduce()  etc.
    Me verás usarlos bastante ya que muchos conceptos de React se basan en trabajar con arreglos (de manera inmutable).

    La siguiente página ofrece una buena descripción general de los diversos métodos que puede utilizar en el prototipo de matriz. No dude en hacer clic en ellos y actualizar sus conocimientos según sea necesario:  
         https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array
         
    Particularmente importantes en este curso son:

    map()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
    find()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
    findIndex()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
    filter()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
    reduce()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce?v=b
    concat()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat?v=b
    slice()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice
    splice()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice

### Sección 3 - Understanding the Base Features & Syntax ###

24. Module Introduction

    Que es, como usarlo, nuestra primera app react, conceptos generales, sintaxis basicas, etc.

25. The Build Workflow

                Recomendado para SPA y MPAs

    Porque?     
            - Optimización de codigo en grandes apps, para tener también el menor codigo postible, considerando el peso de las app también.

            - Usar nex-gen JS. Mejoramos como desarrolladores, y funcionan mejor las app, porque basicamente usar esto es "comprometerse con las mejores practicas"
                Como no en todos los browsers se soporta esto, se debe usar un flujo de trabajo diferente, para poder compilar next-gen javascript y usarlo.

            - Ser mas productivo. 
                Incluir, auto-prefixing de CSS. 
                Linting: una herramienta que te dice si estas escribiendo mal codigo o podes hacer mas optimo algún codigo especifico.
    
    Como?       
            - Gestor de dependencias: npm o yarn (3ty parth libraries)
            - Bundler "Controlador", recomendado: webpack
                Para escribir codigo modular, para tener una tarea/enfoque claro y nos resulte mas facil de mantener y administrar.
            - Compilador (para next-gen), recomendado: Babel + presets
            - Un Web Server de desarrollo. 
            
    * Nos va a enseñar una herramienta de desarrollo que hace todo esto menos engorroso y no tenemos qe andar configurando todo, es una herramienta que generó el equipo de React de facebook.
    * En otro modulo enseña como hacer una desde 0 igual.

26. Using Create React App

    Es la herramienta recomendada para crear proyectos de React. "Create React App"

    - Instalar Node JS.
    > npm install -g create-react-app // Instalar globalmente, para poder llamarla desde cualquier lado.
    > create-react-app react-guia-completa // El segundo parametro es el nombre de la app.
    > cd react-guia-completa
    > npm start

27. Understanding the Folder Structure
    C:\Cursos\React-16.6---The-Complete-Guide-incl.-React-Router-Redux-\info_gral_curso\27\ide-setup.pdf

    package.json
        Donde estan las dependencias y los diferentes scripts que podemos ejecutar para correr diferentes tareas. Dependencias productivas y de desarrollo.

    node_modules
        Donde estan las dependencias de cada paquete, y los paquetes en si de Node.
    
    public
        Es la carpeta raiz, donde van a estar todos los archivos que se le sirven al cliente.
        
        index.html 
            Es la única que tenemos y la única que vamos a tener. NUNCA TENEMOS QUE AGREGAR PAGINAS.
            Si es una MPA (Multi Page Application), el Workflow va a tener que ser diferente.
            Si queremos agregar otro css, va ahí.
            No metamos html dentro del html
        
        manifest.json
            Nos brinda una aplicación web progresiva, lista para usar.

    scr
        Ahí van los archivos que podemos editar.

        index.js
            obtiene acceso al elemento raiz de nuestro DOM del arch html, para que dentro del elemento con id="root" se renderice nuestra aplicación react.
        
        App.js 
            Actualmente ahí tenemos nuestro primer componente.
    
        registerServiceWorker.js (En la ultima versión no esta este archivo, esta: serviceWorker)
            Es importante para registrar un service worker, que es generado automaticamente, relacionado a la PWA
            Basicamente, pre-cachea los archivos scripts.

        App.test.js
            Nos permite crear pruebas unitarias para los diferentes componentes en nuestra app.

    - Eliminar el logo de react.svg y la linea que importa el logo.
    - Eliminar del archivo css, todo menos la parte de .App
    

28. Understanding Component Basics
    file:///C:/Cursos/React-16.6---The-Complete-Guide-incl.-React-Router-Redux-/info_gral_curso/28/components-learning-card.pdf

    index.js
        import React from 'react';
        import ReactDOM from 'react-dom';
        import './index.css';
        import App from './App';
        import * as serviceWorker from './serviceWorker';

        // Siempre vamos a tener un elemento donde van a estar todos los componentes
        // y que lo vamos a renderizar en un id x ej root.
        ReactDOM.render(<App />, document.getElementById('root'));

    app.js
        import React, { Component } from 'react';
        import './App.css';

        class App extends Component {
            render() {
                return (
                    <div className="App">
                        <h1>Hola, soy una App React</h1>
                    </div>
                );
            }
        }

        export default App;

    - Para definir un componente, hay 2 maneras.
        1) 
            1.1) Creamos una clase y lo hacemos heredar de Component, 
                 
                 que se importa de la libreria de react.
                 React, se importa porque es necesario para renderizar el componente y el objeto componente.
            
            1.2) el metodo render() 
                    sirve para renderizar JSX en la pantalla.

        2)
    - 

    * Por lo general cuando se elige el nombre de un componente, se usa ese nombre para la variable a importar, para el archivo y para el elemento.
    * Los archivos también podrían llamarse JSX, pero se usa js por convención.
        JSX en realidad es lo que llaman syntactic sugar. Es una sintaxis dentro de un lenguaje de programación, diseñado para ser mas facil de leer o expresarse.
        Es como "mas dulce para que lo use una persona"

29. Understanding JSX

    class App extends Component {
        render() {
            // Podemos usar el objeto de React para crear un elemento.
            // createElement, toma infinitos argumentos, pero el primero es o un elemento o un componente.
            // 2 arg: puede ser un objeto, aunque es opcional, por lo tanto pasamos null
            // 3 arg, los hijos: a partir de ese, van separados por comas, y basicamente s todo lo que va a ir, adentro del primer arg, el div en este caso.
                1 linea: como el comportamiento por default es tomar todo por texto, va a imprimir en pantalla, h1Iamreactapp, 
                2 lines: así que hay que usar otro react.createelement...
                3 linea: Para pasarle estilo

            //return React.createElement('div', null, 'h1','I\'m a React App!!!!');
            //return React.createElement('div', null, React.createElement('h1',null,'I\'m a React App!!!!'));
            return React.createElement('div', { className: 'App'}, React.createElement('h1',null,'I\'m a React App!!!!'));

        }
    }

    * NO SE USA CREAR LOS ELEMENTOS ASÍ, es para que sepamos que existe esto y no es lo correcto.
    Para eso se genera el "HTML, que en realidad es JSX" = javascript.

30. JSX Restrictions

    Como en realidad el html que vemos es JSX, no podemos usar palabras claves como class, debemos en este caso, por ej usar className, en el elemento.
    No podemos devolver elementos que no tienen un padre. Por ej, no podemos poner un elemento hermano al div root.
    Es buena practica, es meter todo dentro de un contenedor a devolver.

31. Creating a Functional Component

    vamos a crear un componente:
        src/
            Person/
                Person.js
        Por convención el nombre comienza con mayus.
        Por convención las funciones van en minuscula.
    
    La gran mayor cantidad de tiempo los componentes se crean como el de app, pero por lo general son solo funciones.
    
    Para crear un componente entonces (que no derive de Component): 
        Generamos una función.
        La exportamos como default.
        Retornamos JSX

    Para usar en nuestro component App:
        Importamos el componente.
        Dentro del html que estamos retornando, agregamos el tag con nuestro componente.

    <Person /> // lo podemos dejar así ya que no tenemos que anidar nada adentro.

32. Components & JSX Cheat Sheet
    Descargar pdf o file:///C:/Users/Noe/Downloads/components.Pronfudización

    Los componentes son el componente básico de las aplicaciones React . En realidad, React realmente es solo una biblioteca para crear componentes en su núcleo.

    Por lo tanto, una aplicación React típica podría representarse como un árbol de componentes : tiene un componente raíz ("Aplicación") y luego una cantidad potencialmente infinita de componentes secundarios anidados.
    Cada componente debe devolver / generar algún  código JSX ; define qué código HTML React debe procesar al DOM real al final.
    JSX NO es HTML pero se parece mucho a eso. Sin embargo, se pueden ver las diferencias cuando se mira de cerca (por ejemplo, className en JSX vs class en "HTML normal"). JSX es solo azúcar sintáctica para JavaScript, lo que le permite escribir código HTML en lugar de llamadas React.createElement (...) anidadas.
    
    Al crear componentes, puede elegir entre dos formas diferentes:
        Componentes funcionales (también conocidos como componentes de "presentación", "tontos" o "sin estado"; más información sobre esto más adelante en el curso) =>  
            const cmp = () => {
                 return <div>some JSX</div> 
            } 
            (se recomienda usar las funciones de flecha de ES6 como se muestra aquí, pero es opcional)

        Componentes basados ​​en clase (también conocidos como componentes "contenedores", "inteligentes" o "con estado") => 
            class Cmp extends Component { 
                    render () { 
                        return <div>some JSX</div> 
                        } 
            } 
    
    Por supuesto, nos sumergiremos en la diferencia a lo largo de este curso. Ya puede notar que debe usar 1) con la mayor frecuencia posible. Es la mejor práctica.

33. Working with Components & Re-Using Them

    Trabajar componentes en archivos separados, hace que el codigo sea mas mantenible.
    Aparte se lo puede configurar y reutilizar.
    return (
        <div className="App">
          <h1>Hola, soy una App React</h1>
          <Person />
          <Person />
          <Person />
        </div>
    ); 

    * Esto no es dinamico, así que en el proximo vamos a ver como hacerlo..

34. Outputting Dynamic Content

    Para que el js, no sea interpretada como texto, se debe usar ${js que quiera}
        return <p>Soy una persona and I am {Math.floor(Math.random() * 30)} years old! </p>

    Esto se usa para simples calculos o llamadas a funciones, pero nada mas, debería ser solo una linea de codigo

35. Working with Props
    Descargar pdf o file:///C:/Users/Noe/Downloads/props-learning-card.pdf

     return (
        <div className="App">
          <h1>Hola, soy una App React</h1>
          <Person name="Max" age="28"/>
          <Person name="Manu" age="29"/>
          <Person name="Noe" age="32"/>
        </div>
    ); 
    
    Del componente principal, se le pasa al componente que corresponde el valor de las propiedades.

    Person.js
        #IMPORTANTE: El argumento es un objeto con toda la info que se le pasa al componente, se puede llamar props, como se puede llamar pepito.

        const person = (props) => {
            return <p>Hola! Soy {props.name} y tengo {props.age} años! </p>
        }

    #IMPORTANTE: Cuanto se usa en una clase-componente (como app), se tiene que usar this.props

36. Understanding the Children Property
    en esta carpeta: base-syntax--01-props-custom-cmp.zip

    <div>
        <p>I'm {props.name} and I am {props.age} years old!</p>
        <p>{props.children}</p>
    </div>

    Si queremos pasar algo entre la etiqueta de apertura y cierre, tenemos que envolver eso en un elemento padre y usar children.

    <div className="App">
        <h1>Hola, soy una App React</h1>
        <Person name="Max" age="28"/>
        <Person name="Manu" age="29">My hobbies: Racing</Person>
        <Person name="Noe" age="32"/>
    </div>

37. Understanding & Using State

    <button>Cambiar de nombre</button>

    State:
        #IMPORTANTE: 
            - SOLO SE PUEDE USAR: En las clases-componentes
            - es una propiedad especial, donde se establecen y pasan props desde afuera como name, age etc, y que se gestionan dentro del componente.
                Si cambiamos algo que use esta propiedad, va a renderizar nuevamente el dom/componente.

            Se inicializa como un objeto.
                state = {}
            Se le pueden agrengar, array objetos:
                state = {
                    persons: [
                        { name: 'Noe', age: 32 },
                        { name: 'Gabu', age: 29 },
                        { name: 'Nany', age: 33 },
                    ]
                }

            Una vez que hacemos esto, la podemos usar en nuestro metodo dinamico.

            <div className="App">
            <h1>Hola, soy una App React</h1>
            <button>Cambiar de nombre</button>
            <Person name={this.state.persons[0].name} age={this.state.persons[0].age}/>
            <Person name={this.state.persons[1].name} age={this.state.persons[1].age}>My hobbies: Racing</Person>
            <Person name={this.state.persons[2].name} age={this.state.persons[2].age}/>
            </div>

        this, hace referencia a la clase donde se esta usando 
38. Props & State
    file:///C:/Users/Noe/Downloads/props-state.pdf

    props  y state  son los conceptos CORE de React. Solo props  y/o state activa React para volver a renderizar sus componentes y potencialmente actualizar el DOM en el navegador 

    Props
        props: le permite pasar datos de un componente principal (container) a un componente secundario (embebido).

    Ejemplo:
        AllPosts Component:
            const posts = () => {
                return (
                    <div>
                        <Post title="My first Post" />
                    </div>
                );
            }

        Aquí title  está la propiedad personalizada ( prop ) configurada en el Post  componente personalizado . Básicamente, replicamos el comportamiento del atributo HTML predeterminado que ya conocemos (por ejemplo, <input type="text">  le informamos al navegador acerca de cómo manejar esa entrada).

        Post Component:
            const post = ( props ) => {   
                volver ( 
                    <div>
                        <h1> { props . título } </ h1 >
                    </ div >
                );
            }

        El Post  componente recibe el props  argumento. Por supuesto, puede nombrar este argumento como desee: es la definición de su función, ¡a React no le importa! Pero React pasará un argumento a su función de componente => Un objeto, que contiene todas las propiedades que configuró <Post ... /> .
        {props.title}  luego genera dinámicamente la title  propiedad del props  objeto, que está disponible ya que configuramos la title  propiedad dentro del AllPosts  componente (ver arriba).


    State:
        Mientras props le permiten pasar datos al árbol de componentes (y, por lo tanto, desencadenar una actualización de la interfaz de usuario), el estado se usa para cambiar el componente, bueno, el estado desde dentro. Los cambios en el estado también activan una actualización de la interfaz de usuario.

    Ejemplo:
        NewPost Component:
            ¡La clase NewPost extiende el Componente { // estado solo se puede acceder en los componentes basados ​​en clase!     
            
            class NewPost extends Component { // state can only be accessed in class-based components!
                state = {
                    counter: 1
                };  
            
                render () { // Needs to be implemented in class-based components! Needs to return some JSX!
                    return (
                        <div>{this.state.counter}</div>
                    );
                }
            }

        Por supuesto, puede pasar state  a componentes funcionales, pero estos no pueden editarlo directamente.
        state  => 
            Simplemente es una propiedad de la clase de componente, debes llamarlo state, obligatoriamente. 
            Luego, puede acceder a él a través this.state  de su código JSX de clase (que devuelve en el render()  método requerido ).
            Cada vez que state  cambia, el componente se volverá a representar y reflejará el nuevo estado. 
            
            La diferencia con props es que esto sucede dentro de un mismo componente: ¡no recibe datos nuevos ( props ) de fuera!

39. Handling Events with Methods
    // en JSX es con la C mayus.
    <button onClick=>Cambiar de nombre</button>

    es buena practica ponerle al final Handler, a la función que haga de handler.

    switchNameHanlder = () => {
        console.log("click");
    }
    
    a la función no hay que ponerle los () para que no lo llame en ese mismo momento.

    <button onClick={this.switchNameHanlder}>Cambiar de nombre</button>


40. To Which Events Can You Listen?

    En la última conferencia, vimos que puedes reaccionar ante el evento onClick, pero ¿a qué otros eventos puedes escuchar? Puede encontrar una lista de eventos compatibles aquí:  https://reactjs.org/docs/events.html#supported-events

    Clipboard Events
        Event names:
            onCopy onCut onPaste
        Properties:
            DOMDataTransfer clipboardData
    
    Composition Events
        Event names:
            onCompositionEnd onCompositionStart onCompositionUpdate
        Properties:
            string data
        
    Keyboard Events
        Event names:
            onKeyDown onKeyPress onKeyUp
        
        Properties:
            boolean altKey
            number charCode
            boolean ctrlKey
            boolean getModifierState(key)
            string key
            number keyCode
            string locale
            number location
            boolean metaKey
            boolean repeat
            boolean shiftKey
            number which

    Focus Events
        Event names:
            onFocus onBlur
        
        These focus events work on all elements in the React DOM, not just form elements.

        Properties:
            DOMEventTarget relatedTarget
    
    Form Events
        Event names:
            onChange onInput onInvalid onSubmit
        
        For more information about the onChange event, see Forms.

    Mouse Events
        Event names:
            onClick onContextMenu onDoubleClick onDrag onDragEnd onDragEnter onDragExit
            onDragLeave onDragOver onDragStart onDrop onMouseDown onMouseEnter onMouseLeave
            onMouseMove onMouseOut onMouseOver onMouseUp
        
        The onMouseEnter and onMouseLeave events propagate from the element being left to the one being entered instead of ordinary bubbling and do not have a capture phase.

        Properties:
            boolean altKey
            number button
            number buttons
            number clientX
            number clientY
            boolean ctrlKey
            boolean getModifierState(key)
            boolean metaKey
            number pageX
            number pageY
            DOMEventTarget relatedTarget
            number screenX
            number screenY
            boolean shiftKey
    Selection Events
        Event names:
            onSelect
    
    Touch Events
        Event names:
            onTouchCancel onTouchEnd onTouchMove onTouchStart

        Properties: 
            boolean altKey
            DOMTouchList changedTouches
            boolean ctrlKey
            boolean getModifierState(key)
            boolean metaKey
            boolean shiftKey
            DOMTouchList targetTouches
            DOMTouchList touches
    
    UI Events
        Event names:
            onScroll
        Properties:
            number detail
            DOMAbstractView view

    Wheel Events
        Event names:
            onWheel
        Properties:
            number deltaMode
            number deltaX
            number deltaY
            number deltaZ
    
    Media Events
        Event names:
            onAbort onCanPlay onCanPlayThrough onDurationChange onEmptied onEncrypted
            onEnded onError onLoadedData onLoadedMetadata onLoadStart onPause onPlay
            onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend
            onTimeUpdate onVolumeChange onWaiting

    Image Events
        Event names:
            onLoad onError
    
    Animation Events
        Event names:
            onAnimationStart onAnimationEnd onAnimationIteration
        Properties:
            string animationName
            string pseudoElement
            float elapsedTime

    Transition Events
        Event names:
            onTransitionEnd
        Properties:
            string propertyName
            string pseudoElement
            float elapsedTime
    Other Events
        Event names:
            onToggle

41. Manipulating the State
    file:///C:/Users/Noe/Downloads/state-learning-card.pdf

    switchNameHanlder = () => {
        // No hay que mutar de esta manera (cambiar de estado), va a dar un error.
        //this.state.persons[0].name = 'Noelia';
        this.setState({
            persons: [
                { name: 'Noeñs', age: 32 },
                { name: 'Gabuns', age: 29 },
                { name: 'Nanys', age: 33 },
            ]
        )
    }

    setState:
        Esta disponible solo en clases basadas en componentes.

        Este es un método que nos permite actualizar esta propiedad state, después
        nos aseguramos de que react conozca como la actualización y react actualice el DOM.

        // Toma un objeto como argumento y fusionara (sobreescribe) eso con nuestro estado actual
        switchNameHanlder = () => {
            this.setState({
                persons: [
                    { name: 'Noels', age: 32 },
                    { name: 'Gabuns', age: 29 },
                    { name: 'Nanys', age: 33 },
                ]
            })
        }

        * Solo se pueden cambiar props y state 



42. Function Components Naming

    En la próxima conferencia, aprenderemos a administrar el estado en componentes funcionales (en lugar de componentes basados en clases).

    En caso de que esté obteniendo un error con el código que se muestra en la siguiente clase, simplemente asigne un nombre de variable en mayúscula a la variable que contiene su componente funcional.

    Ejemplo:
        Utilizar
            const App = () => {...}
            en lugar de

            const app = () => {...}

    Técnicamente, eso no es necesario, pero dependiendo de la configuración de su proyecto, el indicador incorporado (una herramienta de verificación de la calidad del código) que viene con la aplicación crear-reaccionar puede no gustarle el nombre de la variable en minúscula.

    También puede evitar esto creando proyectos con la versión correcta de react-scripts, que recomendaría para este curso de todos modos (vea el video de instalación, conferencia 26)

    create-react-app my-app --scripts-version 1.1.5

43. Using the useState() Hook for State Manipulation
    base-syntax--02-state-events.zip

    Hasta React 16.8 setState era la unica manera de manejar estados en las aplicaciones de React.

    Ahora hay una característica llamada React Hooks.

    El va a seguir enseñando la manera tradicional (clases basadas en componentes) porque en las compañias ya tienen proyectos hechos basados en esto.
    
    Si bien desde React 16.8 podemos usar componentes funcionales para todo, vamos a mantenernos en las clases basadas en componentes, por la causa que ya se menciono.

    Esta nueva forma en que estamos usando "react hooks" es totalmente opcional y ni siquiera está seguro de si esto será
    la forma principal de crear componentes en el futuro y, por lo tanto, en este curso, simplemente aprenderá ambos 
    y usaremos esta forma de tableta aquí, que es la forma predeterminada de crear componentes y reaccionar y

    "react hooks"  
        Es una colección de funciones expuestas por React para que puedas en componentes funcionales y demás.
        y por lo tanto tendrá que convertir este componente aquí en uno funcional.

        Cambia el componente app por uno funcional o sea, 

        const app = props => {
            useState({
                mete el array de persons
            });

            return() { JSX } 
        }

        Este es un componente funcional normal, pero ahora puede usar la función de "react hooks" o una de las funciones de React.

        UseState devuelve una matriz con exactamente dos elementos y siempre dos elementos que son importantes.
        const [ currentState, updateCurrentState ] = useState({

        }

        Así que podemos almacenarlo está en, digamos, una constante de matriz de estado.
        Ahora el primer elemento que recibimos siempre será nuestro estado actual.
        Así que inicialmente ese objeto y cada vez que lo cambiemos.
        Bueno, el estado actualizado del segundo elemento en la matriz de estado siempre será una función que nos permita actualice este estado para que reaccione lo sepa y volverá a procesar este componente, que por supuesto es.
        La idea y que es lo que también sucede con este estado y los componentes basados ​​en clase, por lo que también podemos
        Use una función javascript más moderna llamada estructuración de radio que funciona agregando corchetes
        en el lado izquierdo del signo igual aquí y esto le permite extraer elementos de la matriz que obtiene
        atrás desde el lado derecho del lado igual.
        Así que fuera de esta función llamada.
        Así que aquí puede dar a estos elementos el nombre que desee y, por lo tanto, nombraré el primero aquí.
        Estado de la persona, por ejemplo, de nuevo.
        Ese nombre depende totalmente de ti.
        Y el segundo elemento será una función que le permitirá establecer ese estado para que la identificación del nombre establezca las personas con las que
        También se puede nombrar dicho estado de persona lo que quieras.
        Así que tal vez establezcamos el estado de la persona para que quede realmente claro qué hace esto.
        Así que ahora tenemos estas dos cosas que las personas en el estado le dan acceso a este objeto.
        Así que ofrecen en todos los lugares donde anteriormente utilizamos este estado, ahora reemplazamos este estado y todos
        Estos lugares con estado de personas porque este estado ya no existe.
        Solo existe en componentes de React basados ​​en clase y no tenemos ningún componente de React basado en clase aquí
        nunca más.

        Es un componente funcional.
        Entonces, este acceso es el estado de la persona del conjunto de datos de la persona que nos permite establecer un nuevo estado y para esto
        Se puede volver a agregar un controlador de nombre de interruptor muerto a nuestro componente.
        Pero, ¿cómo agregamos un método como era antes a un componente funcional mientras resulta que puede tener?
        Funciones dentro de funciones no solo en reaccionar sino en JavaScript en general.
        Y estamos aquí podemos agregar una nueva función almacenada en una constante tal vez, que es mi antiguo controlador de nombre de switch
        Acabo de copiar ese código.
        Así que ahora tengo esa constante de controlador de nombre de switch que contiene este código de función aquí y esto es perfectamente
        El código de javascript fino puede tener una definición de función dentro de todas las funciones parece extraño y normalmente
        no lo use con demasiada frecuencia, pero para los ganchos de React lo usa y está bien porque ahora tiene un funcional
        componente que puede administrar el estado y que puede tener otras funciones que hacen algo, por ejemplo, en
        un clic
        Y eso es exactamente lo que hago aquí en clic.
        Anteriormente llamamos a este conmutador de nombre de controlador.
        Bueno, esta palabra clave ahora es incorrecta porque ya no estamos dentro de una clase.
        En su lugar, es solo un conmutador de nombre de conmutador que se refiere a esta constante aquí sin paréntesis porque
        No quiero ejecutarlo inmediatamente, solo se produce un clic en Windows y esta función se ejecutará
        y ahora ya no llamaremos el estado de configuración porque esta función tampoco existe más.
        En lugar de este estado triste, ahora solo se establece el estado de la persona a la que pasamos nuestro nuevo objeto de estado en su.
        Y con eso, si lo guarda con sus servidores de desarrollo aún en funcionamiento, esta es la aplicación y
        esto todavía se ve bien.
        Lo que ya significa que el estado de uso generalmente funciona, de lo contrario no sería posible extraer datos de
        El estado de nuestra persona ahí abajo.
        Así que si ahora presiona el nombre del interruptor, mira a Max, aquí está Maximilian.
        Así que extraiga el estado y actualice el estado y vuelva a renderizar el componente en un estado cambiar todo
        trabajos.

        Hay una diferencia importante en el estado en un componente basado en clase, aunque generalmente se ve
        como funciona igual pero no me permite controlar el estado de la persona de registro aquí para que podamos ver lo que hay
        dentro.
        Si los dispositivos de seguridad hacen recargas de aplicaciones.
        Así que aquí tenemos a Max y Maximilian, y esto es lo que está en nuestro estado correcto.
        Es un objeto con un estado obvio porque estamos configurando esto también para demostrar que esto no funciona.
        se sobrescribe y las personas si hace clic en el nombre que recibimos el estado de las noticias y no se encuentra en nuestro estado
        y eso es súper importante cuando usas ganchos de React.
        Tu función aquí que obtienes como segundo elemento y esa matriz no fusiona lo que pasas
        A ello con el viejo estado.
        En su lugar, reemplaza el viejo estado con él.
        Y esto es muy importante porque esto significa que cada vez que actualice un estado como este
        Tienes que asegurarte manualmente de incluir todos los datos del estado antiguo.
        Aquí, por ejemplo, agregando manualmente la propiedad del estado promedio y luego tiene que acceder a la persona
        Indique aquí y acceda a nuestro estado y esto solo se asegurará de que copiemos en el antiguo.
        En este caso, intacto nuestro estado, por supuesto, también podría cambiarlo aquí.
        Y cuando lo esté haciendo ahora, si hace clic en cambiar nombre, nuestro estado todavía está allí.
        Esta es una forma de hacerlo, pero la forma más elegante es no fusionar manualmente sus estados.
        pero en su lugar use use state varias veces, mientras que en los componentes basados ​​en clase solo tiene una propiedad de estado
        y este estado establecido fusiona automáticamente los cambios con el estado anterior.
        Para no descartar ningún estado aquí, no puede tener llamadas de estado de uso múltiple.
        Así que podemos llamar.
        Utilice el estado de nuevo y allí, si quisiéramos administrar nuestro estado promedio, podríamos pasar un poco más de nuestra cuenta.
        de nuestro objeto de valor aquí o si lo único que queremos gestionar es una cadena.
        También podríamos simplemente pasarle esa cadena como un valor predeterminado.
        No tiene que ser un objeto.
        Podría ser un objeto como está aquí.
        También podría ser solo una cadena, un número, una matriz, un booleano, independientemente de lo que su aplicación necesite y pueda tener.
        tantas llamadas estatales de los Estados Unidos como desee.

        Y ahora estamos siempre en un estado de registro de mi persona y luego aquí también extraigo eso en dos variables con el
        Ayuda de la desestructuración de matrices que podría ser mi otro estado y establecer nuestro estado.
        Así que ahora, las personas de derecho civil, el estado y otros estados, y nunca uso el set set our state porque no quiero
        para configurarlo en cualquier lugar.
        Ahora, si inicia sesión aquí con Q, utilice las llamadas de estado en la aplicación que ve inicialmente, tenemos a nuestra persona
        Estado que todavía tiene su propio estado promedio, así que eliminemos eso.
        Así que de nuevo cargamos.
        Así que ahora tenemos el estado de la persona que es igual de objeto y luego tenemos nuestro otro estado aquí
        algun otro valor
        Y si cambio de nombre, actualizamos a las personas y todavía tenemos otro valor porque ese estado no es
        tocado por nuestro llamado a establecer el estado de las personas que solo interactúa con el resultado del primer estado de uso.
        Por lo tanto, los estados de uso múltiple con diferentes secciones de estado
        Así que para decir así es como gestionó el estado y un componente funcional en el que reaccionan los ganchos.
        No tienes un objeto de estado grande, aunque puedes y puedes combinarlo manualmente si lo prefieres
        pero en su lugar, tiene varios segmentos de estado separados.
        Este es el gancho de estado de uso y este es un vistazo a los ganchos de React en general y este es el más importante.
        reaccionar gancho.

        Para resumir, los ganchos de React se trata de usar algo que funciona con el estado de los EE. UU.
        Importante que le permite agregar funcionalidad a los componentes funcionales, como aquí el estado de uso nos permite
        Para agregar la gestión del estado a los componentes funcionales.
        Así que si usted está utilizando los ganchos de React solamente.
        Y nuevamente les enseñaré todos estos ganchos importantes a lo largo de este curso.
        No es necesario que uses componentes basados ​​en clases como lo mencioné en este curso.
        Usaré componentes basados ​​en clases porque esa es la manera establecida.
        Esta es la forma en que lo necesitará en cualquier trabajo que esté comenzando.
        Y, por lo tanto, si quieres convertirte en un ayudante reactivo, tienes que saber ese nombre.
        Aún así, todo lo que se aprende es reaccionar sintaxis de gancho en el camino y volver a mencionarlo.
        Hay dos módulos completos hacia el final de este curso donde, en un módulo, paso por todos
        Los reactivos importantes para que los tenga todos en un lugar y en el otro módulo.
        Tomaré ese proyecto de React, este proyecto completo del curso eventualmente se construirá en este curso y se convertirá
        esto es para usar solo el reactor X para que esté bien preparado para cualquier proyecto en el que esté realizando una inmersión.
        Así que esta fue una buena excursión aquí adjunta, encuentra un retroceso al enfoque basado en la clase y también
        Encuentra este código aquí para que tengas esto como referencia.
        Pero retroceda ese enfoque basado en clase para continuar porque ese es el enfoque con el que
        continuaremos para este curso y los usaremos para todos en este curso.

44. Stateless vs Stateful
    
    Functional (Stateless) vs class (Stateful) Components
    La mayoria de las veces vamos a usar funciones stateless, las que reciben props.
    
    La mayor parte de la app, no debería cambiar el estado de la aplicación, se supone que solo va a cambiar en ciertos componentes,
        conocidos como "contenedores" Statefull Components. ej app.js
    
45. Passing Method References Between Components
    base-syntax--02-state-events.zip

    en el padre, al hijo embebido, le generamos un atributo donde le podemos pasar un metodo, entonces en el archivo del hijo, usando prop podemos utilizarlo.

    o sea, el hijo termina usando un metodo que esta en el padre.

    Si necesitamos pasar parametros hay que usar bind.
    
    this.metodo.bind(this, param)
    
    si en vez de usar esa manera, usamos una funcion de flecha anonima, tenemos que tener en cuenta que cuando escribimos la función en una linea:
        onClick={() => this.metodo()}

        adelante del this, si bien no lo pone, hay un RETURN.

    Idealmente es mejor usar bind, porque la función anonima es ineficiente.


46. Adding Two Way Binding

    En el padre, generamos el metodo qu eva a cambiar el nombre, recibe un event como parametro.

    dentro del elemento hijo, agregamos un parametro onChange, para pasarle a ese componente ese metodo, y usamos props.change (que es el atributo donde pusimos el metodo.)


47. Adding Styling with Stylesheets

    hay que poner un archivo .css en la misma carpeta que el componente e importarlo en el componente.js 


48. Working with Inline Styles
    
    Para usar inline styles, se usa javascript en camelCase, ej lo que en css es background-color, aca es backgroundColor o marginLeft, etc.. en el JSX se usa 
    
    <a style={style}
    
    Tarea 1: Time to Practice - The Base Syntax

49. [OPTIONAL] Assignment Solution

    base-syntax--01-props-custom-cmp.zip
    base-syntax--02-state-events.zip
    base-syntax--03-finished.zip
    base-syntax--assignment-solution.zip

    Solución de la tarea.

50. Useful Resources & Links

    create-react-app: https://github.com/facebookincubator/create-react-app
    Introducing JSX: https://reactjs.org/docs/introducing-jsx.html
    Rendering Elements: https://reactjs.org/docs/rendering-elements.html
    Components & Props: https://reactjs.org/docs/components-and-props.html
    Listenable Events: https://reactjs.org/docs/events.html
    Recursos de esta clase
    base-syntax--01-props-custom-cmp.zip
    base-syntax--02-state-events.zip
    base-syntax--03-finished.zip
    base-syntax--assignment-solution.zip

###  Sección 4: Working with Lists and Conditionals

51. Module Introduction
52. Rendering Content Conditionally

    envolver un elemento con { para poder escribir javascript }
    por ejemplo para mostrar o dejar de mostrar un div.

    IMPORTANTE: Hay que usar el operador ternario

    ej:
    { this.showParrafo ?
        <p>hola</p>
      :
      null 
    }

    significa que o muestro o el parro o no muestro (renderizo nada)


53. Handling Dynamic Content "The JavaScript Way"

    Dentro de render, antes de retornar algo, podemos poner variables javascript, ya que ahí podemos usar js normalmente.

54. Outputting Lists (Intro)
55. Outputting Lists
56. Lists & State
57. Updating State Immutably
58. Lists & Keys
59. Flexible Lists
60. Wrap Up
    Tarea 2: Time to Practice - Lists & Conditionals

61. [OPTIONAL] Assignment Solution
62. Useful Resources & Links

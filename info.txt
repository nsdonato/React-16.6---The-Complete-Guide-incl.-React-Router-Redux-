# TEORIA #: Un concepto puntual que deberíamos saber.
# IMPORTANTE #: Algo a tener en cuenta, muy particular sobre el lenguaje.

### SECCION 1 ##

    1. Introduction
    2. What is React?

        Que, como y porque:
        # TEORIA #
            Una /libreria de JavaScript/ para crear interfaces de usuario (Componentes)

            - Basicamente, se crean aplicaciones Javascript, que corren en el navegador, no corren en el servidor. No tenemos que esperar una respuesta del servidor para obtener una nueva página o para renderizar algo nuevo.

            - User interface: Interfaz de usuario, es lo que el usuario puede ver. Con React construimos componentes, para la interfaz de usuario, que a su vez, se pueden reutilizar.

    3. Join our Online Learning Community

        As a student of this course you also get free access to our "Academind Community" on Discord: https://discord.gg/gxvEWGU

        There, you can find like-minded people, discuss issues, help each other, share progress, successes and ideas and simply have a good time!

        I believe that you learn the most if you don't learn alone but find learning partners and other people with similar interests. Our community is a great place for this - it's the perfect complimentary resource for this course.

        Joining it is of course free and 100% optional.

    4. Real-World SPAs & React Web Apps

        Adding the Right React Version to Codepen

        In the next lecture, we'll write our first React code in Codepen, an online editor (it's only getting used in the next lecture).
        Currently, there seems to be a bug if you add React as shown in the next video.
        To fix it, replace the automatically added import paths (you'll see what I mean) with these:
            https://cdnjs.cloudflare.com/ajax/libs/react/15.6.1/react.min.js 
            https://cdnjs.cloudflare.com/ajax/libs/react/15.6.1/react-dom.min.js 
        This should fix. And don't worry about the React version, the entire rest of the course uses 16+ :)

    5. Writing our First React Code
        
        Crear una aplicación en Codepen.
            Cuando se repite un elemento pero tiene diferente información adentro, esto ya se puede entender como un componente.

        - Importar React:
            https://cdnjs.cloudflare.com/ajax/libs/react/15.6.1/react.min.js 

        - Importar React DOM, la logica para crear los componentes en el DOM real.
            https://cdnjs.cloudflare.com/ajax/libs/react/15.6.1/react-dom.min.js 

        - Para utilizar las últimas caracteristicas de React --> Babel

        // Tiene que comenzar con mayuscula para que funcione bien.
        function Person(){
            return (
                <div className="person">
                    <h1>Max</h1>
                    <p>Your Age: 28</p>
                </div>
            );// Sintaxis JSX, para renderizar el DOM.
        }

        ReactDOM.render(<Person />, document.querySelector('#p1')); 

        # TEORIA # 
        El metodo RENDER nos permite representar una función de JavaScript como componente del DOM real, y tratarlo como un componente.

        // le decimos que renderice como html ese objeto Person.
        // le decimos en donde queremos que se vea ese componente.

        * El atributo class en el codigo html se tienen que escribir className, porque React renderiza ese html como un componente JavaScript (que es donde se usa la propiedad className)

        // Le agrega un argumento que es propio de react
        
        # TEORIA #  
        Los datos dinamicos se encierran entre { }
        
        function Person(props){
            return (
                <div className="person">
                    <h1>{props.name}</h1>
                    <p>{props.age}</p>
                </div>
            );// Sintaxis JSX, para renderizar el DOM.
        }

        ReactDOM.render(<Person name="Max" age="28"/>, document.querySelector('#p1')); 
        ReactDOM.render(<Person name="Manu" age="29"/>, document.querySelector('#p2')); 

        En vez tener un elemento div con la clase p1, ahora solo vamos a tener uno con id Apps
        
        HTML:
            <div id="app"></div>

        JS:
            function Person(props){
                return (
                    <div className="person">
                        <h1>{props.name}</h1>
                        <p>{props.age}</p>
                    </div>
                );// Sintaxis JSX, para renderizar el DOM.
            }

            var app = (
                <div>
                    <Person name="Max" age="28" />
                    <Person name="Manu" age="29" />
                </div>
            );

        // En vez de tener dos elementos, tengo uno solo que tenga los 2.
        ReactDOM.render(<app/>, document.querySelector('#app')); 

        * Este es el mejor modo para crear SAP. Single Page Applications.

    6. Why should we choose react?

        Porque en aplicaciones grandes es dificil de manejar el ESTADO.
        Porque cambiar elementos de lugar es mas engorroso, aparte de acomodarlos en pantalla, dependiendo si usaste getQuerySelector o JQuery esto se complica mucho.
        
        React nos permite enfocarnos en nuestra logica de negocios, envitando que nuestra app explote.
        Supuestamente como React tiene una comunidad zarpada, el codigo es excelente.
        Aparte de tener un gran ecosistema, comunidad activa y alta performance.

    7. React alternatives.

        Angular y Vue.js
            Te sirve para enforcarte en la logica y en el modelo de negocio, y no tanto en el aspecto del elemento en particular que        querías cambiar (como en react)

    8. Understanding Single Page Applications and Multi Page Applications.

        SAP:
            Solo recuperamos un solo archivo html, el contenido es renderizado en el cliente.
            Esta construidda por componentes, y cada componente es un componente React, también es mantenida por un componente root de React, que esta bajo el control de React.
            Tipicalmente tenemos una llamada reactDOM.render(), se necesita una sola porque tenemos un componente raiz, que esta montado en el DOM que tiene todo el resto de componentes.

        MPA:
            Recuperamos varias paginas determinadas, donde cada pagina tiene el contenido para una ruta determinada, y el contenido es renderizado en el servidor.
            Algunas partes de la pagina son componentes React.
            Los widgets individuales no conocen la existencia de otros.
            Vamos a tener varios reactDOM.render para los diferentes componentes, en difernetes lugares de la app.

    9. Course outline.

        Getting started.
            Usar JavaScript moderno porque mantiene limpio y es un estandar para react, funciones de flechas, etc.
        
        React basics.
            Como crear componentes reacts, ver las diferentes maneras que hay de hacerlo y como comunicarse entre componentes.
            Como podemos generar listas, o como podemos presentar contenido de forma condicional.

        Debug
            Como debuggear react.

        Styling componentes 
            Como darle estilo a los componentes y como podemos asegurarnos de que el estilo que aplicamos a un componente, solo se aplique a ese componente y no a todos.

        Componentes Deep Dive
            Pronfudización en los componentes, ya que tendremos mucho conocimiento de ellos, vamos a aprender cual es su ciclo de vida.
            Como comprobar actualizaciones a menudo o no.

        HTTP Request
            Como conectarla con el mundo exterior, como obtener datos de un servidor o subirlos al servidor.

        Routing.
            Es una caracteristica del Core de las SAP, porque con routing, podemos manejar diferentes urls, /productos /usuarios  diferentes paginas, aunque tengamos un solo HTML, y en realidad
            lo que hacemos es analizar la url y renderizar las diferentes partes que necesitamos, para mostrar "una nueva pagina".
        
        Forms and validation.
            validación de entrada de datos de los usuarios, etc.

        Redux
            es una biblioteca de terceros pero se usa muchisimo con react.
            acciones asincronas, etc.

        Authentication
            login de usuario.

        Testing
            Introducción a como probar app de react.

        Deployment
            Como publicar en producción

        Bonus: aplicaciones de react animadas, ubicación de reactores, webpack, etc.
            NextJs, una libreria construida bajo react, donde construimos nuestro propio flujo de trabajo, etc.
        
    10. How to get the Most out of This Course

        Como sacarle provecho al curso:
            Codificar solo.
            Si algo no funciona, chequear contra su codigo.
            Si estas atascado, usar lar parte donde se hacen las preguntas, primero buscar porque seguro alguien ya pregunto.
            Practicar.

    11. Useful Resources & Links

        Documentación de React: https://reactjs.org/
        El codepen, hecho por él: https://codepen.io/anon/pen/MELQaQ

### Sección: 2 - Refreshing Next Generation JavaScript (Optional) ###

    12. Module Introduction
        Next-Gen Javascript, para refrescar. React usa esto, así que, hay que saberlo.

    13. Understanding "let" and "const" - # TEORIA #

        let = var (cambia el tema del scope, porque ahora es de bloque.)
        const = para info que no va a cambiar.

    14. Arrow Functions - # TEORIA #

        funciones antes:
            function myFuncion() {
                ...
            } 

        funciones ahora:
            const myFuncion = () => {
                ...
            }

        * Arrow functions, mejoran el problema de que this, no siempre apuntaba al contexto de ejecución, sino al objeto global.
        * Si no tiene parametros, va solo parentesis
        * Si tiene uno, es param => 
        * Si tiene mas de uno, es (param1,param2) =>
        * Si la parte de retorno solo tiene una linea, se puede escribir así: const multiplicar = number => number * 2;

    15. Exports and Imports - # TEORIA #

        Para modular el código, para dividir los archivos js en varios archivos.
            Si bien ya se puede (porque agregas diferentes archivos en el html, de manera ordenada)
            Lo que pasa ahora es que desde un js, se puede usar info de otro js.

        EXPORTAR
            person.js
                const person = {
                    name: 'Max'
                } 
                export default person

                // export: sirve para exportar esa función, objeto, etc, desde un archivo.
                // default: que esa funcion, obj, etc, va a ser la predeterminada.
                // person: en este caso es el objeto 

            utility.js
                export const clean = () => { ... }
                export const baseData = 10;

        IMPORTAR
            app.js
                // Se pone de alguna de las dos maneras, ya que hace referencia a lo único que se exporto (default)

                    import person from './person.js' 
                    import prs from './person.js'   

                // Al ser exportada como diferentes constantes, se usa las { }  para "mejorar el codigo", diciendo que se esta exportando algo especifico
                // Tiene que respetar el nombre que se le puso en el archivo donde se la exporta obj
                // se puede ponerle un alias, como en la segunda linea

                    import { baseData } from './utility.js' 
                    import { baseData as bd } from './utility.js' 

                // También se podría hacer de esta manera.

                    import { baseData, clean } from './utility.js' 

    16. Understanding Classes - # TEORIA #

        - Los metodos son como: funciones atachados a esa clase/objetos,
        - las propiedades son como: variables, atachadas a esa clase/objetos,

        class Human {
            constructor(){
                this.gender = 'male';
            }

            printGender(){
                consoe.log(this.gender);
            }
        }

        // Herencia
        class Person extends Human{
            constructor(){
                super();
                this.name = 'Max';
                this.gender = 'female'; // pero no es correcto usar así.
            }
            
            printMyname (){
                console.log(this.name);
            }
        }

        // Instanciar un objeto de esa clase.
        const miPersona = new Person();
        miPersona.printMyname();
        miPersona.printGender();    

    17. Classes, Properties and Methods - # TEORIA #

        ES6
        Propiedades:
            constructor() {
                this.myProperty = 'value'
            }

        Metodos:
            miMetodo () {
                ...
            }

        ES7
        Propiedades:
            myProperty = 'value'; // Si, no hay un "constructor" en si.

        Metodos:
            miMetodo = () => {
                ...
            }
            
        * Es mejor usar ambos opciones de ES7, para esto si o si hay que usar ES6/Babel, que transpila el código y lo convierte.

    18. The Spread & Rest Operator - # TEORIA #

        // Operator Spread o Rest (depende de donde se use)
        ...

        Spread: (división de las propiedades de un objeto o un array.)

                Se usa para dividir elementos de un array o propiedades de un objeto.
                Por ejemplo, si tenemos una matriz antigua y queremos agregar todos los elementos de esa matriz anterior a una nueva matriz y,
                además, agregar un 1 en un elemento dos, este primer índice sería lo que tenía tres puntos delante
                de toda la matriz. simplemente extraiga todos los elementos y agregue a la nueva matriz que
                creamos con corchetes.

                // Idem object pero array
                    const oldArray = [3,4,5];
                    const newArray = [...oldArray,1,2];
                    console.log(newArray);
                    // 3,4,5,1,2

                // Lo probé, lo que hace es agarrar las propiedades/funciones del objeto viejo, y ponerselo al nuevo y suma la nueva prop/func.
                const oldObject = {
                    name: "Noe";
                }

                const newObject = { ...oldObject, newProp: 5 }
                console.log(newO)

        Rest: (Fusión de elementos en un array)
            
            Se utiliza con menos frecuencia.

            Se usa para mergear una lista de argumentos de funciones en una matriz.
            O sea, lo usamos en el parametro de una función. ej:

            // Recibe una lista ilimitada de argumentos, y todos se fusionan en un array.
            // O sea, en vez de dividir, los une.

            function sortArgs(...args){
                return args.sort[]; 
            }

            sortArgs(1,2,3,4,5);
        
        * Hay que tener en cuenta que si el numero o propiedad / funcion, ya existia en el objeto actual, lo sobreescribe.
        
        array.filter()  // ejecuta una función en cada elemento de la matriz y se verifica si existe un elemento en ella, ej:
        const filter = (...args) => {
            return args.filter(el => el === 1);
        }

        console.log(filter(1,2,3));
        // [1]

    19. Destructuring - # TEORIA #

        Permite extraer facilmente elementos de una matriz o propiedades de objetos y guardarlos en variables.
        ej:

        array:
            [nombre, apellido] = ['Noe','Donato'];
            console.log(nombre); // Noe
            console.log(apellido); // Donato

            const numbers = [1,2,3];
            [num1, num2] = numbers;
            console.log(num1,num2); // 1 2

            [num1, ,num3] = numbers;
            console.log(num1,num3); // 1 3

        object:
            { name } = { name: 'Noe', age: '32' };
            console.log(name); // Noe
            console.log(age); // undefined

    20. Reference and Primitive Types Refresher - # TEORIA #

        Primitivos
        * Copia el valor de su variable en otra, osea hay 2.
        number, boolean, string

        Referencia
        * No copia, sino que hace referencia al puntero en memoria del otro objeto.
        Object, arrays.

            const person = {
                name: 'Max'
            };
            const secPerson = person;
            person.name = 'Manu';

            console.log(secPerson); // 'Manu'

        Para copiar un objeto, o sea generar uno nuevo, deberíamoshacer:
            const person = {
                name: 'Max'
            };
            const secPerson = {
                ...person
            };
            person.name = 'Manu';

            console.log(secPerson); // 'Max'

    21. Refreshing Array Functions - # TEORIA #

        const numbers = [1,2,3];

        // La función se va a ejecutar por cada elemento
        // Al parametro le ponemos num, porque esta recorriendo numeros, como para ser claros.
        const numbers = [1,2,3];
        const doubleNumArray = numbers.map((num) => num * 2 );
        console.log(doubleNumArray); // [2,4,6]

    22. Wrap Up

        Basicamente que cualquier cosa, se puede volver a esas clases para refrescar por si te olvidaste algo.

    23. Next-Gen JavaScript - Summary
    24. JS Array Functions

        En realidad, no la próxima generación de JavaScript, pero también es importante: un arreglo de funciones de JavaScript, como map() , filter() , reduce()  etc.
        Me verás usarlos bastante ya que muchos conceptos de React se basan en trabajar con arreglos (de manera inmutable).

        La siguiente página ofrece una buena descripción general de los diversos métodos que puede utilizar en el prototipo de matriz. No dude en hacer clic en ellos y actualizar sus conocimientos según sea necesario:  
            https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array
            
        Particularmente importantes en este curso son:

        map()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
        find()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
        findIndex()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
        filter()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
        reduce()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce?v=b
        concat()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat?v=b
        slice()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice
        splice()  =>  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice

### Sección 3 - Understanding the Base Features & Syntax ###

    25. Module Introduction

        Que es, como usarlo, nuestra primera app react, conceptos generales, sintaxis basicas, etc.

    26. The Build Workflow 

        Recomendado para SPA y MPAs

        Porque?     
                - Optimización de codigo en grandes apps, para tener también el menor codigo postible, considerando el peso de las app también.

                - Usar nex-gen JS. Mejoramos como desarrolladores, y funcionan mejor las app, porque basicamente usar esto es "comprometerse con las mejores practicas"
                    Como no en todos los browsers se soporta esto, se debe usar un flujo de trabajo diferente, para poder compilar next-gen javascript y usarlo.

                - Ser mas productivo. 
                    Incluir, auto-prefixing de CSS. 
                    Linting: una herramienta que te dice si estas escribiendo mal codigo o podes hacer mas optimo algún codigo especifico.
        
        Como?       
                - Gestor de dependencias: npm o yarn (3ty parth libraries)
                - Bundler "Controlador", recomendado: webpack
                    Para escribir codigo modular, para tener una tarea/enfoque claro y nos resulte mas facil de mantener y administrar.
                - Compilador (para next-gen), recomendado: Babel + presets
                - Un Web Server de desarrollo. 
                
        * Nos va a enseñar una herramienta de desarrollo que hace todo esto menos engorroso y no tenemos qe andar configurando todo, es una herramienta que generó el equipo de React de facebook.
        * En otro modulo enseña como hacer una desde 0 igual.

    27. Using Create React App
        Es la herramienta recomendada para crear proyectos de React. "Create React App"

        - Instalar Node JS.
        # IMPORTANTE: npm install -g create-react-app ESTA DEPRECADO.

        > npm create-react-app react-guia-completa // El segundo parametro es el nombre de la app.
        > cd react-guia-completa
        > npm start

    28. Understanding the Folder Structure
        
        package.json
            Donde estan las dependencias y los diferentes scripts que podemos ejecutar para correr diferentes tareas. Dependencias productivas y de desarrollo.

        node_modules
            Donde estan las dependencias de cada paquete, y los paquetes en si de Node.
        
        public
            Es la carpeta raiz, donde van a estar todos los archivos que se le sirven al cliente.
            
            index.html 
                Es la única que tenemos y la única que vamos a tener. NUNCA TENEMOS QUE AGREGAR PAGINAS.
                Si es una MPA (Multi Page Application), el Workflow va a tener que ser diferente.
                Si queremos agregar otro css, va ahí.
                No metamos html dentro del html
            
            manifest.json
                Nos brinda una aplicación web progresiva, lista para usar.

        scr
            Ahí van los archivos que podemos editar.

            index.js
                obtiene acceso al elemento raiz de nuestro DOM del arch html, para que dentro del elemento con id="root" se renderice nuestra aplicación react.
            
            App.js 
                Actualmente ahí tenemos nuestro primer componente.
        
            registerServiceWorker.js (En la ultima versión no esta este archivo, esta: serviceWorker)
                Es importante para registrar un service worker, que es generado automaticamente, relacionado a la PWA
                Basicamente, pre-cachea los archivos scripts.

            App.test.js
                Nos permite crear pruebas unitarias para los diferentes componentes en nuestra app.

        - Eliminar el logo de react.svg y la linea que importa el logo.
        - Eliminar del archivo css, todo menos la parte de .App
        
    29. Understanding Component Basics
        index.js
            import React from 'react';
            import ReactDOM from 'react-dom';
            import './index.css';
            import App from './App';
            import * as serviceWorker from './serviceWorker';

            // Siempre vamos a tener un elemento donde van a estar todos los componentes
            // y que lo vamos a renderizar en un id x ej root. # TEORIA #
            ReactDOM.render(<App />, document.getElementById('root'));

        app.js
            import React, { Component } from 'react';
            import './App.css';

            class App extends Component {
                render() {
                    return (
                        <div className="App">
                            <h1>Hola, soy una App React</h1>
                        </div>
                    );
                }
            }

            export default App;

        - Para definir un componente, hay 2 maneras.
            1) 
                1.1) Creamos una clase y lo hacemos heredar de Component, 
                    
                    que se importa de la libreria de react.
                    React, se importa porque es necesario para renderizar el componente y el objeto componente.
                
                1.2) el metodo render() 
                        sirve para renderizar JSX en la pantalla.

            2)
        - 

        # TEORIA #
        * Por lo general cuando se elige el nombre de un componente, se usa ese nombre para la variable a importar, para el archivo y para el elemento.
        * Los archivos también podrían llamarse JSX, pero se usa js por convención.
            JSX en realidad es lo que llaman "syntactic sugar". Es una sintaxis dentro de un lenguaje de programación, diseñado para ser mas facil de leer o expresarse.
            Es como "mas dulce para que lo pueda usar una persona"

    30. Understanding JSX

        Componente basado en clase:
        class App extends Component {
            render() {
                // Podemos usar el objeto de React para crear un elemento.
                // createElement, toma infinitos argumentos, pero el primero es o un elemento o un componente.
                // 2 arg: puede ser un objeto, aunque es opcional, por lo tanto pasamos null
                // 3 arg, los hijos: a partir de ese, van separados por comas, y basicamente s todo lo que va a ir, adentro del primer arg, el div en este caso.
                    1 linea: como el comportamiento por default es tomar todo por texto, va a imprimir en pantalla, h1Iamreactapp, 
                    2 lines: así que hay que usar otro react.createelement...
                    3 linea: Para pasarle estilo

                //return React.createElement('div', null, 'h1','I\'m a React App!!!!');
                //return React.createElement('div', null, React.createElement('h1',null,'I\'m a React App!!!!'));
                return React.createElement('div', { className: 'App'}, React.createElement('h1',null,'I\'m a React App!!!!'));

            }
        }

        * NO SE USA CREAR LOS ELEMENTOS ASÍ, es para que sepamos que existe esto y no es lo correcto.
        Para eso se genera el "HTML, que en realidad es JSX" = javascript.

    31. JSX Restrictions

        # IMPORTANTE #:
        
        - Como en realidad el html que vemos es JSX, no podemos usar palabras reservadas como class, debemos en este caso, por ej usar className, en el elemento.
        
        - No podemos devolver elementos que no tienen un padre. Por ej, no podemos poner un elemento hermano al div root.
       
        - Es buena practica, es meter todo dentro de un contenedor a devolver.

    32. Creating a Functional Component

        # IMPORTANTE #

        vamos a crear un componente:
            src/
                Person/
                    Person.js
            Por convención el nombre comienza con mayus.
            Por convención las funciones van en minuscula.
        
        La gran mayor cantidad de tiempo los componentes se crean como el de app, pero por lo general son solo funciones.
        
        Para crear un componente entonces (que no derive de Component): 
            Generamos una función.
            La exportamos como default.
            Retornamos JSX

        Para usar en nuestro component App:
            Importamos el componente.
            Dentro del html que estamos retornando, agregamos el tag con nuestro componente.

        <Person /> // lo podemos dejar así ya que no tenemos que anidar nada adentro.

    33. Components & JSX Cheat Sheet
        Descargar pdf o file:///C:/Users/Noe/Downloads/components.Pronfudización

        Los componentes son el componente básico de las aplicaciones React . En realidad, React realmente es solo una biblioteca para crear componentes en su núcleo.

        Por lo tanto, una aplicación React típica podría representarse como un árbol de componentes : tiene un componente raíz ("Aplicación") y luego una cantidad potencialmente infinita de componentes secundarios anidados.
        Cada componente debe devolver / generar algún  código JSX ; define qué código HTML React debe procesar al DOM real al final.
        JSX NO es HTML pero se parece mucho a eso. Sin embargo, se pueden ver las diferencias cuando se mira de cerca (por ejemplo, className en JSX vs class en "HTML normal"). JSX es solo azúcar sintáctica para JavaScript, lo que le permite escribir código HTML en lugar de llamadas React.createElement (...) anidadas.
        
        Al crear componentes, puede elegir entre dos formas diferentes:
            Componentes funcionales (también conocidos como componentes de "presentación", "tontos" o "sin estado"; más información sobre esto más adelante en el curso) =>  
                const cmp = () => {
                    return <div>some JSX</div> 
                } 
                (se recomienda usar las funciones de flecha de ES6 como se muestra aquí, pero es opcional)

            Componentes basados ​​en clase (también conocidos como componentes "contenedores", "inteligentes" o "con estado") => 
                class Cmp extends Component { 
                        render () { 
                            return <div>some JSX</div> 
                            } 
                } 
        
        Por supuesto, nos sumergiremos en la diferencia a lo largo de este curso. Ya puede notar que debe usar 1) con la mayor frecuencia posible. Es la mejor práctica.

    34. Working with Components & Re-Using Them

        Trabajar componentes en archivos separados, hace que el codigo sea mas mantenible.
        Aparte se lo puede configurar y reutilizar.
        return (
            <div className="App">
            <h1>Hola, soy una App React</h1>
            <Person />
            <Person />
            <Person />
            </div>
        ); 

        * Esto no es dinamico, así que en el proximo vamos a ver como hacerlo..

    35. Outputting Dynamic Content

        # IMPORTANTE #
        Para que el js, no sea interpretada como texto, se debe usar {js que quiera}

            return <p>Soy una persona and I am {Math.floor(Math.random() * 30)} years old! </p>

        Esto se usa para simples calculos o llamadas a funciones, pero nada mas, debería ser solo una linea de codigo

    36. Working with Props

        return (
            <div className="App">
            <h1>Hola, soy una App React</h1>
            <Person name="Max" age="28"/>
            <Person name="Manu" age="29"/>
            <Person name="Noe" age="32"/>
            </div>
        ); 
        
        Del componente principal, se le pasa al componente que corresponde el valor de las propiedades.

        Person.js
            #IMPORTANTE: 
            El argumento es un objeto con toda la info que se le pasa al componente, se puede llamar props, como se puede llamar pepito.

            const person = (props) => {
                return <p>Hola! Soy {props.name} y tengo {props.age} años! </p>
            }

        Cuanto se usa en una clase-componente (como app), se tiene que usar this.props

    37. Understanding the Children Property

        Si queremos pasar algo entre la etiqueta de apertura y cierre, tenemos que envolver eso en un elemento padre y usar children.

        <div className="App">
            <h1>Hola, soy una App React</h1>
            <Person name="Max" age="28"/>
            <Person name="Manu" age="29">My hobbies: Racing</Person>
            <Person name="Noe" age="32"/>
        </div>

        Person.js
         <div>
            <p>I'm {props.name} and I am {props.age} years old!</p>
            <p>{props.children}</p>
         </div>

    38. Understanding & Using State

        <button>Cambiar de nombre</button>

        State:
            #IMPORTANTE: 
                - SOLO SE PUEDE USAR: En las clases-componentes
                - es una propiedad especial, donde se establecen y pasan props desde afuera como name, age etc, y que se gestionan dentro del componente.
                    Si cambiamos algo que use esta propiedad, va a renderizar nuevamente el dom/componente.

                Se inicializa como un objeto.
                    state = {}
                Se le pueden agregar, array objetos:
                    state = {
                        persons: [
                            { name: 'Noe', age: 32 },
                            { name: 'Gabu', age: 29 },
                            { name: 'Nany', age: 33 },
                        ]
                    }

                Una vez que hacemos esto, la podemos usar en nuestro metodo dinamico.

                <div className="App">
                <h1>Hola, soy una App React</h1>
                <button>Cambiar de nombre</button>
                <Person name={this.state.persons[0].name} age={this.state.persons[0].age}/>
                <Person name={this.state.persons[1].name} age={this.state.persons[1].age}>My hobbies: Racing</Person>
                <Person name={this.state.persons[2].name} age={this.state.persons[2].age}/>
                </div>

                props.children mostraría por ej en el componente Person "My hobbies: Racing"

            this, hace referencia a la clase donde se esta usando 

    39. Props & State
        file:///C:/Users/Noe/Downloads/props-state.pdf

        props  y state  son los conceptos CORE de React. Solo props  y/o state activa React para volver a renderizar sus componentes y potencialmente actualizar el DOM en el navegador 

        Props
            props: le permite pasar datos de un componente principal (container) a un componente secundario (embebido).

        Ejemplo:
            AllPosts Component:
                const posts = () => {
                    return (
                        <div>
                            <Post title="My first Post" />
                        </div>
                    );
                }

            Aquí title  está la propiedad personalizada ( prop ) configurada en el Post  componente personalizado . Básicamente, replicamos el comportamiento del atributo HTML predeterminado que ya conocemos (por ejemplo, <input type="text">  le informamos al navegador acerca de cómo manejar esa entrada).

            Post Component:
                const post = ( props ) => {   
                    volver ( 
                        <div>
                            <h1> { props . título } </ h1 >
                        </ div >
                    );
                }

            El componente Post recibe props como argumento. Por supuesto, puede nombrar este argumento como desee: es la definición de su función, ¡a React no le importa! Pero React pasará un argumento a su función de componente => Un objeto, que contiene todas las propiedades que configuró <Post ... /> .
            {props.title}  luego genera dinámicamente la title  propiedad del props  objeto, que está disponible ya que configuramos la title  propiedad dentro del AllPosts  componente (ver arriba).


        State:
            Mientras props le permiten pasar datos al árbol de componentes (y, por lo tanto, desencadenar una actualización de la interfaz de usuario), el estado se usa para cambiar el componente, bueno, el estado desde dentro. Los cambios en el estado también activan una actualización de la interfaz de usuario.

        Ejemplo:
            NewPost Component:
                ¡La clase NewPost extiende el Componente { // estado solo se puede acceder en los componentes basados ​​en clase!     
                
                class NewPost extends Component { // state can only be accessed in class-based components!
                    state = {
                        counter: 1
                    };  
                
                    render () { // Needs to be implemented in class-based components! Needs to return some JSX!
                        return (
                            <div>{this.state.counter}</div>
                        );
                    }
                }

            Por supuesto, puede pasar state  a componentes funcionales, pero estos no pueden editarlo directamente.
            state  => 
                Simplemente es una propiedad de la clase de componente, debes llamarlo state, obligatoriamente. 
                Luego, puede acceder a él a través this.state  de su código JSX de clase (que devuelve en el render()  método requerido ).
                Cada vez que state  cambia, el componente se volverá a representar y reflejará el nuevo estado. 
                
                La diferencia con props es que esto sucede dentro de un mismo componente: ¡no recibe datos nuevos ( props ) de fuera!

    40. Handling Events with Methods
        // en JSX es con la C mayus.
        <button onClick=>Cambiar de nombre</button>

        es buena practica ponerle al final Handler, a la función que haga de handler.

        switchNameHanlder = () => {
            console.log("click");
        }
        
        a la función no hay que ponerle los () para que no lo llame en ese mismo momento.

        <button onClick={this.switchNameHanlder}>Cambiar de nombre</button>

    41. To Which Events Can You Listen?

        En la última conferencia, vimos que puedes reaccionar ante el evento onClick, pero ¿a qué otros eventos puedes escuchar? Puede encontrar una lista de eventos compatibles aquí:  https://reactjs.org/docs/events.html#supported-events

        Clipboard Events
            Event names:
                onCopy onCut onPaste
            Properties:
                DOMDataTransfer clipboardData
        
        Composition Events
            Event names:
                onCompositionEnd onCompositionStart onCompositionUpdate
            Properties:
                string data
            
        Keyboard Events
            Event names:
                onKeyDown onKeyPress onKeyUp
            
            Properties:
                boolean altKey
                number charCode
                boolean ctrlKey
                boolean getModifierState(key)
                string key
                number keyCode
                string locale
                number location
                boolean metaKey
                boolean repeat
                boolean shiftKey
                number which

        Focus Events
            Event names:
                onFocus onBlur
            
            These focus events work on all elements in the React DOM, not just form elements.

            Properties:
                DOMEventTarget relatedTarget
        
        Form Events
            Event names:
                onChange onInput onInvalid onSubmit
            
            For more information about the onChange event, see Forms.

        Mouse Events
            Event names:
                onClick onContextMenu onDoubleClick onDrag onDragEnd onDragEnter onDragExit
                onDragLeave onDragOver onDragStart onDrop onMouseDown onMouseEnter onMouseLeave
                onMouseMove onMouseOut onMouseOver onMouseUp
            
            The onMouseEnter and onMouseLeave events propagate from the element being left to the one being entered instead of ordinary bubbling and do not have a capture phase.

            Properties:
                boolean altKey
                number button
                number buttons
                number clientX
                number clientY
                boolean ctrlKey
                boolean getModifierState(key)
                boolean metaKey
                number pageX
                number pageY
                DOMEventTarget relatedTarget
                number screenX
                number screenY
                boolean shiftKey
        Selection Events
            Event names:
                onSelect
        
        Touch Events
            Event names:
                onTouchCancel onTouchEnd onTouchMove onTouchStart

            Properties: 
                boolean altKey
                DOMTouchList changedTouches
                boolean ctrlKey
                boolean getModifierState(key)
                boolean metaKey
                boolean shiftKey
                DOMTouchList targetTouches
                DOMTouchList touches
        
        UI Events
            Event names:
                onScroll
            Properties:
                number detail
                DOMAbstractView view

        Wheel Events
            Event names:
                onWheel
            Properties:
                number deltaMode
                number deltaX
                number deltaY
                number deltaZ
        
        Media Events
            Event names:
                onAbort onCanPlay onCanPlayThrough onDurationChange onEmptied onEncrypted
                onEnded onError onLoadedData onLoadedMetadata onLoadStart onPause onPlay
                onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend
                onTimeUpdate onVolumeChange onWaiting

        Image Events
            Event names:
                onLoad onError
        
        Animation Events
            Event names:
                onAnimationStart onAnimationEnd onAnimationIteration
            Properties:
                string animationName
                string pseudoElement
                float elapsedTime

        Transition Events
            Event names:
                onTransitionEnd
            Properties:
                string propertyName
                string pseudoElement
                float elapsedTime
        Other Events
            Event names:
                onToggle

    42. Manipulating the State
        file:///C:/Users/Noe/Downloads/state-learning-card.pdf

        switchNameHanlder = () => {
            // No hay que mutar de esta manera (cambiar de estado), va a dar un error.
            //this.state.persons[0].name = 'Noelia';
            this.setState({
                persons: [
                    { name: 'Noeñs', age: 32 },
                    { name: 'Gabuns', age: 29 },
                    { name: 'Nanys', age: 33 },
                ]
            )
        }

        setState:
            Esta disponible solo en clases basadas en componentes.

            Este es un método que nos permite actualizar esta propiedad state, después
            nos aseguramos de que react conozca como la actualización y react actualice el DOM.

            // Toma un objeto como argumento y fusionara (sobreescribe) eso con nuestro estado actual
            switchNameHanlder = () => {
                this.setState({
                    persons: [
                        { name: 'Noels', age: 32 },
                        { name: 'Gabuns', age: 29 },
                        { name: 'Nanys', age: 33 },
                    ]
                })
            }

            * Solo se pueden cambiar props y state 

    43. Function Components Naming

        En la próxima conferencia, aprenderemos a administrar el estado en componentes funcionales (en lugar de componentes basados en clases).

        En caso de que esté obteniendo un error con el código que se muestra en la siguiente clase, simplemente asigne un nombre de variable en mayúscula a la variable que contiene su componente funcional.

        Ejemplo:
            Utilizar
                const App = () => {...}
                en lugar de

                const app = () => {...}

        Técnicamente, eso no es necesario, pero dependiendo de la configuración de su proyecto, el indicador incorporado (una herramienta de verificación de la calidad del código) que viene con la aplicación crear-reaccionar puede no gustarle el nombre de la variable en minúscula.

        También puede evitar esto creando proyectos con la versión correcta de react-scripts, que recomendaría para este curso de todos modos (vea el video de instalación, conferencia 26)

        create-react-app my-app --scripts-version 1.1.5

    44. Using the useState() Hook for State Manipulation
        base-syntax--02-state-events.zip

        Hasta React 16.8 setState era la unica manera de manejar estados en las aplicaciones de React.

        Ahora hay una característica llamada React Hooks, se utiliza mas que nada en los componentes de funciones.

        IMPORTANTE: El va a seguir enseñando la manera tradicional (clases basadas en componentes) porque en las compañias ya tienen proyectos hechos basados en esto.
        
        Si bien desde React 16.8 podemos usar componentes funcionales para todo, vamos a mantenernos en las clases basadas en componentes, porque el dice que en los laburos se usa mas eso.
        
        "react hooks"  
            Es una colección de funciones expuestas por React para que puedas en componentes funcionales y demás, una de ellas es useState.

            Cambia el componente app por uno funcional o sea, 
                const app = props => {
                    useState({
                        mete el array de persons
                    });

                    return() { JSX } 
                }

            Este es un componente funcional normal, pero ahora puede usar la función de "react hooks" o una de las funciones de React.
            --> Para eso hay que importarlo:  import React, { useState } from 'react' (React ya lo teníamos, solo agregamos { useState })

            UseState:
                Devuelve una matriz con exactamente dos elementos y siempre dos elementos que son importantes.

                    // Usamos destructuración [ param1, param 2] , lo que hace que useState ponga la info en donde corresponda.
                    const [ currentState, updateCurrentState ] = useState({});

                    1) Ahora el primer elemento que recibimos siempre será nuestro estado actual.
                    2) El segundo elemento en la matriz de estado siempre será una función que nos permita actualice este estado para que react lo sepa y volverá a procesar este componente
                        IMPORTANTE: La 2da función no mergea los cambios, pisa el objeto con el nuevo estado.

                    3) Si estabamos usando this.state ahora debemos cambiarlo por currentState 
                    
    45. Stateless vs Stateful
        
        Functional (Stateless) vs class (Stateful) Components
        La mayoria de las veces vamos a usar funciones stateless, las que reciben props.
        
        La mayor parte de la app, no debería cambiar el estado de la aplicación, se supone que solo va a cambiar en ciertos componentes,
            conocidos como "contenedores" Statefull Components. ej app.js
        
    46. Passing Method References Between Components
        base-syntax--02-state-events.zip

        en el padre, al hijo embebido, le generamos un atributo donde le podemos pasar un metodo, entonces en el archivo del hijo, usando prop podemos utilizarlo.

        o sea, el hijo termina usando un metodo que esta en el padre.

        Si necesitamos pasar parametros hay que usar bind.
        
        this.metodo.bind(this, param)
        
        si en vez de usar esa manera, usamos una funcion de flecha anonima, tenemos que tener en cuenta que cuando escribimos la función en una linea:
            onClick={() => this.metodo()}

            adelante del this, si bien no lo pone, hay un RETURN.

        Idealmente es mejor usar bind, porque la función anonima es ineficiente.

    47. Adding Two Way Binding

        En el padre, generamos el metodo que va a cambiar el estado, por parametro le pasamos un event.

        dentro del elemento hijo, agregamos un parametro onChange, para pasarle a ese componente ese metodo, y usamos props.change (que es el atributo donde pusimos el metodo.)

        IMPORTANTE: Si usamos un input siempre le tenemos que poner un onChange o readonly

    48. Adding Styling with Stylesheets

        hay que poner un archivo .css en la misma carpeta que el componente e importarlo en el componente.js 

    49. Working with Inline Styles
        
        Para usar inline styles, se usa javascript en camelCase, ej lo que en css es background-color, aca es backgroundColor o marginLeft, etc.. en el JSX se usa 
        
        Dentro de render () 
        const style = {
            backgroundColor: color,
        }

        <a style={style}></a>
        
        Tarea 1: Time to Practice - The Base Syntax

    50. [OPTIONAL] Assignment Solution

        base-syntax--01-props-custom-cmp.zip
        base-syntax--02-state-events.zip
        base-syntax--03-finished.zip
        base-syntax--assignment-solution.zip

        Solución de la tarea.

    51. Useful Resources & Links

        create-react-app: https://github.com/facebookincubator/create-react-app
        Introducing JSX: https://reactjs.org/docs/introducing-jsx.html
        Rendering Elements: https://reactjs.org/docs/rendering-elements.html
        Components & Props: https://reactjs.org/docs/components-and-props.html
        Listenable Events: https://reactjs.org/docs/events.html
        Recursos de esta clase
        base-syntax--01-props-custom-cmp.zip
        base-syntax--02-state-events.zip
        base-syntax--03-finished.zip
        base-syntax--assignment-solution.zip

### Sección 4: Working with Lists and Conditionals

    52. Module Introduction
    53. Rendering Content Conditionally

        envolver un elemento con { para poder escribir javascript }
        por ejemplo para mostrar o dejar de mostrar un div.

        IMPORTANTE: Hay que usar el operador ternario

        Dentro de JSX no se puede poner el if comun.

        ej:
        { this.showParrafo === true ?
            <p>hola</p>
        :
        null 
        }

        significa que o muestro o el parrafo o no muestro (renderizo nada)

    54. Handling Dynamic Content "The JavaScript Way"

        Dentro de render, antes de retornar algo, podemos poner variables javascript, ya que ahí podemos usar js normalmente.

        ej:

        render (){
            let person = null;

            if(this.person == null) {
                person = ( // esto es como crear un elemento 
                    metemos el html aca que queremos ocultar o no
                );  
            }

            return (
                html..
                {person} // person es la variable null o la variable donde guardamos el html a renderizar.
            )
        }

    55. Outputting Lists (Intro)

        Explica que las listas asi hardcodeadas como estan se romperían si se elimina un elemento. Y que se soluciona con lo que se va a seguir en el curso (re al pedo este modulo.)

    56. Outputting Lists

        
        .map mapea elementos en un array dado (en este caso "elArray"), ejecuta un metodo en cada elemento del array
            el metodo/funcion, es pasado a mapa dentor de los ().
            - .map retorna un nuevo array, react lo que intenta hacer al retornarlo es renderizarlo otra vez en el DOM (si es un JSX valido)

        esa función que se le pasa a map, se ejecuta en cada elemento del array.
        map tiene un segundo parametro que es el index del elemento.

        {this.state.elArray.map(elementoDelArray => {
            return <Person name="person.name" age="person.age" />;                                    // Lo que quiero mapear dentro de cada elemento.
        })}

        * El elemento key en este ejemplo falta, esta en el 58 y se tiene que poner para que funcione todo correctamente, explicación ahí.

    57. Lists & State
        deletePersonHandler = (personIndex) => {
            
            const persons = this.state.persons; // Me guardo el array de personas.
            persons.splice(personIndex, 1); // Splice, sirve para eliminar elementos del array, acá le decimos que elimine 1 solo, y un index en particular.
            this.setState({persons: persons})

        }
        
        {this.state.elArray.map( ( elementoDelArray, index ) => {
            return <Person click={this.deletePersonHandler} name="person.name" age="person.age" />;                                   
        })}

        Supuestamente esto tiene una falla, en el proximo  modulo se va a demostrar esto.

    58. Updating State Immutably

        Lo que se hizo antes es una mala practica. Ya que esta apuntando al state original, y si ese se modifica, también explotaría acá.
        Lo que hay que hacer primero es una copia del array, utilizando slice.

        slice() sin argumentos copia el array completo y retorna uno nuevo en la variable, entonces ahora si no habría ningún problema.

            const persons = this.state.persons.slice();

        Hay una alternativa (equivalente) a esto, que es usar el operador spread: ... / Si son tres puntos.
        Spread: ... despliega los elementos del array en una lista de elementos, que se agrega a esa matriz, de modo que ahora tenemos una matriz,
            nueva matriz con los objetos viejos de la matriz vieja, pero no la matriz vieja en si misma.   
            
            const persons = [...this.state.persons] 

        Por ende:
            1) Crear una copia
            2) Actualizar esa
            3) updatear el state

    59. Lists & Keys

        React exige escribir el elemento key, ya que esto le deja comparar el dom virtual con el dom real, y de esta manera identifica
            que elemento cambió y debe actualizar y no así toda la lista.
            se tiene que poner el id de los elementos.

            {this.state.elArray.map( ( elementoDelArray, index ) => {
                return <Person click={this.deletePersonHandler} name="person.name" age="person.age" key="person.id" />;                                   
            })}

    60. Flexible Lists

        1) Le agrega id al array de persons, apenas lo setea 
        2) modifica el elemento Person para que tenga el evento change, pasandole el evento y el id:

            {this.state.elArray.map( ( elementoDelArray, index ) => {
                return <Person 
                            click={this.deletePersonHandler} 
                            name="person.name" 
                            age="person.age" 
                            key="person.id"
                            change="{(event) => { this.nameChangeHandler(event, person.id)}} // A la función anonima hay que pasarle el param event, para que después se lo pueda pasar a la función nameChangeHandler

                            />;                                   
            })}

        3) Actualiza la función nameChangeHandler, para que seactualice el elemento especifico.

            nameChangeHandler = (event, id) => {
                
                // Obtenemos el index del elemento en la matriz, findIndex retorna true o false si no lo encontró.
                const personIndex = this.state.persons.findIndex(p => {
                    return p.id === id;
                });

                // Creamos un nuevo objeto para poder quedarnos con el que queremos una vez que lo encontramos.
                const person = {
                    ...this.state.persons[personIndex]
                }
                
                // Otra manera de hacerlo sería:
                // Pasamos un objeto vacio, y como 2do param, el objeto que queremos asignarle.
                // const person = Object.assign({}, this.state.persons[person]); 

                // Ya conseguí la copia (no el objeto original)
                person.name = event.target.name;

                // Pongo los elementos viejos del state en uno nuevo, y actualizo el array con la nueva persona a la que actualizamos el nombre anteriormente.
                const persons = [...this.state.persons];
                persons[personIndex] = person;

                // Finalmente actualizamos el estado con el nuevo array actualizado.
                this.setState({ persons: persons)}
            

            // findIndex como map, recorre cada elemento y busca el index que le pasamos.

    61. Wrap Up
        Tarea 2: Time to Practice - Lists & Conditionals

    62. [OPTIONAL] Assignment Solution
    63. Useful Resources & Links

        Conditional Rendering: https://reactjs.org/docs/conditional-rendering.html
        Lists & Keys: https://reactjs.org/docs/lists-and-keys.html

        Recursos de esta clase
            lists-conditionals--01-conditional-content.zip
            lists-conditionals--lists-finished.zip
            lists-conditionals--assignment-solution.zip

### Sección 5: Styling React - Components & Elements

    64. Module Introduction
    65. Outlining the Problem Set
    66. Setting Styles Dynamically

        render () {
            // Agrega esto
            const style = {
                backgroundColor: 'green',
                color: 'white',
                font: 'inherit',
                border: '1px solid blue',
                padding: '8px',
                cursor: 'pointer'
            }

            let persons = null;

            if ( this.state.showPersons ) {
            persons = (
                <div>
                {this.state.persons.map((person, index) => {
                    return <Person
                    click={() => this.deletePersonHandler(index)}
                    name={person.name} 
                    age={person.age}
                    key={person.id}
                    changed={(event) => this.nameChangedHandler(event, person.id)} />
                })}
                </div>
            );

            style.backgroundColor = 'red'; // Agrega esto
        }

    67. Setting Class Names Dynamically

        // Agrega las clases:

        App.css 
            .red {
                color: red;
            }

            .bold {
                font-weight: bold;
            }
        
        App.js
            // Esto usa las clases que declaramos y las une con un espacio en el medio.
            let classes = ['red','bold'].join(' ');

            return (
                <div className="App">
                    <h1>Hi, I'm a React App</h1>
                    <p className={classes}>This is really working!</p>

    68. Adding and Using Radium
        
        // Sirve para poder usar, inline styles, pseudo selectores y media queries:
            Para extender el alcance de un componente o cambiarlo dinamicamente.

        1) > npm install --save Radium
        2) import Radium from 'radium'; 
        3) export default Radium(App); // Higher order component, se puede usar en todo tipo de componentes.

        const style = {
        backgroundColor: 'green',
        color: 'white',
        font: 'inherit',
        border: '1px solid blue',
        padding: '8px',
        cursor: 'pointer',
        ':hover': {
            backgroundColor: 'yellow',
            color: 'black'
        }
        };

        style.backgroundColor = 'red';
        style[':hover'] = {
            backgroundColor: 'brown',
            color: 'black'
        };

        IMPORTANTE: Todo esto es porque si bien podemos poner el codigo en el css, no va a aplicar solo al componente que queremos sino a todos los componentes.

    69. Using Radium for Media Queries

        // Actualemente no es necesario importar ni usar usar: </StyleRoot>
            no hay errores.
        Person.js
            const style = {
                '@media (min-width: 580px': {
                    
                }
            };

    70. Introducing Styled Components
        npm install --save styled-components
        
        import syled from 'styled-components';
        const Button = styled.button`` -> feature: que se llama tacked templates. button es una función o metodo, dentro de los ticks, podes pasar texto.

        Los metodos retornan un componente de react.

        En vez de:
        <div className="Person" style={style}">

        Haces:
        styled.div``
            width: 60%;
            margin:  16px auto;

        pero, es mejor, crear un nuevo COMPONENTE, de esta manera, que es especifica para este framework, ya que recordemos, los metodos, retornan un componente.:

        const StyledDiv = styled.div`
            width: 60%;
            margin:  16px auto;`;

        Esto después lo usamos así:
        <StyledDiv>
        </StyledDiv>
            
    71. More on Styled Components
        Como funcionan realmente?

        Si nos fijamos en el html, los nombres de las clases que se generaron son fruta, estos nombres los genera el framework.

        El package agarra todo el css y lo pone como selectores de clase y los agrega al encabezado documento, y después agrega el css al div que es retornado por ese compoenente.

    72. Styled Components & Dynamic Styles
        Para pasarle props y cambiar su estilo, dinamicamente, simplemente le pasamos como cualquier otro componente, mediante un nombre de prop y un valor. Después dentro de los backteacks, usamos por ej:

        <StyledButton alt="this.state.button">

        const StyledButton = styled.button`
            background-color: ${props => props.alt ? 'red' : 'green' }
        `;
        
        Todo esto es javascript, no react, por eso usando los backteacks, se puede usar interpolación de cadenas y a su vez el package hace la magia de poder usar props.
         
    73. Working with CSS Modules
        npm run eject 
        // Esto ya se hace varias veces en el curso, buscarlo en el archivo.

        En el caso de que estemos manejando todo el css dentro de un solo arhivo, podríamos indicar adelante de los selectores, el css principal por ejemplo el de App.

    74. CSS Modules & Media Queries
         Con CSS Modules, tenemos la info separada, js por un lado css por otro, y aparte de importar el css solo en el js que lo necesitamos. Recomendable este en la misma carpeta del componente junto al js.

    75. More on CSS Modules
        CSS Modules are a relatively new concept (you can dive super-deep into them here: https://github.com/css-modules/css-modules). With CSS modules, you can write normal CSS code and make sure, that it only applies to a given component.

        It's not using magic for that, instead it'll simply automatically generate unique CSS class names for you. And by importing a JS object and assigning classes from there, you use these dynamically generated, unique names. So the imported JS object simply exposes some properties which hold the generated CSS class names as values.

        Example:

        In Post.css File

        .Post {
            color: red;
        }
        In Post Component File

        import classes from './Post.css';
        
        const post = () => (
            <div className={classes.Post}>...</div>
        );
        Here, classes.Post  refers to an automatically generated Post  property on the imported classes  object. That property will in the end simply hold a value like Post__Post__ah5_1 .

        So your .Post  class was automatically transformed to a different class (Post__Post__ah5_1 ) which is unique across the application. You also can't use it accidentally in other components because you don't know the generated string! You can only access it through the classes  object. And if you import the CSS file (in the same way) in another component, the classes  object there will hold a Post  property which yields a different (!) CSS class name. Hence it's scoped to a given component.

        By the way, if you somehow also want to define a global (i.e. un-transformed) CSS class in such a .css  file, you can prefix the selector with :global .

        Example:

        :global .Post { ... } 

        Now you can use className="Post"  anywhere in your app and receive that styling.

    76. Useful Resources & Links
        Using CSS Modules in create-react-app Projects: https://medium.com/nulogy/how-to-use-css-modules-with-create-react-app-9e44bec2b5c2
        More information about CSS Modules: https://github.com/css-modules/css-modules
        Recursos de esta clase
        styling--01-radium.zip
        styling--02-styled-components.zip
        styling--03-finished.zip

    Desde acá hasta el 75, cambio todo, esto es viejo: 
        70. MUST READ: Enabling CSS Modules

            // Para habilitar CSS Modules:
            1) commitear los cambios que puedas tener
            2) npm run eject
            3) Vamos a ver nuevas carpetas: 
                /config -->
                /scripts --> Tiene un script por cada comando en scripts a ejecutar 

            4) Modificar el archivo en config/webpack.config.js 

            test: cssRegex,
                    exclude: cssModuleRegex,
                    use: getStyleLoaders({
                        importLoaders: 1,
                        modules: true,
                        localIdentName: '[name]__[local]__[hash:base64:5]',
                        sourceMap: isEnvProduction && shouldUseSourceMap,
                    }),

                debería modificarse también en el de prod, pero no lo tengo.. igual que otros archivos que el tiene y yo no.
            5) Modificamos el import del css: import clases from './App.css' 
                las clases que tenemos en el archivo pasan a ser propiedades :O
            6) Cambiamos 
                <div className="App">
                por:
                <div className={clases.App}>

                Transforma la info que esta en la clase en unica.
            7) Si revisamos el html vemos que tiene un nombre de clase super extraño :D

        71. Enabling & Using CSS Modules

            // Para habilitar CSS Modules:
            1) commitear los cambios que puedas tener
            2) npm run eject
            3) Vamos a ver nuevas carpetas: 
                /config -->
                /scripts --> Tiene un script por cada comando en scripts a ejecutar 

            4) Modificar el archivo en config/webpack.config.js 

            test: cssRegex,
                    exclude: cssModuleRegex,
                    use: getStyleLoaders({
                        importLoaders: 1,
                        modules: true,
                        localIdentName: '[name]__[local]__[hash:base64:5]',
                        sourceMap: isEnvProduction && shouldUseSourceMap,
                    }),

                debería modificarse también en el de prod, pero no lo tengo.. igual que otros archivos que el tiene y yo no.
            5) Modificamos el import del css: import clases from './App.css' 
                las clases que tenemos en el archivo pasan a ser propiedades :O
            6) Cambiamos 
                <div className="App">
                por:
                <div className={clases.App}>

                Transforma la info que esta en la clase en unica.
            7) Si revisamos el html vemos que tiene un nombre de clase super extraño :D

        72. More on CSS Modules

            CSS Modules are a relatively new concept (you can dive super-deep into them here: https://github.com/css-modules/css-modules). With CSS modules, you can write normal CSS code and make sure, that it only applies to a given component.

            It's not using magic for that, instead it'll simply automatically generate unique CSS class names for you. And by importing a JS object and assigning classes from there, you use these dynamically generated, unique names. So the imported JS object simply exposes some properties which hold the generated CSS class names as values.

            Example:

            In Post.css File

            .Post {
                color: red;
            }
            In Post Component File

            import classes from './Post.css';
            
            const post = () => (
                <div className={classes.Post}>...</div>
            );
            Here, classes.Post  refers to an automatically generated Post  property on the imported classes  object. That property will in the end simply hold a value like Post__Post__ah5_1 .

            So your .Post  class was automatically transformed to a different class (Post__Post__ah5_1 ) which is unique across the application. You also can't use it accidentally in other components because you don't know the generated string! You can only access it through the classes  object. And if you import the CSS file (in the same way) in another component, the classes  object there will hold a Post  property which yields a different (!) CSS class name. Hence it's scoped to a given component.

            By the way, if you somehow also want to define a global (i.e. un-transformed) CSS class in such a .css  file, you can prefix the selector with :global .

            Example:

            :global .Post { ... } 

            Now you can use className="Post"  anywhere in your app and receive that styling.
            
        73. Adding Pseudo Selectors

            Elimina todo el css que andaba por los archivos. Lo voy a eliminar cualquier cosa ver commit "elime css por curso 72"

            .App button {
                border: 1px solid blue;
                padding: 16px;
                background-color : green;
                font: inherit;
            }

            Sigue funcionando todo porque:
            <div className={classes.App}>
                <button
            </div


            btnClass = classes.Red;
            <button
                className={btnClass}

        74. Working with Media Queries

            Person.css
            @media (min-width: 500px) {
                .Person {
                    width: 450px;
                }
            }

            no se que pasa que no funciona.

        75. Useful Resources & Links

            Using CSS Modules in create-react-app Projects: https://medium.com/nulogy/how-to-use-css-modules-with-create-react-app-9e44bec2b5c2
            More information about CSS Modules: https://github.com/css-modules/css-modules
            Recursos de esta clase
            styling--01-radium.zip
            styling--02-css-modules-finished.zip

### Sección 6: Debugging React Apps

    77. Module Introduction
    78. Understanding Error Messages

        Como ver en la consola el error y en que linea esta.

    79. Finding Logical Errors by using DevTools & Sourcemaps

        Enseña como poner un debug en la consola de chrome.

    80. Working with the React Developer Tools

        Instala la extensión de chrome, muestra la solapa React en la consola de Chrome.

    81. Using Error Boundaries (React 16+)

        throw new Error("hubo un error");
        
        IMPORTANTE: key, siempre tiene que estar en el elemento "padre";

        Crea un componente ErrorBoundary

        import React, { Component } from 'react;
        class ErrorBoundary extends Component{
            state = {
                hasError: false,
                errorMessage:
            }

            componentDidCatch = (error, info ) => {
                this.setState({hasError: true, errorMessage: error});
            }

            render () {
                if(this.state.hasError){
                    return <h1>{this.state.errorMessage}</h1>;
                }else{
                    return.this.props.children;
                }
            }
        }

        export default ErrorBoundary;

        IMPORTANTE: hay que usar este componente para envolver algo que tenga realmente sentido.
                    en development el error es sobreescrito por lo que informa React, no así en prod.

    82. Wrap Up
    83. Useful Resources & Links

        Error Boundaries: https://reactjs.org/docs/error-boundaries.html
        Chrome Devtool Debugging: https://developers.google.com/web/tools/chrome-devtools/javascript/
        Recursos de esta clase
        debugging--01-finished.zip

### Sección 7: Diving Deeper into Components & React Internals

    84. Module Introduction
    85. A Better Project Structure

        Los componentes a generar deben tener sentido. Por ej si queremos tener algo generico como un input que se use en varias partes, ahí si valdría la pena hacer un solo componente por eso.
        Los componentes que manejan estados, no deberían comprometerse mucho con la renderización de otros, o sea no tener mucho JSX.

        En src, genera:
            /components  --> cada componente
            /assets      --> imagenes y css
            /containers  --> los componentes principales (como App)

    86. Splitting an App Into Components

        // Si hacemos esto, no es necesario poner el return, gracias a ES6
        const persons = (props) => (
            Podemos poner JSX
        );

        Si en una función utilizamos { } y un metodo return -> componente.
        Si en una función utilizamos { } -> funcion
        
        Resumen: Hay que tener containers donde se manejen estados y el resto deberían ser funcional components donde 
                solamente se pasen props.

    87. Comparing Stateless and Stateful Components

        Presentational component (stateless components) = functional component que no maneja estados

    88. Class-based vs Functional Components

            A los containers se les puede pasar props desde index.js al renderizarlos.

    89. class Component Lifecycle Overview

        - Solo esta disponible en class Component.
        - Hay un monton de metodos, que react corre por nosotross, ej:
        contructor(), getDerivedStateFromProps()...

        IMPORTANTE: no realizar "side effects" en el construtor, como:
            http request, store aglo en la base. Usar solo para inicializar variables.

        Ejemplos de llamados de metodos en orden:

            1) constructor
            2) getDerivedStateFromProps
                Cuando las props cambien para la clase. Idem constructor, no side effects acá.

            3) render
                prepara y estructura tu jsx para retornarlo.

            4) Child components:
                Se renderizan estos components.

            5) ComponentDidMount()
                Acá se pueden generar "side effects"
                NO ACTUALIZAR EL ESTADO ACA. Salvo que se cumpla una promesa sobre un llamado http.

    90. Component Creation Lifecycle in Action
        lifecycle-creation-learning-card (1)
        cmp-deep-dive-01-creation-lifecycle

        mediante console log, muestra como se van ejecutando en orden las cosas, idem las posteriores..

    91. Component Update Lifecycle (for props Changes)

        lifecycle-update-external-learning-card (1)
        cmp-deep-dive-02-updating-lifecycle-props

        Ciclo de vida para actualizar los componentes.
            Cuando cambian las props o el estado
        
        1) getDerivedStateFromProps(props, state)
            No se usa amenudo, se utiliza para inicializar el estado de un componente que se actualiza en funcion de los accesorios que esta obteniendo. ej, algun control de form que obtiene propieades externas y luego internamente desea manejar la entrada del usuario pero inicializa su estado o actualiza el estado en función de cmbioas externos.
            Sirve para sincronizar tu estado local dentro del component, no debería realizar side effects, por lo que no se deberían realizar llamadas http.

        2) shouldComponentUpdate(nextProps, nextState)
            permite cancelar el proceso de actualización, o sea, si react debe continuar evaluando y renderizando el componente o no.
            se usa para optimizar el rendimiento.
            tener cuidado porque podes bloquear tus componentes

        3) render()
            revisa el codigo JSX, lo evalua y basicamente construye su dom virtual 
        
        4) Update Child Components Props
            Evalua todos los hijos secundarios que tengas en tu JSX y los actualiza

        5) getSnapshotBeforeUpdate(prevProps, prevState)
            devuelve un objeto snapshot que se puede configurar.
            también es un enlace de ciclo de vida que no se usa demasiado.
            se usa para operaciones de ultimo momento en el dom, no cambios, sino como obtener la posición de desplazamiento actual del usuario.
            suponiendo que su proxima actualizacion del dom va a volver a representar el dom y agregara nuevos elementos y por lo tanto queres restaurar donde estaba el usuario posicionado.
        
        6) componentDidUpdate(prevProps, prevState, snapshot)
            un enlace de ciclo de vida que te "avisa" que terminó la actualización del componente. 
            acá si se pueden realizar llamadas http
            LOOP INFINITOO ALERT:
                no actualice el stado aqui porque sino va a causar re-renderizado nuevamente. 

    92. Component Update Lifecycle (for state Changes)
        cmp-deep-dive-03-updating-lifecycle-state

    93. Using useEffect() in Functional Components
    
        import React, { useEffect } import 'react'

        Toma una función que corre en cada ciclo de renderizado, después que se re-renderiza.
            useEffect(() => {

            })

        useEffect combina dos :
            componentDidMount y componentDidUpdate.

    94. Controlling the useEffect() Behavior

        1) Que haga algo solo la primera vez. Se pone un array vacio [] y corre una sola vez y nunca mas.
            useEffect(() => {

            },[])
        
        2) cuando se actualiza un estado.
            Lo que hay que hacer sería lo siguiente:

            useEffect(() => {

            },[props.persons])

        IMPORTANTE: En el caso de necesitar lo mismo para otra prop, hay que volver a escribir useEffect y pasarle esa prop.

    95. Cleaning up with Lifecycle Hooks & useEffect()

        componentWillUnmount, se ejecuta cuando se remueve el componente, en el caso del toggle persons por ej cuando haces clic otra vez para ocultarlo.

        Dentro del mismo useEffect, se puede retornar algo mediante una función anonima, para limpiar algo.

    96. Cleanup Work with useEffect() - Example
        useeffect

    97. Using shouldComponentUpdate for Optimization
        https://academind.com/learn/javascript/reference-vs-primitive-values/

        shouldComponentUpdate -> se renderizan todos los componentes, pero lo podemos modificar para que se renderice solo el que se actualizó:

        shouldComponentUpdate(nextProps, nextState){
            if(nextProps.persons !== this.props.persons){
                return true;
            }else{
                return false;
            }

            return true;
        }

        IMPORTANTE: Para ver que se refresca en la pantalla > F12 > clic en los 3 puntos > More Tools > Rendering > chequear la opción Paint Flashing
                    Ojo porque a veces parece que refresca la pantalla, pero en realidad esta refrescando el dom virtual.
        
    98. Optimizing Functional Components with React.memo()

        En cockppit por ejemplo, al exportar el componente, utilizaríamos memo.
        Lo que hace es tomar un snapshot del componente y lo re-renderiza, si y solo si, el input cambia.

        export default React.memo(cockpit);

        El problema es que en cockpit, hay una propiedad que cambia siempre que es persons, por ende hay que hacer un mini fix en la manera de pasarselo en App.
            le pasamos solo el lenght de cockpit, en vez de que lo resuelva el adentro.

    99. When should you optimize?
    100. PureComponents instead of shouldComponentUpdate
        
        Si queremos chequear si alguna de todas las propiedades cambió, no nos conviene usar shouldComponentUpdate.
        Para eso tenemos que extender de otro componente:

        import React, { PureComponent } from 'react'

        PureComponent, ya implementa shouldComponentUpdate con un completo chequeo de todas las props.

    101. How React Updates the DOM

        render() --> No actualiza inmediatamente al DOM real. Aplica a todo tipo de componentes. 
                    Este puede llegar a dar el mismo resultado que antes, es por eso que se usa shouldComponentUpdate, para manejar que es lo que realmente se debería renderizar.

                    Lo que hace es compara el viejo DOM con el nuevo DOM (virtuals)
                        Hace esto porque es mas rapido que el DOM real.

                    DOM Virtual, es una representación del DOM en Javascript.
                    El future DOM, es el que se crea cuando render es llamado, recordemos que render no llama inmediatamente al DOM real sin antes comparar (el viejo con el futuro para ver si hay diferencias.)
                    Una vez que termina llama al DOM real y lo actualiza, y no lo re-renderiza por completo, solo lo que fue detectado para updetear.

                    Si no encuentra diferencias, se ejecuta render y ahí es donde shouldComponentUpdate debería prevenir que llame al dom real, si realmente nada cambio.
                    
    102. Rendering Adjacent JSX Elements

        En vez de envolver los elementos en un div, podemos usar:

            return [
                <h1></h1>,
                <p></p>
            ]

            El tema es que hay que generar una key, para cada elemento, si no tenes que generar identificadores unico igual.

        Otra manera de hacer esto es:
        
            Crear una carpeta hoc (High order component)
            Después hay que crear un archivo Aux.js (mac) Auxiliary.js (Windows) 

            import React from 'react';

            const aux = props => props.children;

            export default aux;

            IMPORTANTE: Children es una propiedad especial, que lo que sea que entre, lo pone entre tags cerrados.

    103. Windows Users Must Read

        On Windows, the Aux.js  filename is not allowed in ZIP archives. Hence when extracting the attached source code, you might get prompted to rename the Aux.js  file. You might also face difficulties creating an Aux folder and Aux.js file.

        I really apologize for that inconvenience, Windows is really doing an amazing job here ;-).

        Follow these fixes:

        1) Problems when unzipping the attached file:
        Simply skip this step (e.g. by pressing "No") and ignore the upcoming error message.

        In the extracted folder, you'll then find all source files EXCEPT for the Aux.js  file. In later course modules (where we work on the course project), the Aux.js  file can be found in an Aux/  subfolder inside hoc/ .

        Make sure to take the Aux.js  file attached to this lecture and place it inside the hoc/  or hoc/Aux/  folder (which ever of the two you got).

        2) Problems with the creation of an Aux folder and/ or file:
        Simply name both differently. For example, you may create an Auxiliary  folder and name the file inside of it Auxiliary.js . Make sure to then adjust your imports (import Aux from './path/to/Auxiliary/Auxiliary' ) and you should be fine.



        Recursos de esta clase
        Aux.js
        Auxiliary.js

    104. Using React.Fragment

        En vez de usar Aux, se puede usar <React.Fragment> si no queremos usarlo así (separado por el punto, hay que importar Fragment)
        import React, { Fragment} from 'react' 

        Hace lo mismo que Aux.

    105. Higher Order Components (HOC) - Introduction
        
        Se llama así porque contiene un componente, no hace nada.

        También puede haber componentes HOC:
            Puede ser por ej el div con className App.

        Otro ejemplo:
            Crea el archivo /hoc/WithClass.js

            import React from 'react';

            const withClass = props => {
                <div className={props.classes}>
                    {props.children}
                </div>
            };

            export default withClass;

        CONVENCIÓN: Los archivos de hoc, tienen que tener With adelante.
        
        Cambia el div de app por este withClass y le pasa classes por props.

    106. Another Form of HOCs

        Existe otra manera de crear las clases tipo withClass.
        
        Devolver una función comun de Javascript.
        1) parametro que debe arrancar con mayuscula
        2) algo que necesitemos en el componente hoc.
        3) Puede tener n parametros (obvio los que necesitas nada mas.)

        const withClass = (WrappedComponent, className) => {
            // Retorno un componente funcional.
            return props => (
                <div className={className}>
                <WrappedComponent></WrappedComponent>
                </div>
            );
        };
        
        4) Usamos el componente Aux en App y cambiamos el nombre del js a tener w minuscula, porque ahora estamos devolviendo una función no un componente.
        5) modificamos el export de App:
            export default withClass(App, classes.App);

            Esto se usa dependiendo de que necesitemos.

    107. Passing Unknown Props

        Si lo hacemos en el componente de Person no tenemos prop, entonces hay qu tocar la función, para que dentro delc omponente, haga un spread de props, así después los demas componentes que la quieren usar no tienen ningun problema.

    108. Setting State Correctly

        Esto que muestra es solo para clases basadas en componentes.

        Hay que actualizar el estado así:
            this.setState((prevState, props) => {
                return {
                    persons: persons,
                    changeCounter: prevState.changeCounter + 1;
                }
            })

        NO ASÍ:
            this.setState({
                persons: persons,
                changeCounter: this.state.changeCounter + 1;
            })

        Porque cuando se usa de la ultima forma, React no te garantiza que ese sea realmente el último estado.

    109. Using PropTypes

        No necesariamente son necesarias, pero cuando trabaja en un equipo grande o que queres distribuir lo que estás haciendo, evitas que la gente pase mal las propiedades.

        Hay que:
        
            1) Instalar prop-types
                > npm install --save prop-types
            2) Importarlo: 
                import PropTypes from 'prop-types';
            3) Agregar antes del export:
                
                NOTA: va con minuscula acá:

                Person.propTypes = {
                    click: PropTypes.func,
                    name: PropTypes.string,
                    age: PropTypes.number
                }
        
        IMPORTANTE: 
            - Funciona en cualquier tipo de componente.
            - Te avisa si estas pasando una propiedad incorrecta EN DEVELOPMENT MODE.
            - Podes usarlo en el componente que creas necesario.

    110. Using Refs

        Solo funciona en componentes basados en clases.
        Ejemplo para ponerle el foco en el ultimo elemento de una lista de 3 elementos input:
        
        ref:
            es una key especial, que le podes pasar a cualquier componente.
            Se puede usar de varias maneras, una es esta:

                Lo usas con una función anonima en la que obtenes tenes la referencia, de donde pongas ref.
                y le pones el nombre que quieras, por ej inputEl, 
                en el cuerpo de la función podes asignar ese elemento a una nueva propiedad de clase 

                ComponentDidMount() {
                    this.inputElement.focus();
                }

                <input 
                    ref={ ( inputEl ) => { this.inputElement = inputEl }}
                />
            
            Otra es:
                constructor() {
                    super(props);
                    this.inputElementRef = react.createRef();
                }

                ComponentDidMount() {
                    this.inputElementRef.current.focus();
                }

                <input 
                    ref={ this.inputElementRef }
                />

    111. Refs with React Hooks

        Como usar algo parecido a Refs, con React Hooks en functional components.

        import React, { useRef } from 'react'
        const toggleBtnRef = React.createRef(null);

        y hay que usar dentro de useEffect: toggleBtnRef.current.click()

    112. Understanding Prop Chain Problems

        Hace un ejemplo donde pasa una propiedad por varios componentes y que si tenes un componente que es reutilizable vas a tener que estar haciendo cosas demas para poder usarlo solo por eso,
        explica que esto lo resuelve

    113. Using the Context API

        * this.context no se usa mas, se debe usar esta api. React.createContext + useContext

        PROVIDER: se crea el context para que los componentes después, lo puedan CONSUMIR.
            - React create context, nos permite inicializar nuestro contexto con un valor inicial, puede ser cualquiera cosa, obj, array, etc. También se inicializa para poder usar el intellisense, pero generalmente la inicialización no se utiliza salvo que no se pase nada al atributo value del componente.

            - Crete context es un "objeto global" de javascript. O sea, en realidad no es que es un objeto global, 
            sino que vos decidis donde se va a aplicar.
            
            - En el contexto tengo que guardar todo lo que quiero acceder desde mis diferentes componentes.
            
            - Con nuestro nuevo componente, en este caso authContext, tenemos que envolver, los componentes, que querramos que tengan acceso a esta información.
        
        CONSUMER:
            - Se debe importar el context, y en el return, debemos utilizar el componente, englobando los componentes que necesitan esa info, pero con <AuthContext.Consumer> ver ej mas abajo:
            - No toma JSX como un hijo, pero si una función, ver ej de como realizar esto.
            - Se utiliza en el componente que este lo mas abajo posible, ya que sino tenemos que andar pasando cosas por props y justamente esa no es la idea.
        
        EJEMPLO:
        Agrega una nueva carpeta /context y después un archivo aux-context.js
            import React from 'react';

            const authContext = React.createContext({
                authenticated: false,
                login: () => {}
            });

            export default authContext;

        App.js
            Lo importamos.
            Envolvemos los componentes que queremos con el componente que creamos:
                // value, se setea cuando vos no seteas ningun otro valor.
                <AuthContext.Provider value={authenticated: this.state.authenticated, login: this.loginHandler  } >

        Persons.js
            Como acá lo queremos consumir, tenemos que, después del return, poner:
            <AuthContext.Consumer>
            {context => <button onClick...}
            </ AuthContext.Consumer>

        IMPORTANTE: lo que se cambie en ese contexto, no va a generar una re-renderización.

        export default authContext;

    114. contextType & useContext()

        
        COMPONENTES BASADOS EN CLASES:

            Como en ComponentDidMount, puede que tengas que hacer un llamado HTTP y necesites el context y ahí no se puede obtener la info como la aprendimos.
            A partir de react 16.6 hay una variable estatica contextType.

            static contextType = authContext;

            Esto habilita a que detrás de escena, el metodo ComponentDidMount, se comunique con la variable estatica, ya que ahora tenes dentro del metodo:
            this.context.login por ej.
            this.context.authenticated
            También podemos modificar el elemento AuthContext.Consumer por this.context.authenticated

        FUNCTIONAL COMPONENTS
            import AuthContext from 'context/aut-context';
            import React, {useContext} from 'react'

            const authContext = useContext(AuthContext);

            authContext.authenticated

            en coockpit, cambias el elemento por esto y listo. 

    115. Wrap Up
    116. Useful Resources & Links

        More on useEffect(): https://reactjs.org/docs/hooks-effect.html

        State & Lifecycle: https://reactjs.org/docs/state-and-lifecycle.html

        PropTypes: https://reactjs.org/docs/typechecking-with-proptypes.html

        Higher Order Components: https://reactjs.org/docs/higher-order-components.html

        Refs: https://reactjs.org/docs/refs-and-the-dom.html

        Recursos de esta clase
        cmp-deep-dive-01-creation-lifecycle.zip
        cmp-deep-dive-02-updating-lifecycle-props.zip
        cmp-deep-dive-03-updating-lifecycle-state.zip
        cmp-deep-dive-04-finished-useeffect.zip
        cmp-deep-dive-05-shouldcomponentupdate-memo.zip
        cmp-deep-dive-06-aux.zip
        cmp-deep-dive-07-withclass.zip
        cmp-deep-dive-08-finished-hocs.zip
        cmp-deep-dive-09-updating-state.zip
        cmp-deep-dive-10-proptypes.zip
        cmp-deep-dive-11-refs.zip
        cmp-deep-dive-12-finished.zip

    117. MUST READ: Legacy Lectures
        DON'T SKIP THIS!

        ---

        With React 16.8, a new feature called "React Hooks" was introduced. This course already covers this feature and this module, up to this point, is 100% up-to-date with that feature (e.g. you learned about useEffect()).

        The upcoming lectures marked as "[LEGACY]" are only there to allow existing students who started this module before the update (on February 6th) to continue smoothly.

        You can skip all remaining lectures in this module (i.e. the lectures with "[LEGACY]") if you watched all the other lectures prior to this one.
    118. [LEGACY] Splitting an App Into Components
    119. [LEGACY] Comparing Stateless and Stateful Components
    120. [LEGACY] Understanding the Component Lifecycle
    121. [LEGACY] Converting Stateless to Stateful Components
    122. [LEGACY] Component Creation Lifecycle in Action
    123. [LEGACY] componentWillUnmount()
    124. [LEGACY] Component Updating Lifecycle Hooks
    125. [LEGACY] Component Updating Lifecycle in Action
    126. [LEGACY] Updating Lifecycle Hooks (Triggered by State Changes)
    127. [LEGACY] Performance Gains with PureComponents
    128. [LEGACY] How React Updates the App & Component Tree
    129. [LEGACY] Understanding React's DOM Updating Strategy
    130. [LEGACY] Windows Users Must Read - File Downloads
    131. [LEGACY] Returning Adjacent Elements (React 16+)
    132. [LEGACY] React 16.2 Feature: Fragments
    133. [LEGACY] Understanding Higher Order Components (HOCs)
    134. [LEGACY] A Different Approach to HOCs
    135. [LEGACY] Passing Unknown Props
    136. [LEGACY] Using setState Correctly
    137. [LEGACY] Validating Props
    138. [LEGACY] Available PropTypes
    139. [LEGACY] Using References ("ref")
    140. [LEGACY] More on the React ref API (16.3)
    141. [LEGACY] The Context API (React
    142. [LEGACY] More on the Context API (16.6)
    143. [LEGACY] Updated Lifecycle Hooks (React 16.3)
    144. [LEGACY] The "memo" Method (16.4)
    145. [LEGACY] Wrap Up
    146. [LEGACY] Useful Resources &

### Sección 8: A Real App: The Burger Builder (Basic Version)

    147. About React Hooks

        As mentioned before, we'll build the course project without React Hooks for now (React Hooks are a new feature, introduced with React 16.8, I'll introduce them in-depth later).
        Towards the end of the course, we'll have an entire module where we convert it to use React Hooks though (after having yet another Hooks deep-dive module of course).

    148. Module Introduction
    149. Planning an App in React - Core Steps

        Como planear una applicación React: Pasos Core

        1) Estructura (planificar el árlbol de componentes)
        2) Estado (State)
        3) Componentes vs Contenedores (cuales tienen que mantener el estado y cuales no)
            Es normal que a veces cambiemos sobre la marcha, porque nos damos cuenta que es mejor otra cosa..

    150. Planning our App - Layout and Component Tree

        Modela como va a ser la pagina, y los componentes que va a necesitar.

    151. Planning the State

        Identificar donde necesitamos state, va a ayudar a saber que va a ser un componente o no

        State
            -Ingredients
                -carne
                -queso
            -comprado: true/false
            -totalPrice: 0
            ...
    152. MUST READ: Enabling CSS Modules

        MUST READ (at least the first few paragraphs ... ;-))

        In the next lecture, we'll use a styling solution named "CSS modules". We already had a look at that in the "Styling" section earlier in the course.

        In the next lecture, we'll enable CSS modules and depending on the project setup you're using, the exact steps shown there might not work for you.

        At least if you're not using the starting project you also find attached to the next lecture. If you DO use that, you should be able to continue without issues (and you can skip the rest of this text lecture here).

        ***

        In more recent project versions created by CRA, support for CSS modules is already built-in and you can use that feature without ejecting, please see: https://facebook.github.io/create-react-app/docs/adding-a-css-modules-stylesheet

        I also showed this built-in support in the "Styling" section earlier in the course.

        If you use this approach, you DON'T need to eject. But please don't skip the next videos though, I do explain what CSS modules are and why + how we use them there!

        ***

        Optional:

        If you still want to eject and manually adjust the Webpack config (as we do it in the new videos - which you don't need to do if you follow the approach described in the link above), you should take the below comments into account in case your webpack config (after ejecting) doesn't look the same as it does in my videos:

        After ejecting, we edit a Webpack config file that's made available by ejecting. This file might look slightly different for you.

        In the video, I'll look for an entry that starts like this (in the webpack.config.js file):

        {
        test: /\.css$/,
        ...
        }
        and I then edit this entry.

        This entry now looks slightly different. You'll have to find the following part in your webpack.config.js file:

        {
        test: cssRegex,
        exclude: cssModuleRegex,
        ...
        }
        and then edit that entry.

        Finally, it should look like this:

        {
        test: cssRegex,
        exclude: cssModuleRegex,
        use: getStyleLoaders({
            importLoaders: 1,
            modules: true,
            localIdentName: '[name]__[local]__[hash:base64:5]'
        }),
        }
        You can ignore me editing the webpack.config.prod.js file - with the latest version of create-react-app, ejecting only gives you ONE webpack config file (which you edit as described above).
    153. Setting up the Project
        Habilita Csss Modules, que ahora ya esta habilitada desde la nueva versión.
        Agrega el css de una tipografia y nadamas..

    154. Creating a Layout Component
        Crea las carpetas de componentes/contenedores.
        Crea el componente layout y comenta que usa props.children porque de esa manera va a ir mostrando las cosas en pantalla que esten por debajo de ese componente ??¿¿

        crea una carpeta hoc y adentro un componente aux, que va a utilizar para envolver elementos adyacentes.
            const aux = (props) => props.childre;
            export default aux;

    155. Starting Implementation of The Burger Builder Container
        para agregar estilo, se pone el css y después se importa donde se necesita el estilo y con js se agrega, ej:
        
        import classes from './Layout/Layout.css'
        className={classes.laClaseQueHice}

    156. Adding a Dynamic Ingredient Component
        Si queremos tener un poco de logica nuestra función tiene que arrancar con llaves, sino directamente con parentesis.
        
        Arma toda la parte de los ingredientes de la hamburguesa con una clase de css que el tenía.

    157. Adding Prop Type Validation
        npm install --save prop-types 

        sirve para validar lo que le pasamos a las properties sea lo que realmente esperamos.

        Componente.propTypes = {
            type: PropTypes.string,isRequired;
        }

    158. Starting the Burger Component
        Estila Burger.css 

        En el componente BurgerBuilder, agrega el componente Burger.

    159. Outputting Burger Ingredients Dynamically
        Hace toda una función para mostrar pseudo dinamicament los ingredientes de la hamburgeusa (heardcoders), pero recorre todo el objeto.

    160. Calculating the Ingredient Sum Dynamically
        .reduce((previosValue, currentValue) => {
            return previosValue.concat(currentValue)
        }, [])

        hace esto para poder verificar si no hay ingredientes y mostrar un texto para que el usuario empiece a agregarlos.

    161. Adding the Build Control Component
        Agrega un BuildControls y crea un componente BuildControl, lo estila..

    162. Outputting Multiple Build Controls
        agrega el control al componente principal y con map, mapea todos los controles para agregar los distintos ingredientes.

    163. Connecting State to Build Controls
        genera las funciones de remover y agregar, agrega el codigo necesario a add, como actualizar el precio, y los ingredientes.

        en el componente de mas abajo de todos de los controles, no el ultimo, ya que ese es el que ejuta la funcion nad amas, el anterior, a la función le pase el tipo cuando hace clic, el se encarga de hacer eso no el padre de todos esos componentes, porque es el que tiene la función y el que pasa la referencia a sus componentes hijos.

    164. Removing Ingredients Safely
        copia y pega la de agregar y la modifica para el removr.
        también valida que los ingredientes sean mayor a 0, así cuando intenta remover mas y no hay mas, no hay errres.
        
        genera un flag que inhabilita el ctrl de el ingrediente cuando no hay mas de ese especifico

        pasa la property de disable entre los componentes.

    165. Displaying and Updating the Burger Price
        con .toFixed(2) -> dice que el precio muestre con 2 decimales.

    166. Adding the Order Button
        genera la función que valida si hay al menos u ingrediente para que se habilite el boton de ordernar ahora. agrega la función al final del remover ingredientes o agregar ingredientes para que se llame y justamente verifique si tiene que habilitar el boton o no.

    167. Creating the Order Summary Modal
        crea una carpeta Ui dentro decomponentes, para poner el modal y un par mas,
        a la misma altura que los controles crea un componente orderSumarr que se va a ir actualizando desde el componente raiz con los ingredientes.
        
    168. Showing & Hiding the Modal (with Animation!)
        crea el código para mostrar u ocultar el modal y le da un poco de estilo.
        En el interin tiene un problema con this, por la manera que escribio la función, así que la pasa a una arrow function y listo, solucionado.

        El error pasó porque la función se ejecutaba después de un evento y eso hacía que this no apunte a la función.

    169. Implementing the Backdrop Component
         Se puede retornar null en un componente, esta ok, significa que no queres mostrar nada.

         Genera el overlay y pone el componente dentro del modal porque estan totalmente relacionados.

    170. Adding a Custom Button Component
        Agregar los botones confirmar y cancelar.
        Genera en UI un componente nuevo Button, y le define las propiedades necesarias para utilizarlo y qe sea generico.

        de clase le passa un array, ya que le agrega 2 o mas segun el estado del boton.

    171. Implementing the Button Component
        Lo implementa en OrderSummery
        Le pasa por props a OrderSummery los handlers para los botones.

    172. Adding the Price to the Order Summary
        Usa el precio total que viene por props, y lo muestra.

    173. Adding a Toolbar
        crea el toolbar de la burguer y su css. (un nav con 2 menus)

    174. Using a Logo in our Application
        Dentro de componentes crea una carpeta Logo, dentro de assests tiene el logo de la app.
        
        Importa el logo como si fuera un package.

        en el src={variableConLaQueLoImporte}

        Usa el componente logo donde lo necesita en el toolbar y listo.
        
    175. Adding Reusable Navigation Items
        Dentro de la carpeta Navigation aparte del Toolbar, crea una capreta NavigationItem, NavigationItems y sus js.

        Dentro de NavigationItem.js
            lo que mete acá sería el <li><a href="/"> A Link</a></li>

        Dentro de NavigationItems.js    
            importa el componente NavigationItem

            Lo que pone acá es el ul y pone los navigationItem que necesita.

        Dentro de Toolbar.
            Importa NavigationItems y dentro de <nav> pone NavigationItem.

    176. Creating a Responsive SideDrawer
        Cuando aprestas el boton Menu, el SideDrawer debería aparecer de costado.

        importa el componente Logo y NavigationItems, classes..

        <div className={classes.SideDrawer}>
            <Logo />
            <nav>
                <NavigationItems />
            </nav>
        </div>

        Lo que hace es meterlo detro del componente Layout, junto con el Toolbar.
            <Aux>
                <Toolbar />
                <SideDrawer />
                <main classNAme={classes.Content}>
                    {props.children}
                </main>
            </Aux>
        
    177. Working on Responsive Adjustments
        Le hace modificaciones en el css al SideDrawer
    178. More about Responsive Adjustments
        Css y mas css par todo lo relacionado al layout y mobile.

    179. Reusing the Backdrop
        El backdrop es como el telon que se pone cuando abris un modal. Ahora lo que hace es reutilizarlo
        para el SideDrawer.

        Por ende lo importa y lo usa en el SideDrawer y le pasa a su property show, true o false dependiendo si se tiene que ver o ono (idem el SideDrawer)
        
        Pasa a layout como componente. y pone los handlers necesarios para manejar el mostrar o no el SideDrawer y el backdrop.

        También agrega código para que cuando se hace clic en el overlay, se cierre todo.

    180. Adding a SideDrawer Toggle Button
        Intenta que primero lo hagas vos, después da el resultado:

        Dentro de SideDrawer, crea otra carpeta DrawerToggle y su js.

        Después lo importa en Toolbar y reemplaza la parte del menu con el componente DrawerToggle.

        En el componente pasa una prop clicked, por ende maneja el estado en toolbar, pero como este se usa desde Layout, ahí finalmente va a manejar el handler del evento.

    181. Adding a Hamburger Icon
        Hace lo que dice el modulo.

    182. Improving the App - Introduction
        Habla sobre todo lo que nos enseño, su manera de pensar, que si hay componentes que se podrían mejorar, unir, si hay mejoras de performance que hacer, se va a tratar todo en las siguientes clases.

    183. Prop Type Validation
        Comenta que solamente hice una validación de propiedades, porque es una app que esta haciendo el solo, que si lo aplicaría para un team de trabajo, o si esta haciendo algo open source, etc.
        
    184. Improving Performance
        Empieza a analizar la aplicación y comenta que en OrderSummery, se esta re-renderizando el componente, aún cuando el modal no esta visible, por lo que va a optimizar eso:

        Para verificar eso, pasa el componente de Order a una clase y utiliza el metodo ComponentWillUpdate(), si falla por la versión que tenemos, se puede usar también ComponenteDidUpdate() 

        Hace lo mismo con el modal, ya que verificó que realmente cada vez que agrega un ingrediente se actualiza Order.
        A modal también lo convierte a clase y usa la función shouldComponentUpdate y solo va a actualizar las cosas si show (muestra o no el modal, se cambia a verdadero)


        shouldComponentUpdate(nextProps, nextState) {
            return nextProps.show !== this.props.show;
        }

        También comenta que no es necesario que se convierta en una clase, que debería ser un componente funcional.
    
    185. Using Component Lifecycle Methods
        Side effects en realidad aca se usa como llegar a hacer una llamada a una api y obtener datos de ella.
        Explica la importancia de los metodos que ayudan a verificar si se actualizó un estado o no, etc.

    186. Changing the Folder Structure
        Explica que Layout es un HOC, que podría estar en esa carpeta, pero que tampoco esta mal que este en containers, porque maneja el estado y se lo pasa a los componentes que esta conteniendo.
        
        Que no necesariamente hay que tener una carpeta hoc, podriamos tener solo componentes y containers y tampoco estaría mal. 

        Dentro de la carpeta hoc, agrega una Aux y mete ahí el archivo Aux.js
    187. Wrap Up
        Explica que hicimos nuestra primer app en react, que aprendimos, etc.

    188. Useful Resources & Links
        Useful Resources & Links
        Find the finished code (as well as in-between steps) for this module attached to this lecture.

        Recursos de esta clase
        burger-basics--06-finished.zip
        burger-basics--01-project-setup.zip
        burger-basics--02-after-ingredients.zip
        burger-basics--03-after-build-controls.zip
        burger-basics--04-after-modal.zip
        burger-basics--05-after-navigation.zip

### Sección 9: Reaching out to the Web (Http / Ajax)

    189. Module Introduction
    190. Understanding Http Requests in React
        explica como funciona cuando un cliente hace un request mediante el navegador y que responde el servidor..

    191. Understanding our Project and Introducing Axios
        Habla de que se puede hacer algo con Javascript, pero ya existen paquetes que hacen todo mas facil, como axios.

        npm install axios --save

    192. Creating a Http Request to GET Data
        simula llamadas a una api, con json placeholder

        axios.get(url)
            .then(response => {
                console.log(response);
            }) // cuando se resuelva la promesa, cae en then.

    193. Rendering Fetched Data to the Screen
        guarda la info que retorna la api en el state, y después con map genera los componentes necesarios dependiendo de cuanta info vino en el repsonse.

    194. Transforming Data
        usa slice para en vez de mostrar todos los elementos del response, mostrar solo los primeros 4.
        Envia por atributos/props la info y arregla el componente para que muestre bien todo.
        
    195. Making a Post Selectable   
        Hace una función y se la pasa al componente que termina renderizando un mensaje o la info que seleccionaste.

    196. Fetching Data on Update (without Creating Infinite Loops)
        Valida que el fetch se haga si y solo si, el id que esta queriendo cargar es difernete al que esta cargado.
        Sino esto genera un loop infinito de requests.

    197. POSTing Data to the Server
        axios.post(url, data)
            .then(response => {
                console.log(response);
            })

    198. Sending a DELETE Request
        axios.delete(url, this.props.id)
            .then(response => {
                console.log(response);
            })

    199. Fixing a Bug
        arregla un temita que no se había dado cuenta, que era que cuando hacia click en un post se mostraba el titulo y no el contendido, nad amas.

    200. Handling Errors Locally
        a la llamada de axios aparte de .then, se le puede agregar 
        .catch(response => {
            this.setState({error: true}); 
        })

    201. Adding Interceptors to Execute Code Globally
        Para cuando queres hacer cosas como agregar headers que tienen que ir siempre, en app.js
        importa axios.
        Tiene 2 parametros, en uno recibimos la config del request y después podemos manejar los errores que puedean ocurrir.

        axios.interceptors.request.use(request =>  {
            console.log(request);
            // Editamos la configuración del request (que es lo que hay en request en si)
            return request; // siempre tenemos que retornar request, sino estamos bloqueando el request.
        }, error => { -> esto es para cuando hay errores de conectividad, no un 400 bad request por ej
            return Promise.reject(error);
        })


        También podemos manejar los response.
        axios.interceptors.response.use(response => {
            console.log(response);
            return response;
        }, error => {
            console.log(error);
            return Promise.reject(error);
        });


        Hay otr manera también de acceder a las configuraciones, la muestra en la proxima.

    202. Removing Interceptors
        You learned how to add an interceptor, getting rid of one is also easy. Simply store the reference to the interceptor in a variable and call eject  with that reference as an argument, to remove it (more info: https://github.com/axios/axios#interceptors):

        var myInterceptor = axios.interceptors.request.use(function () {/*...*/});
        axios.interceptors.request.eject(myInterceptor);

    203. Setting a Default Global Configuration for Axios
        En app.js

        axios.defaults.BaseUrl = 'la url de mi api'; -> sacamos en nuestras llamadas la parte del server:port
        axios.defaults.headers.common['Authorization'] = 'AUTH TOKEN'; -> que venga con el token
        axios.defaults.headers.post['Content-Type'] = 'application/json' -> que solo para los post pida esto, se puede con cualquier metodo

    204. Creating and Using Axios Instances
        se puede configurar diferentes url base, usando diferentes instancias.

        crea un nuevo archivo axios.js y:
            importa axios

            const instance = axios.create({
                baseURL: 'mi url',

            })

            //axios.defaults.headers.common['Authorization'] = 'AUTH TOKEN';
            instance.headers.common['Authorization'] = 'AUTH TOKEN'; -> solo para esta instancia con esa url.

            export default instance;

        en donde la necesitamos ahora importamos este archivo en vez de axios.

    205. Wrap Up
    206. Useful Resources & Links
        Useful Resources & Links
        Axios Docs: https://github.com/axios/axios
        Recursos de esta clase
        http--01-starting-setup.zip
        http--02-after-get.zip
        http--03-after-post-error.zip
        http--04-after-global-axios.zip
        http--05-finished.zip

### Sección 10: Burger Builder Project: Accessing a Server

    207. Module Introduction
    208. Firebase & The Right Database
        The Firebase Database console - which we'll see in the next lecture - changed visually.

        Important: Make sure you pick the Realtime Database, NOT Firestore!

    209. Creating the Firebase Project
        Ir a consola > Nuevo proyecto > poner el nombre > destilde Google Analytics. 
        
        Dice que hay que tener en cuenta los planes...
        Setea en rules en true, la opción de lectura/escritura, al menos por el momento.
        Copia la url que le provee que es como un endpoint al que le pegas a la base.


        * La consola que muestra el es bastante diferente de la que tiene actualmente firebase.
          El en este curso usa la opción de realtime database, por si en algún lugar de la consola se llega a ver eso.

    210. Creating the Axios Instance
        crea un archivo axios-order.js y genera una instancia de axios para hacer posteos

    211. Sending a POST Request
        Dentro de la función purchaseContinueHandler

        hace la llamada a axios, y hay que tener en cuenta que para pegarle a la base a la tabla que corresponde en firebase, hay que poner por ej:

        axios.post('/orders.json', objetoConInfo);

    212. Displaying a Spinner while Sending a Request
        
        Crea dentro de la carpeta UI un spinner.js
        Busca en google css spinner, se copia el css, 
        genera el componente en el archivo, props, estado.

        Dentro del modal, en el metodo shouldComponentUpdate, agrega una condición al if, que se renderice lo que esta adentro del componente si cambia show o si nextProps.children !== this.props.children 

    213. Handling Errors
        Implementar Global Error Handling.

        Crea un componente hoc, withErrorHandler, con minuscula (es otra manera de crear un componente), no va a devolver JSX.
        Usa el interceptor de response de axios para obtener si hubo algun error en alguna llamada en el response.
        Crea una función para setear el error en nulo cuando cierra el modal de error.

    214. Retrieving Data from the Backend
        En FireBase, crea la "tabla" ingredients, con las mismas propiedades del objeto con el que inicializaba, ahora en componentDidUpdate realiza la llamada a la base y mete una validación para que no rompa la app ya que ahora ingredients en el state es nulo al arrancar, porque se actualiza después con lo de la base.

        Hay un error por la manera en la que se llaman los componentes cuando son clases y el problema lo tiene porque se utlizan los interceptores, por lo que cambia componentDidUpdate por componentWillMount, en la versión 16.8 ya no existe.
        Agrega los catch a las llamadas con axios que faltaban.

    215. Removing Old Interceptors
        Genera propiedades a la clase donde pone el resultado de los interceptors de req y resp, para usarlo en el componentWillUnmount.
        
        Y utiliza axios.interceptors.request.eject(this.reqInterceptor)
        Y utiliza axios.interceptors.response.eject(this.reqResponse)

        con esto evitamos crear y crear interceptors.

    216. Useful Resources & Links
        Useful Resources & Links
        Find the source code for this module attached to this lecture.

        Recursos de esta clase
        http-burger--01-post-data.zip
        http-burger--02-after-error-hoc.zip
        http-burger--03-finished.zip

### Sección 11: Multi-Page-Feeling in a Single-Page-App: Routing

    217. Module Introduction
    218. Routing and SPAs
        El enrutamiento se trata de poder mostrar diferentes paginas a el usuario.
                        
        Router Package:
        Parsear url / path -> configurar las rutas ->  renderiza / carga el jsx apropiado / componente

    219. Setting Up Links
        Agrega un nav y los links necesarios.
        
    220. Setting Up the Router Package
        npm install --save react-router react-router-dom

        importamos BrowserRouter y envolvemos el div de app por ej, a partir de ahí en todos los subcomponentes se van a poder acceder a las funcionalidades de este componente. (La funcionalidad sería parecida a la de Context)

        import { BrowserRouter } from 'react-router-dom';
        <BrowserRouter>
        ...
        </BrowserRouter>

    221. react-router vs react-router-dom

        We installed both react-router  and react-router-dom . Technically, only react-router-dom  is required for web development. It wraps react-router  and therefore uses it as a dependency. 

        We don't need to install react-router  on our own for it to work. You can omit this installation step, I left it in there for historic reasons and because I like to emphasize that the main package is named react-router. If you ever search for assistance, you probably want to search for "react router" - that's the name of the package.

    222. Preparing the Project For Routing
        Modifica la estructura, cambiando componentes de lugar Post lo saca de adentro de blog...

    223. Setting Up and Rendering Routes
        En Blog, importa Route de react-router-dom

        render -> se le pasa una función por esta prop, dentro de la función se debe retornar jsx
        exact -> prop booleana que exije que se muestre la ruta que realmente es actualmente

        <Route path="/" render={() => <h1>Home</h1>}>

    224. Rendering Components for Routes
        component tiene que hacer referencia a la función o clase que queremos usar por ej Post dentro de Blog.
        En render no debería renderizarse componentes enteros, porque es dificil de mantener después.

        <Route path="/" component={Post}>

    225. Switching Between Pages
        <Route path="/" component={NewPost}>

        Si bien funciona, al pasar de una pagina a otra se recarga toda la pagina y por lo tanto se pierde el state, en el prox muestra como soucionar esto.

    226. Using Links to Switch Pages
        Comenta que no es correcto usar Route, sino que hay que importar y usar Link

        Para eso modifica en en el nav, los <a> por el componente link
        React router genera la etiqueta de anclaje y previene el reload, por lo tanto
        to, apate de ser un string, también se le puede pasar una función, un objeto...

        hash -> esto sirve para si hay algún id con submit, directamente vaya a esa pagina.
        search -> nos habilita a pasar parametros por query
        
        <Link to="/"> Home</Link>
        
        Son ejemplos para que sepamos que existen, pero no lo vamos a usar así.
        <Link to={{
            pathname: '/new-post',
            hash: '#submit', 
            search: '?quick-submit=true', 
        }}> New Post</Link>

        Si hacemos click ahora vamos a ver que no se actualiza la pagina entera (se nota en el icono de reload del navegador, que no se mueve esta vez-)

    227. Using Routing-Related Props
        Muestra en consola las props que tiene Router.

    228. The "withRouter" HOC & Route Props
       Para que un componente que esta routeando a otro, a este último, si queremos pasarle la props de ruteo, hay que decorarlo con withRouter.

    229. Absolute vs Relative Paths
        Absolute: depende siempre del dominio. 

        Relative: podes construir la url con las props, ya que vimos que en match viene parte de la url, entonces lo que harías es:
        pathname: this.props.match + '/new-posts'

    230. Absolute vs Relative Paths (Article)
        Absolute vs Relative Paths (Article)
        You learned about <Link> , you learned about the to  property it uses.

        The path you can use in to can be either absolute or relative. 

        Absolute Paths
        By default, if you just enter to="/some-path"  or to="some-path" , that's an absolute path. 

        Absolute path means that it's always appended right after your domain. Therefore, both syntaxes (with and without leading slash) lead to example.com/some-path .

        Relative Paths
        Sometimes, you might want to create a relative path instead. This is especially useful, if your component is already loaded given a specific path (e.g. posts ) and you then want to append something to that existing path (so that you, for example, get /posts/new ).

        If you're on a component loaded via /posts , to="new"  would lead to example.com/new , NOT example.com/posts/new . 

        To change this behavior, you have to find out which path you're on and add the new fragment to that existing path. You can do that with the url  property of props.match :

        <Link to={props.match.url + '/new'}>  will lead to example.com/posts/new  when placing this link in a component loaded on /posts . If you'd use the same <Link>  in a component loaded via /all-posts , the link would point to /all-posts/new .

        There's no better or worse way of creating Link paths - choose the one you need. Sometimes, you want to ensure that you always load the same path, no matter on which path you already are => Use absolute paths in this scenario.

        Use relative paths if you want to navigate relative to your existing path.

    231. Styling the Active Route
        <NavLink 
            activeClassName="my-active"
            actuveStyle={{
                color: #6546
                textDecoration: underline
            }}
        > 
        de react-router-dom se usa para estilar los links, magicamente te deja estilar los links tiene otras propiedades también, pero bueno la magia de estilar el link que esta activo se maneja con este componente.

        Con actuveStyle se aplican estilos en linea.

    232. Passing Route Parameters
         <Route path="/:id" exact component={Post} />

        Soluciones:
        
        1) Envolver al post con <Link>, al link en to, agregarle el "/" + id, el key lo tenía post, pero ahora como link es el componente mas externo, lo tiene que manejar él.

    233. Extracting Route Parameters
        Ahora si hacemos props.match.params.id vamos a tener el idque pasamos y seteamos en nuestro <Route>

    234. Parsing Query Parameters & the Fragment
        You learned how to extract route parameters (=> :id  etc). 

        But how do you extract search (also referred to as "query") parameters (=> ?something=somevalue  at the end of the URL)? How do you extract the fragment (=> #something  at the end of the URL)?

        Query Params:
        You can pass them easily like this:

        <Link to="/my-path?start=5">Go to Start</Link> 

        or

        <Link 
            to={‌{
                pathname: '/my-path',
                search: '?start=5'
            }}
            >Go to Start</Link>
        React router makes it easy to get access to the search string: props.location.search .

        But that will only give you something like ?start=5 

        You probably want to get the key-value pair, without the ?  and the = . Here's a snippet which allows you to easily extract that information:

        componentDidMount() {
            const query = new URLSearchParams(this.props.location.search);
            for (let param of query.entries()) {
                console.log(param); // yields ['start', '5']
            }
        }
        URLSearchParams  is a built-in object, shipping with vanilla JavaScript. It returns an object, which exposes the entries()  method. entries()  returns an Iterator - basically a construct which can be used in a for...of...  loop (as shown above).

        When looping through query.entries() , you get arrays where the first element is the key name (e.g. start ) and the second element is the assigned value (e.g. 5 ).

        Fragment:
        You can pass it easily like this:

        <Link to="/my-path#start-position">Go to Start</Link> 

        or

        <Link 
            to={‌{
                pathname: '/my-path',
                hash: 'start-position'
            }}
            >Go to Start</Link>
        React router makes it easy to extract the fragment. You can simply access props.location.hash .

    235. Using Switch to Load a Single Route
        Switch basicamente lo que hace es: cargar la primer ruta que realmente coincida y deja de analizar el resto.

        El orden es importante, tampoco es necesario meter todo dentro del switch, hay que ver que hacer depende de lo que necesitemos.

    236. Navigating Programmatically
        Va a mostrar una alternativa a usar link envolviendo en este caso <Post>

        También podemos usar history y pushear la nueva ruta al historial.

        props.history.push({pathname: "/" + props.match.params.id});

    237. Additional Information Regarding Active Links
        Cuando cambiamos de ruta, si estamos usando <NavLink> para estilar. Dice que como es un caso raro, no pasa nada (?)
   
    238. Understanding Nested Routes
        Podes utilizar <Route> en cualquier parte de tu aplicación, siempre y cuando el enutador atrape el componente que lo esta utilizando.

        Para que sea realmente dinamico, en vez de hardcodear /post/id, vamos a usar props.match.url, que es la ruta que llamó a ese componente y después se le suma '/:id', por lo tanto va a matchera con la ruta.
        
    239. Creating Dynamic Nested Routes
        Desde que hicimos las rutas dinamicas, el componente no carga el post especifico, porque como nota que no cambió nada no lo vuelve a renderizar, por lo que para solucionarlo hay que implementar: 

        componentDidUpdate()
        
        mete todo acá y lo llama desde DidUpdate.
        loadData() 

        cuando hacemos esto, se genera un loop infinito, por lo que:
            modifica donde usa props.id por props.match.params.id
        
        después sigue sin funcionar porque tiene chequeo estricto, así que o convertimos a number o le sacamos el stricto y listo.

        # IMPORTANTE # 
        Otra manera de convertir algo a number es meterle un + adelante.

    240. Redirecting Requests
        Una solución diferente a poner una ruta abajo de la otra es, en el switch utilizar 
        <Redirect from="/" to="/post" />

        De esta manera hacemos que el usuario vaya a donde realmente debería estar. 

        Por ej si ahora vamos a  /, nos va a redigir a /posts

    241. Conditional Redirects
        Lo que hace es generar por ejemplo un Redirect, solo si el formulario se submitió, entonces renderiza nu componente <Redirect> condicionalmente.

        <Redirect to="/posts">

        No es necesario que le digamos desde donde from=

    242. Using the History Prop to Redirect (Replace)
        Cambiamos el redirect por push con history.
        Push, lo que hace es enviar la pagina a la pila, por ende podemos volver atrás.
        no así con redirect.

        Redirect reemplaza el lugar donde estabamos, por eso no podemos volver atras.

        También existe props.history.replace, que hace lo mismo que redirigir.

    243. Working with Guards
        Basicamente sirve para utilizar en esas surtas que sabes que el usuario necesita estar autenticado.
        Algo asi como el [Authorized] pero autenticado.
        
        te fijas si el usuario esta logueado y sino no renderizas el componente.

    244. Handling the 404 Case (Unknown Routes)
        Si no se puede catchear ninguna ruta, podemos poner un caso de ruta no encontrada de esta manera:

        <Route render={() => <h1>Not found</h1>} />

        O sea, puede existir la ruta, pero si por ejemplo no la mostramos porque el usuario no esta autenticado, va a terminar cayendo en Not found, y esta ok.

    245. Loading Routes Lazily
        Porque cargamos código del componente que todavía no se navego si no estamos autenticados?
        
        Todo esta movida vale la pena solamente cuando tenemos una aplicación grande. Cuando es una aplicación chica no se justifica.

        La técnica de descargar solo lo que necesita se conoce como división de código o carga diferida.

        Para esto creamos una carpeta hoc -> AsyncComponent.js

        * ver archivo.

    246. Lazy Loading with React Suspense (16.6)
        En vez de hacer lo que hicimos antes, usamos React.lazy() ej:

        const Post = React.lazy(() => import('./containers/Posts'));

        y después en en vez de levantar el componente en Route, usamos ej:


        <Route
            fallback={<div>Loading...</div>} 
            path="/posts" 
            render={() => {
                <Suspense>
                    <Posts />
                </Suspense>
            }}
        />

       No necesariamente necesitamos meter esto dentro de BrowserRouter, podemos usar suspense sin Route siquiera.

    247. Routing and Server Deployment
        La primer parte no entendí a que iba, ver otra vez.
        La segunda parte:
            
            Si tu sitio se aloja en lugar y queda algo asi como
            blabla.com/my-app 
            hay que comunicarle esto a react.

            basename por default no es necesario escribirlo y siempre apunta a la raiz ="/".
            
            Esto se hace en BrowserRouter basename="/my-app"

    Tarea 3: Time to Practice - Routing
    248. Wrap Up
    249. Useful Resources & Links
        React Router Docs: https://reacttraining.com/react-router/web/guides/philosophy
        Recursos de esta clase
        routing--01-start.zip
        routing--02-links-and-routes.zip
        routing--03-after-nested-routing.zip
        routing--04-redirect.zip
        routing--05-finished.zip
        routing--assignment-solution.zip

### Sección 12: Adding Routing to our Burger Project

    250. Module Introduction
    251. Building the Checkout Container

         Crea el componente Checkout, para manejar el estado, ya que es donde se procesan todos los ingredientes, pago etc.

         
        En App.js
            <Layout>
                <BurgerBuilder />
                <Checkout />
            </Layout>

        Para poner css en linea por ej, hace: 
            <div style={{with: 100%, margin: 'auto'}}

    252. Setting Up Routing & Routes

        npm install --save react-router-dom 
    253. Navigating to the Checkout Page

    254. Navigating Back & To Next Page

    255. Passing Ingredients via Query Params

    256. Navigating to the Contact Data Component

    257. Order Submission & Passing Data Between Pages

    258. Adding an Orders Page

    259. Implementing Navigation Links

    260. Fetching Orders

    261. Outputting the Orders

    262. Wrap Up

    263. Useful Resources & Links
        Find the source code for the module attached to this lecture.

        Recursos de esta clase
        routing-burger--01-first-routes.zip
        routing-burger--02-query-params.zip
        routing-burger--03-finished.zip

### Sección 13: Forms and Form Validation

    264. Module Introduction
    265. Analyzing the App
        Habla de poner los input en su propio componente para poder centralizar, poner label y algún manejo de errores.

    266. Creating a Custom Dynamic Input Component
        Lo mete dentro de la carpeta components > UI 
        Genera css, y le pasa la info desde el form que lo usa, no más que eso

    267. Setting Up a JS Config for the Form
        Genera un objeto con los inputs que va a tener el formulario, ej:

        orderForm: {
            name: {
                elementType: 'input',
                elementConfig: {
                    type: 'text',
                    placeholder: 'Your Name'
                },
                value: '',
                validation: {
                    required: true
                },
                valid: false,
                touched: false
            },
        }

       
    268. Dynamically Create Inputs based on JS Config
         después dinamicamente genera el form:

        <form onSubmit={this.orderHandler}>
                {formElementsArray.map(formElement => (
                    <Input 
                        key={formElement.id}
                        elementType={formElement.config.elementType}
                        elementConfig={formElement.config.elementConfig}
                        value={formElement.config.value}
                        invalid={!formElement.config.valid}
                        shouldValidate={formElement.config.validation}
                        touched={formElement.config.touched}
                        changed={(event) => this.inputChangedHandler(event, formElement.id)} />
                ))}
                <Button btnType="Success" disabled={!this.state.formIsValid}>ORDER</Button>
            </form>
            

    269. Adding a Dropdown Component
        Genera en el switch el código para renderizar selects

    270. Handling User Input
        Le agrega los onchage a los input y genera la función:

        inputChangedHandler = (event, inputIdentifier) => {
            const updatedOrderForm = {
                ...this.state.orderForm
            };
            const updatedFormElement = { 
                ...updatedOrderForm[inputIdentifier]
            };
            updatedFormElement.value = event.target.value;
            updatedFormElement.valid = this.checkValidity(updatedFormElement.value, updatedFormElement.validation);
            updatedFormElement.touched = true;
            updatedOrderForm[inputIdentifier] = updatedFormElement;
            
            let formIsValid = true;
            for (let inputIdentifier in updatedOrderForm) {
                formIsValid = updatedOrderForm[inputIdentifier].valid && formIsValid;
            }
            this.setState({orderForm: updatedOrderForm, formIsValid: formIsValid});
        }
    
    271. Handling Form Submission
        Genera la función que va a utilizar el formulario al submitirse.

        orderHandler = ( event ) => {
            event.preventDefault();
    
            const formData = {};
            for (let formElementIdentifier in this.state.orderForm) {
                formData[formElementIdentifier] = this.state.orderForm[formElementIdentifier].value;
            }
            const order = {
                ingredients: this.props.ings,
                price: this.props.price,
                orderData: formData,
                userId: this.props.userId
            }

            this.props.onOrderBurger(order, this.props.token);
            
        }

    272. Adding Custom Form Validation
        Genera la función, con la que se valida si esta bien lla info ingresada en los input o no.
        
        checkValidity(value, rules) {
            let isValid = true;
            if (!rules) {
                return true;
            }
            
            if (rules.required) {
                isValid = value.trim() !== '' && isValid;
            }

            if (rules.minLength) {
                isValid = value.length >= rules.minLength && isValid
            }

            if (rules.maxLength) {
                isValid = value.length <= rules.maxLength && isValid
            }

            if (rules.isEmail) {
                const pattern = /[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/;
                isValid = pattern.test(value) && isValid
            }

            if (rules.isNumeric) {
                const pattern = /^\d+$/;
                isValid = pattern.test(value) && isValid
            }

            return isValid;
        }
    273. Fixing a Common Validation Gotcha
        Mejora esto:
        
        if (rules.required) {
            isValid = value.trim() !== '' && isValid;
        }

    274. Adding Validation Feedback
        if (props.invalid && props.shouldValidate && props.touched) {
            inputClasses.push(classes.Invalid);
        }

    275. Improving Visual Feedback
        Agrega la propiedad touche: false, esto es para que los input no arranquen rojos, como que tuvieran mal la validación.

    276. Showing Error Messages
        We're not showing any error messages in our form, but you can of course easily add some.

        The form inputs (<Input />  component) already receives the information whether it's invalid or not. You could of course easily add some conditionally rendered element inside of that component.

        For example (inside <Input />  component function):

        // all the other code from the videos
        
        let validationError = null;
        if (props.invalid && props.touched) {
            validationError = <p>Please enter a valid value!</p>;
        }
        
        return (
            <div className={classes.Input}>
                <label className={classes.Label}>{props.label}</label>
                {inputElement}
                {validationError}
            </div>
        );
        This could of course be finetuned. You could also pass the value type (e.g. "email address" ) as a prop:

        validationError = <p>Please enter a valid {props.valueType}</p>; 

        You could also receive the complete error message as a prop:

        validationError = <p>{props.errorMessage}</p>; 

        And of course, also don't forget to style the messages if you want to do that:

        validationError = <p className={classes.ValidationError}>{props.errorMessage}</p>;

        In your CSS file, you could have:

        .ValidationError {
            color: red;
            margin: 5px 0;
        } 

    277. Handling Overall Form Validity
        Agrega formValid a los controles del form.

        Hace que el boton no este habilitado si no estan todos los inputs requeridos validados.

    278. Working on an Error
        Arregla un problema con el combo.
        Agrega un validation: {} en el control del select, para que no de error.

    279. Fixing a Bug
        Le pone un valor por defecto al combo, para que se posicione en un value, dice que lo va a arreglar después ??

    280. Useful Resources & Links
        Validate.js (you may import its functionality into your React projects): https://validatejs.org/
        Get more ideas about potential validation approaches: https://react.rocks/tag/Validation
        Alternatives to the manual approach taken in this course:

        react-validation package: https://www.npmjs.com/package/react-validation
        formsy-react package: https://github.com/christianalfoni/formsy-react
        Recursos de esta clase
        forms--01-basic-form.zip
        forms--02-form-validation.zip
        forms--03-finished.zip

### Sección 14: Redux

    281. Module Introduction
        State management, que es el estado y como funciona redux.

    282. Understanding State
        Ingredientes nuevos
        Esta el usuario autenticado?
        El modal esta abierto?
        lista de posteos en nuestro blog, etc...

    283. The Complexity of Managing State
        Si bien podemos manejar el estado y pasar información de un componente A a un componente B mediante queryString a travez de las rutas, se vuelve inmanejable cuando crece la app.

        Si queremos pasar por ej, la información de autenticación de un componente A a B, se puede tornar muy engorroso ya que o lo vamos a manejar pasando de props en props y componentes.. o queryStrings, ahí aparece redux en acción...

    284. Understanding the Redux Flow
        Redux es una libreria de terceros, que si bien vemos que se puede integrar con React, se puede usar sola.

        Como maneja los datos y como se actualiza?
        
        CentralStorage: 
            Tiene el estado de toda la aplicación

        Acciones:
            - Se envian (dispatch) desde los componentes. 
            - Un action, es un es un paquete de información predefinida, por ej "Agregar componente" o "Eliminar componente"
            - Posiblemente también tenga un payload, por ej, si la acción es un ingrediente, necesitamos pasar toda la información sobre QUE ingrediente
            - Una acción no sabe como operar el central storage, no tiene logica, es solo un mensajero. 

        Reducers:
            - Se utiliza para cambiar el central storage.
            - Es una función pura que recibe la acción y el estado viejo.
            - Podemos combinar diferentes reducers en 1. Pero en el "final", simplemente es una ruta reducer que se conecta directamente con el central storage.
            - El reducer puede chequear el tipo de la acción , por ej si es agregar un ingrediente, y cuando definimos el codigo para ese tipo de acción y luego "escupe" un estado actualizado.
            - El reducer ejecuta codigo sincronico, por ende no ejecuta HTTP request, no side effects, nada. Es solo información entrando, respuesta saliendo, nada de delay, igual vamos a aprender a hacer cosas asincronicas.
            - El reducer actualiza el estado del central storage, de una manera inmutable, por lo que siempre retornamos un nuevo estado, que es basado en el viejo pero es tecnicamente un nuevo objeto javascript, porque los objetos son de tipo de referencia y no queremos que accidentalmente cambiemos el objeto viejo.

        Subscriptions Model (Subscriptors?):
             - Sirve para que una vez que el reducer actualiza el estado del central storage, se triggeree la finromación nuevamente al componente que lo necesitaba, para ello el componente debe estar subscripto al modelo de subscripción.   

        EJ:
            Tenemos un componente que quiere manipular el estado, este no lo actualiza directamente modificando central storage

    285. Setting Up Reducer and Store
        Comenta que agrego un proyecto para que bajemos y con el que vamos a ejercitar redux.

        1) Instalación redux:
            > npm install --save redux
        2) Crea el archivo redux-basics.js acá va a poner el Store, Reducer, Dispatching Action, Subscription.

        Estado incial del estado..
            const initialState = {
                counter: 0;
            }

        Reducer:
            Es una función rootReducer que recibe el estado y la acción por parametro.
            return state;
            
            const rootReducer = (state = initialState, action) => {
                return state;
            }

        Store:
            const store = createSotre(rootReducer) ;nos habilita a crear un nuevo store.
                                                    un Store, necesita ser inicializado con un reducer.
            connsole.log(sotre);
    
    286. Dispatching Actions
        Una acción es "enviada" por simplemente acceder al store.


        // Dispatching
         // recibe como parametro una acción, un objeto, que si o si tiene que ser type, por convención su valor tiene que estar todo en mayus.
        store.dispatch({ type: 'INC_COUNTER' });
        store.dispatch({ type: 'INC_COUNTER', value: 10 }); // tiene otro parametro opcional.


        const rootReducer = (state = initialState, action) => {
            if(action.type === 'INC_COUNTER'){
                // state.counter++ -> esto no se puede hacer porque estas mutando su estado original.
                return {
                    ...state,
                    counter: state.counter + 1; // obtiene el estado que acabo de desesctructurar y ahi si, en un nuevo obj le sumo 1.
                };
            }

            return state;
        }

    287. Adding Subscriptions
        // Subscription -> Tienqe que ir antes de los dispatchers.

        store.suscribe(() => {
            console.log('[Suscripción]', store.getState());
        }) // como parametro toma una función que se va a ejecutar cada vez que se actualice el estado.

    288. Connecting React to Redux
         Tenemos que tener en cuenta que hay aplicaciones que no necesitan redux porque no son tan complejas...

         en el archivo index.js, importamos redux: 
            import { createStore } from 'redux';

            // antes de que se renderice la app:
            const store = createStore(reducer);

        # ! Generalmente se puede ver en la estructura del proyecto que hay una carpet store. #

        crea la carpeta store, adentro crea un archivo reducer.js:

            const initialState = {
                counter: 0
            }

            const reducer = (state = initialState, action) => {
                return state;
            }

            export default reducer;

    289. Connecting the Store to React
        Instalamos react-redux, para conectar el store con nuestra app react:
            npm install --save react-redux;

        index.js
            import { Provider }  from 'react-redux';

            envolvemos el componente a renderizar <App /> con el componente Provider.

        Provider: 
            Es un helper component, que nos habilita a "inyectar" nuestro store dentro de los componentes de react.
            le tenemos que pasar una propiedad, le vamos a poner store por sentido comun, y le pasamos el store que creamos.
            <Provider store={}> <App /> </Provider>

        Counter.js 
            Importamos un hoc, una función de redux que nos permite ocnectar con nuestro store. O sea, no es realmente un hoc, sino una función que retorna un hoc.
            En grandes aplicaciones podríamos tener montones y montones de diferentes estados y piezas de estados que manejar.

            import { connect } from 'redux';

            const mapStateToProps = state => {
                return {
                    ctr: state;
                }
            }
            export default connect(mapStateToProps)(Counter); // En el primer param le pasamos cierta config.

            Al hacer esto ahora en nuestro componente, donde mostramos el value que crece o decrece, simplemente utilizamos la prop que acabamos de generar y pasarle a connect:

            // value={this.state.counter}
            <CounterOutput value={this.props.ctr} />

    290. Dispatching Actions from within the Component
        Ahora vamos a aprender a enviar acciones desde nuestro componente.

        También necesitamos una función para enviarle por parametro a connect e informarle que acciones queremos realmente que se envien.
        
        // retorna un obj javascript que va a tener la función que cuando se ejecute va a enviar una acción.
        // pasariamos como nulo el primer parametro a connect si no es necesario, segun lo que tengamos en nuestro componente.
        const mapDispatchToProps = dispatch => {
            return {
                onIncrementCounter: () => dispatch({type: 'INCREMENT'})
            };
        }

        Ahora en el componente <CounterControl pasamos en la prop donde tenemos el handler de la función que hace el incremento, simplemente pasamos this.props.onIncrementCounter


        Ahora tenemos que actualizar en nuestro archivo reducer, el if que verifica las acciones que van llegando.

    Tarea 4: Time to Practice - Dispatching Actions
    291. Passing and Retrieving Data with Action
        cuando pasamos info al dispatch, en el segundo parametro, podemos pasar info por el action.
        después lo manejamos en el reducer.

    292. Switch-Case in the Reducer
        statement expression: switch 

        en el caso default, retornamos solo state;

    293. Updating State Immutably
        en el case arregla los return:

        const newState = Object.assign({}, state);
        newState.counter= state.counter + 1;
        return newState;

        una mejor manera:

        case 'DECREMENT':
            return {
                ...state,
                counter: state.counter + action.val 
            }

        // en este caso esta es la manera correcta:
        case 'STORE_RESULT':
            return {
                ...state,
                results: state.results.concat(state.counter)
            }

        Agrega a mapStateToProps una propiedad:

            storedResults: state.results;

    294. Updating Arrays Immutably
        

        Para eliminar info de un array se usa splice, pero como este lo hace sobre el array existe y nosotros no podemos mutar el original, muestra dos opciones:

        1) 
            const id = 2;
            const newArray = [...state.results]
            newArray.splice(id, 1);

            case 'DELETE_RESULT':
            return {
                ...state,
                results: newArray       
            }

        2) const updatedArray = state.results.filter(result => result.id !== action.resultElId);
            
            case 'DELETE_RESULT':
            return {
                ...state,
                results: updatedArray
            }

    295. Immutable Update Patterns
        Immutable Update Patterns on reduxjs.org: http://redux.js.org/docs/recipes/reducers/ImmutableUpdatePatterns.html

        Updating Nested Objects
        The key to updating nested data is that every level of nesting must be copied and updated appropriately. This is often a difficult concept for those learning Redux, and there are some specific problems that frequently occur when trying to update nested objects. These lead to accidental direct mutation, and should be avoided.

        Common Mistake #1: New variables that point to the same objects
        Defining a new variable does not create a new actual object - it only creates another reference to the same object. An example of this error would be:

        function updateNestedState(state, action) {
            let nestedState = state.nestedState;
            // ERROR: this directly modifies the existing object reference - don't do this!
            nestedState.nestedField = action.data;
        
            return {
                ...state,
                nestedState
            };
        }
        This function does correctly return a shallow copy of the top-level state object, but because the nestedState variable was still pointing at the existing object, the state was directly mutated.

        Common Mistake #2: Only making a shallow copy of one level
        Another common version of this error looks like this:

        function updateNestedState(state, action) {
            // Problem: this only does a shallow copy!
            let newState = {...state};
        
            // ERROR: nestedState is still the same object!
            newState.nestedState.nestedField = action.data;
        
            return newState;
        }
        Doing a shallow copy of the top level is not sufficient - the nestedState object should be copied as well.

        Correct Approach: Copying All Levels of Nested Data
        Unfortunately, the process of correctly applying immutable updates to deeply nested state can easily become verbose and hard to read. Here's what an example of updating state.first.second[someId].fourth might look like:

        function updateVeryNestedField(state, action) {
            return {
                ...state,
                first : {
                    ...state.first,
                    second : {
                        ...state.first.second,
                        [action.someId] : {
                            ...state.first.second[action.someId],
                            fourth : action.someValue
                        }
                    }
                }
            }
        }
        Obviously, each layer of nesting makes this harder to read, and gives more chances to make mistakes. This is one of several reasons why you are encouraged to keep your state flattened, and compose reducers as much as possible.

        Inserting and Removing Items in Arrays
        Normally, a Javascript array's contents are modified using mutative functions like push, unshift, and splice. Since we don't want to mutate state directly in reducers, those should normally be avoided. Because of that, you might see "insert" or "remove" behavior written like this:

        function insertItem(array, action) {
            return [
                ...array.slice(0, action.index),
                action.item,
                ...array.slice(action.index)
            ]
        }
        
        function removeItem(array, action) {
            return [
                ...array.slice(0, action.index),
                ...array.slice(action.index + 1)
            ];
        }
        However, remember that the key is that the original in-memory reference is not modified. As long as we make a copy first, we can safely mutate the copy. Note that this is true for both arrays and objects, but nested values still must be updated using the same rules.

        This means that we could also write the insert and remove functions like this:

        function insertItem(array, action) {
            let newArray = array.slice();
            newArray.splice(action.index, 0, action.item);
            return newArray;
        }
        
        function removeItem(array, action) {
            let newArray = array.slice();
            newArray.splice(action.index, 1);
            return newArray;
        }
        The remove function could also be implemented as:

        function removeItem(array, action) {
            return array.filter( (item, index) => index !== action.index);
        }
        Updating an Item in an Array
        Updating one item in an array can be accomplished by using Array.map, returning a new value for the item we want to update, and returning the existing values for all other items:

        function updateObjectInArray(array, action) {
            return array.map( (item, index) => {
                if(index !== action.index) {
                    // This isn't the item we care about - keep it as-is
                    return item;
                }
        
                // Otherwise, this is the one we want - return an updated value
                return {
                    ...item,
                    ...action.item
                };    
            });
        }
        Immutable Update Utility Libraries
        Because writing immutable update code can become tedious, there are a number of utility libraries that try to abstract out the process. These libraries vary in APIs and usage, but all try to provide a shorter and more succinct way of writing these updates. Some, like dot-prop-immutable, take string paths for commands:

        state = dotProp.set(state, `todos.${index}.complete`, true)
        Others, like immutability-helper (a fork of the now-deprecated React Immutability Helpers addon), use nested values and helper functions:

        var collection = [1, 2, {a: [12, 17, 15]}];
        var newCollection = update(collection, {2: {a: {$splice: [[1, 1, 13, 14]]}}});
        They can provide a useful alternative to writing manual immutable update logic.

        Immutable Data#Immutable Update Utilities section of the Redux Addons Catalog.

    296. Outsourcing Action Types
        Recomienda por ej en un archivo acions.js crear constantes para las acciones, así si hay un error de tipo sabes donde puede estar el problema, y no tenes que andar buscando por toda la app donde pusiste esa variable para el dispatcher y que le pifiaste.

        export const INCREMENTE = 'INCREMENT';
        export const DECREMENT = 'DECREMENT';
        ...ETC

    297. Combining Multiple Reducers
        Divide los reducers en diferentes archivos. Crea una carpeta reducers > counter.js, result.js

        en counter pone los de decremento y incremento.
        en result pone store result y delete result.
        a ambos los exporta default reducer;

        para combinarlos en el archivo index, aparte de importarlos, importa una helper function del paquete de readux, que se llama combineReducers

        const rootReducer = combineReducers({
            ctr: counterReducer,
            res: resultReducer
        });

        y después al createStore se le pasa rootReducer.

    298. Understanding State Types
        Dice que para una aplicación chiquita no es necesario usar redux, pero para una chica>mediana, si. Pero que de todas maneras no es necesario que toda la app lo use, simplemente hay que analizar donde se necesita.

        Tipos de estado:

        Type:               Example:                Use Redux?:
        loca ui state      show / hide backdrop     mostly handled within components.
        Persistent state     All Users... All posts..    Stored on Server, relevant slice managed by Redux.
        Client State        Esta autenticado? Filter set by User        Managed via Redux.


        * No olvidarse que si el usuario recarga la pagina, el estado se pierde, redux no reemplaza una base de datos. * 
    Tarea 5: Time to Practice - Redux Basics

    299. [OPTIONAL] Assignment Solution
        Solución por él de la tarea.
        
    300. Combining Local UI State and Redux
        Muestra combina los dos, useState para manejar los valores que usa el usuario en los input. 
        Y en el boton que usa la función que se creo para redux dentro de mapDispatchToProps

    301. Wrap Up
    302. Useful Resources & Links
        Redux Docs: http://redux.js.org/
        Core Concepts: http://redux.js.org/docs/introduction/CoreConcepts.html
        Actions: http://redux.js.org/docs/basics/Actions.html
        Reducers: http://redux.js.org/docs/basics/Reducers.html
        Redux FAQs: http://redux.js.org/docs/FAQ.html
        Recursos de esta clase
        redux--01-start.zip
        redux--02-basic-flow.zip
        redux--03-react-redux.zip
        redux--04-improved-setup.zip
        redux--05-finished.zip
        redux--assignment-1-solution.zip
        redux--assignment-2-solution.zip

### Sección 15: Adding Redux to our Project

    303. Module Introduction
        Analiza la app de la hamburguesa, para ver donde puede usar Redux y donde deja state.

        Analiza que es local ui state.

    304. Installing Redux and React Redux

    305. Basic Redux Setup

    306. Finishing the Reducer for Ingredients

    307. Connecting the Burger Builder Container to our Store

    308. Working on the Total Price Calculation

    309. Redux & UI State

    310. Adjusting Checkout and Contact Data

    311. Wrap Up
    312. Useful Resources & Links
        Find the source code for this module attached to this lecture.

        Recursos de esta clase
        redux-burger--01-basic-setup.zip
        redux-burger--02-finished.zip

### Sección 16: Redux Advanced

    313. Module Introduction

    314. Adding Middleware

    315. Using the Redux Devtools

    316. Executing Asynchronous Code - Introduction

    317. Introducing Action Creators

    318. Action Creators & Async Code

    319. Handling Asynchronous Code

    320. Restructuring Actions

    321. Where to Put Data Transforming Logic?

    322. Using Action Creators and Get State

    323. Using Utility Functions

    324. A Leaner Switch Case Statement

    325. An Alternative Folder Structure

    326. Diving Much Deeper

    327. Wrap Up
    328. Useful Resources & Links
        Middleware: http://redux.js.org/docs/advanced/Middleware.html

        redux-thunk package: https://github.com/gaearon/redux-thunk

        Async Actions: https://redux.js.org/advanced/asyncactions

        Recursos de esta clase
        redux-adv--01-start.zip
        redux-adv--02-action-creators.zip
        redux-adv--03-async-actions.zip
        redux-adv--04-finished.zip

### Sección 17: Redux Advanced: Burger Project

    329. Module Introduction

    330. Installing the Redux Devtools

    331. Preparing the Folder Structure

    332. Creating Action Creators

    333. Executing Asynchronous Code

    334. Fetching Ingredients Asynchronously

    335. Initializing Ingredients in the BurgerBuilder

    336. Changing the Order of our Ingredients Manually

    337. Adding Order Actions

    338. Connecting Contact Data Container & Actions

    339. The Order Reducer

    340. Working on Order Actions

    341. Redirect to Improve UX

    342. Combining Reducers

    343. Handling Purchases & Updating the UI

    344. Resetting the Price after Purchases

    345. Fetching Orders (via Redux)

    346. Checking our Implemented Functionalities

    347. Refactoring Reducers

    348. Refactoring Reducers Continued

    349. Wrap Up
    350. Useful Resources & Links
        Find the source code for this module attached to this lecture.

        Recursos de esta clase
        redux-adv-burger--01-async-action-ingredients.zip
        redux-adv-burger--02-finished.zip

### Sección 18: Adding Authentication to our Burger Project

    351. Module Introduction
        En MPA generalmente esto se maneja en el servidor mediante session. Acá tenemos un solo archivo, así que vamos a ver como se maneja...

    352. Understanding Authentication in Single Page Applications
        SPA -> envia un auth al SERVER, el server no devuelve una sesión sino un TOKEN (json), generalmente se guarda en el localStorage, no se puede guardar en el estado porque si refresca la pagina se pierde..
        Para hacer ciertos request necesitamos estar autenticados, entonces para no andar validando eso todo el tiempo en el request se envia el token con cierta información

        Si bien acá usamos Firebase, el token se puede generar en cualuqier server.
                                       
    353. Required App Adjustments
        Comenta que va a agregar una vista, que es el formulario de inicio de sesión, que también tenemos que manejar en que endpoints vamos a pedir autenticación y por ultimo tenemos que pasar el token para poder hacer lo anterior.

    354. Adding an Auth Form
        Dentro de containers crea un nuevo componente Auth.
        Reutiliza lo que hizo en el modulo de Form y validaciones.

        Le agrega un css, actualiza codigo..etc

    355. Adding Actions
        Al final termina usando redux.. 
        Agrega un tipo de acción al archivo actionsTypes.js
        crea un archivo auth.js dentro de la carpeta actions.
        // TODO: terminar de ver

    356. Getting a Token from the Backend
        En firebase va a la sección de autenticación, y muestra que hay una opción para marcar donde elegis quedarte con el usuario y password del usuario y se aloja en firebase.
        Enable > save.

        Busca en Google firebase rest auth 
        Busca en Firebase el api key, para pegarle al nuevo endpoint. 
        Autenticación > web setup 

        Elige la url de sing up, la pone dentro del archivo auth, que esta dentro de la carpeta store > actions > auth.js en la parte donde se exporta la función auth, ahí hace el post.

        Verifica que datos tiene que mandarle en el body al endpoint, lo prueba y muestra por consola que le retorno bien la info.

    357. Adding Sign-In

    358. Storing the Token
        Dentro de la carpeta reducer, genera un archivo auth.js 

    359. Adding a Spinner

    360. Logging Users Out

    361. Accessing Protected Resources

    362. Updating the UI Depending on Auth State

    363. Adding a Logout Link

    364. Forwarding Unauthenticated Users

    365. Redirecting the User to the Checkout Page

    366. Persistent Auth State with localStorage
        Agrega en el local storage el token que obtiene, y también en localStorage agrega un expirationDate.

        let expirationDate = new Date(new Date().getTime() + response.data.expiresIn * 1000);
        localStorage('expirationDate', expirationDate);

    367. Fixing Connect + Routing Errors

    368. Ensuring App Security

    369. Guarding Routes

    370. Displaying User Specific Orders

    371. Wrap Up
    372. Useful Resources & Links
        SPA Authentication in general: https://stormpath.com/blog/token-auth-spa
        Firebase authentication REST API: https://firebase.google.com/docs/reference/rest/auth/ 
        Recursos de esta clase
        auth--01-form-actions.zip
        auth--02-auth-store.zip
        auth--03-token.zip
        auth--04-finished.zip

### Sección 19: Improving our Burger Project

    373. Module Introduction
    374. Fixing the Redirect to the Frontpage
        Arregla un flag que le había quedado mal en purchaseBurgerStart (el loading lo pasó a true)

        Cuando submite la orden, se redirige al index con todo vacio.
            Vuelve a poner la ruta de auth, porque dentro de ese componente estaba la funcionalidad y como no hace daño volver a ponerlo, es la solucion mas rapida que encontró.

        fixea el css de la hamburgeusa porque no esta bien centrado..

    375. Using updateObject in the Entire App
        Crea una carpeta shared y pasa el archivo utility.js ahí adentro.
        actualiza las referencias al archivo en los import.

        en updatedFormElement = updateObject(this.state.orderForm[inputIdentifier], 
            value: event.target.value,
            valid: this.checkValidity(updatedFormElement.value, updatedFormElement.validation),
            touched: true
        )

        mismo para orderForm

        verifica en otros archivos y hace lo mismo.

    376. Sharing the Validation Method
        a la función checkValidity, la mete en el archivo utility.js, la usa para validar cosas del formulario.

        elimina el metodo de los archivos, importa la función y le saca el this a la función en los archvos.

    377. Using Environment Variables
        Hace que la dev tools de redux se vea solo en dev con las variables de entorno.

    378. Removing console.log()s
        Elimina los console.log...
        
    379. Adding Lazy Loading
        Carga diferida.
        Agrega dentro de la carpeta hoc > asyncComponent 
        le pega info que hizo en la sección de enrutamiento

        Genera una para cada una, order, auth, etc.

        * No se debe usar siempre y para cualquier cosa, porque si son cosas chicas ni vale la pena hacer esto.

    380. Wrap Up
    381. Useful Resources & Links
        Find the source code for this module attached to this lecture.

        Recursos de esta clase
        burger-improvements--01-finished.zip

### Sección 20: Testing

    382. Module Introduction
    383. What is Testing?
        Build App > Testear manualmente en el navegador > Tests Automaticos > Ship App to Server.

    384. Required Testing Tools
        Necesitamos 2 cosas:

        Un corredor de test.
        Ejecutar test y tener una libreria de validación.
        React viene con Jest instalado.

        Generamos test unitarios
        Simulamos la app, montamos componentes y de esto nos permite consumir el DOM.
        React Test Units.
        
        Enzyme es otra herramienta como Jest, creada por el equipo de Airbnb (también recomendada por el team de React), esta herramienta hace mas facil montar componentes y navegar entre ellos.
        
    385. What To Test?

        Que NO queres testear:
            No queres testear la libreria, ni react, ni axios, redux, etc. Todo esto ya fue testeado por el que lo creó.

            No queres testear conecciones complejas.

        Lo que si queres:
            - Mockear y generar data fake.
            - Unidades aisladas, por ej una función que creaste, un componente.
            - Output condicional.

    386. Writing our First Test
        
        enzyme             -> Nos permite cargar un componente por si mismo, sin dependenr de toda la app.     
            Estos dos packages, son complementos para enzyme.
            react-test-render           -> dependencia de enzyme.
            enzyme-adapter-react-16     -> adaptador de enzyme para nuestra versión actual.
        
        jest               -> ya viene instalado.

        npm install --save enzyme react-test-render 

        Va a testear NavigationItems, en la misma carpeta crea un js con el mismo nombre del componente pero le agrega test, ej: NavigationItems.test.js 

        describe es una función que toma 2 argumentos
            1) Lo que se va a testear, el puso el nombre del componente x ej 
            2) Testing arrow function.

        It te permite escribir un test individual, también tiene 2 argumentos.
            1) Una descripción de lo que se esta testeando
            2) Testing arrow function.
        
        import React from 'react';
        import { configure, shallow } from 'enzyme';
        import Adapter from 'enzyme-adapter-react-16';

        import NavigationItems from './NavigationItems';
        import NavigationItem from './NavigationItem/NavigationItem';

        // Para conectar enzyme con mi app.
        configure({adapter: new Adapter});

        describe('<NavigationItems />', () => {
            it('should render two <NaviationItems /> elements if not authenticated', () => {
                // testing logic
                const wrapper = shallow(<NavigationItems />);
                expect(wrapper.find(NavigationItem)).toHaveLength(2); // osea, que haya 2 componentes.
            })
        })

        * shallow, es un helper (una función),que usamos para renderizar el componente con todo su contenido, pero todo no es completamente cargado, osea no todo el sub arbol de componentes.
        * wrapper en realidad puede ser pepito.
        * en expect definimos lo que queremos chequear.
        * find es una utilidad de enzyme que nos permite ver dentro del componente y chequear si existe lo que necesitamos.

        Para correr los test, primero chequeamos que en package.json este el script de test.

        npm test
        * Si llega a haber un error, eliminar el test de App.test.js

    387. Testing Components Continued

        // Agrego otro test, ahora verifico que haya 3 componentes y le paso al componente la prop que necesita para que se rendericen los 3.

        import React from 'react';
        import { configure, shallow } from 'enzyme';
        import Adapter from 'enzyme-adapter-react-16';

        import NavigationItems from './NavigationItems';
        import NavigationItem from './NavigationItem/NavigationItem';

        // Para conectar enzyme con mi app.
        configure({adapter: new Adapter});

        describe('<NavigationItems />', () => {
            // Si se repiten ciertas cosas, podemos usar este setup general:
            let wrapper;

            beforeEach(() => {
                wrapper = shallow(<NavigationItems />);
            })

            it('should render two <NaviationItems /> elements if not authenticated', () => {
                expect(wrapper.find(NavigationItem)).toHaveLength(2); // osea, que haya 2 componentes.
            });

            it('should render two <NaviationItems /> elements if not authenticated', () => {
                // Como este necesitaba que se pase una prop para correr bien, lo podemos setear de esta manera: 
                wrapper.setProps({ isAuthenticated: true });
                expect(wrapper.find(NavigationItem)).toHaveLength(3);
            })
        })

    388. Jest and Enzyme Documentations
        
        Para ver todas las cosas que podemos usar de los packages: 
        Enzyme API: http://airbnb.io/enzyme/docs/api/
        Jest Docs: https://facebook.github.io/jest/

        it('should render two <NaviationItems /> elements if not authenticated', () => {
            wrapper.setProps({ isAuthenticated: true });
            expect(wrapper.contains(<NavigationItem link="/logout"> Logout </NavigationItem)).toEqual(True);
        })

    389. Testing Components Correctly

        Escribir test correctos es complicado. Siempre hay algo que se nos puede escapar.
        Lo que dice es que hay que escribir test de las cosas que sabemos que pueden romper todo, por ej un if negado, cuando no era negado y así.

    390. Testing Containers

        Como tenemos setProps también tenemos setTest para poder mockear estados.

        Le agregamos export adelante de la clase, para exponerla y poder testearla. Esto no choca con el export default que ya tenemos.

        en el test, por ej BurgerBuilder.test.js, la importamos así:

        import { BurgerBuilder } from './BurgerBuilder';

        Lo que hace es verificar si se encontra el componente BurgerBuilder, ya que se muestra solo si no hay ingredientes.

    391. How to Test Redux
        
        Hay testear Redux, pero hay que tener cuidado qué testeamos.
        Si seguimos el patron de no poner demasiada logica dentro de en la creación de los actions.
        Como son sincronicos y funciones que se les pasa y devuelven algo, es mas facil de testear.

        import reducer from './auth';
        import * as actionTypes from '../actions/actionTypes';

        describe('auth reducer', () => {
            it('should return the initial state', () => {
                expect(reducer(undefined, {})).toEqual({
                    token: null,
                    userId: null,
                    error: null,
                    loading: false,
                    authRedirectPath: '/'
                });
            });

            it('should store the token upon login', () => {
                expect(reducer({
                    token: null,
                    userId: null,
                    error: null,
                    loading: false,
                    authRedirectPath: '/'
                }, { 
                    type: actionTypes.AUTH_SUCCESS,
                    idToken: 'some-token',
                    userId: 'some-user-id'
                })).toEqual({
                    token: 'some-token',
                    userId: 'some-user-id',
                    error: null,
                    loading: false,
                    authRedirectPath: '/'
                });
            })
        });

    392. Wrap Up
    393. Useful Resources & Links
        Enzyme API: http://airbnb.io/enzyme/docs/api/
        Jest Docs: https://facebook.github.io/jest/
        Recursos de esta clase
        testing--01-finished.zip

### Sección 21: Deploying the App to the Web

    394. Module Introduction
    395. Deployment Steps
        chequear y quizas actualizar basePath
        buildear y optimizar el proyecto. 
            -> npm run build // in create-react-app project
        el servidor siempre tiene que servir el index.html (sino da 404) -> 
        actualizar el artefacto a static del build 
            ->  githubpages o firebase se puede implementar porque es todo estatico, no hace falta un servidor, tendría que haber una carpeta /build

    396. Building the Project
        corre el comando npm run build
        muestra la carpeta build que se creo con todo minimizado...

    397. Example: Deploying on Firebase
        En la consola de firebase > setup hosting > npm install -g firebase-tools > continue > firebase login > firebase init > firebase deploy
        hosting hay que elegir en login, después la carpeta build, si, es una SPA, no a sobreescribir el index y listo
        te genara un link tipo firebase.burgerApp.com bla entras y listo.

        parecido a heroku.

    398. Wrap Up
    399. Useful Resources & Links
        Useful Resources & Links
        Attached to this lecture, you'll find the module source code.

        Recursos de esta clase
        deployment--01-finished.zip

### Sección 22: Bonus: Working with Webpack

    400. Module Introduction
    401. Introducing Webpack
        
        Es un bundler, pero es mas que eso. Un bundler solo concatenaría archivos. 

        También optimiza archivos, conectar complementos, loaders, transformarlos, transpilarlos, etc.

        La de gral es: tenes multiples archivos, js, css e imagenes, cualquier archivo y lo que hace webpack es analizar cada uno, bundlearlos pero a su vez, verificar cuales estan conectados (imports)...

    402. How Webpack works

        De tras de escena, webpack tiene 4 features importantes:
        
        1) Necesita al menos un entry point, por ej App.js
            Ya que ahí es donde se inserta todo en el dom y analiza este archivo verificando sus dependencias.
        
        2) Loaders:
            Esto esta en el medio, ej loaders (babel-loader, css-load). O sea, lo que vos le decis al loeader es como va a manejar todos los archivos de un determinado tipo, por ejemplo los de js van a ser manejados por tal package.

        3) Plugins:
            Concatenan los files, ej uglify, esta de manera global, minifica los archivos, optimizandolos.

        4) Analiza todas las dependencias y genera un unico archivo por ej dist/output.js, de manera ordenada y concatenadas.

    403. Basic Workflow Requirements

        Vamos a analizar los requesitos que tenemos:
            1) Compilar next-gen javascript features.
            2) Handle JSX, o sea, que podamos usar jsx.
            3) CSS Autoprefixing. O sea, manejar la mayor cantidad de sintaxis en los diferentes navegadores.
            4) Soportar imagenes. O sea, importarlas como si fuera un archivo.
            5) Optimizar el código (minificar los js)

    404. Project & npm Setup

        1) Crea un archivo .gitignore
            node_modules

        2) npm init
        3) npm install --save-dev webpack webpack-dev-server      -> Solo para desarrollo. Estos dos paquetes van de la mano.
        4) 

    405. Creating a Basic Folder & File Structure
        
        Recrea algo semejante a la estructura de cra.

        src/
            assets/
            components/
            containers/
            index.css               --> para estilos globales. 
            index.js                   
            index.html
                <div id="root">
            App.js                  --> Mi componente root.
            
    406. Creating the Basic React Application
        components/
            PizzaImage/
                PizzaImage.js
                PizzaImage.css
        
        containers
            Pizza.js
            Users.js
        
        assets/
            pizza.jpg

        
        hoc/
            asyncComponent.js       -> Usar el componente que ya creo antes, para cargar componentes de manera lazy. 

        index.js
            Agrega BrowserRouter y envuelve <App /> y renderiza app con ReactDOM.

    407. Installing Production Dependencies

        Core dependencies:
            npm install --save react react-dom react-router-dom

    408. Setting Up the Basic Webpack Config

        Agregar en package.json un script para start

        1) "start": "webpack-dev-server"   -> Usa este package y ejecutalo (así tal cual no pasa nada. hay que instalar una dependencia mas, te lo dice en la consola).

        2) npm install --save-dev webpack-clic

        3) Si intentas correr npm start, te tira un error porque webpack no sabe que hacer con index.js no entiende que tiene que hacer.
           
           Agrega un archivo webpack.config.js provee la configuración para webpack.

           const path = require('path');    -> este paquete ya viene con node js.
           //__dirname  es una variable global que existe en node.

           module.expots = {
               mode: 'development',         -> le dice a webpack que optimizaciones hacer según el amb.
               entry: './src/index.js',
               output: {
                   path: path.resolve(__dirname, 'dist'),
                   filename: 'bundle.js',
                   publicPath: ''
               },
               devtool: 'cheap-module-eval-source-map'     -> controla como se genera el source map en debug x ej, si lo transforma o no. en la paguina oficial esta esto.
           };

    409. Adding File Rules & Babel

        Vamos a agregar para que entienda next-gen javascript, para eso tenemos que instalar Babel.
        
        Lo que hace Babel es transpilar los features nuevos de javascript a los viejos para que sean compatbiles en todos los navegadores.

        npm install --save-dev @babel/core @babel/preset-env @babel/preset-react @babel/preset-stage-2 babel-loader @babel/plugin-proposal-class-properties

        const path = require('path');    -> este paquete ya viene con node js.

           module.expots = {
               mode: 'development',         -> le dice a webpack que optimizaciones hacer según el amb.
               entry: './src/index.js',
               output: {
                   path: path.resolve(__dirname, 'dist'),
                   filename: 'bundle.js',
                   publicPath: ''
               },
               devtool: 'cheap-module-eval-source-map',     -> controla como se genera el source map en debug x ej, si lo transforma o no. en la paguina oficial esta esto.
               module: {       
                   rules: [     -> cada regla es un objeto, donde vas a tener una propiedad test con una expression regular, donde vas a indicar que archivos van a estar alcanzados por cierta herramienta/plugin, por ej los archivos javascript, van a ser alcanzados por el loader y la herramienta va a ser babel-loader.
                       {
                           test: /\.js$/,
                           loader: 'babel-loader',
                           exclude: /node_modules/  -> no queremos que alcance la carpeta.
                       }
                   ]
               }
           };

            Creamos un nuevo archivo .babelrc es un archivo de confugración para babel que se escribe en formato JSON.
            Todo esto esta en la pagina oficial de Babel.

            {
                "presets": [ -> acá tenemos que aplicar todos los presets que queremos.
                    [
                        "@babel/preset-env", 
                        {
                            "targets": {
                                "browsers": ["> 1%", "last 2 versions"] -> compila para que compile en estos browser.
                            }
                        }
                    ],
                    "@babel/preset-react"   -> no necesita ser un array porque no es necesario presets.
                ],
                "plugins": [    -> config extra o comportamiento.
                    "@babel/plugin-proposal-class-properties"   -> controla que sintaxis soporta.
                ]
            }

    410. Loading CSS Files
        
        npm install --save-dev style-loader css-loader (uno analiza los css y el otro toma los css y los inyecta en nuestro html. (style))

        agrega una regla al archivo webpack:

        {
            test: /\.css$/,
            exclude: /node_modules/,
            use: [
                { loader: 'style-loader' },
                { 
                    loader: 'css-loader', 
                    options: {  -> necesita config extra para aceptar css-modules.
                        importLoaders: 1,
                        modules: {
                            localIndentName: '[name]__[local]__[hash:base:5]'
                        }
                    }
                },
                { 
                    loader: 'postcss-loader',  -> nos ayuda con el procesamiento de css y prefinxing para que pueda funcionar en navegadores viejos.
                    options: {
                        ident: 'postcsss',
                        plugins: () => [autoprefixer()]
                    }
                }

            ]
        }

        npm install --save-dev postcss-loader  
        npm install --save-dev autoprefixer 
            Abajo del import de path en el archivo webpack:

            const autoprefixer = require('autoprefixer');
                se agrega a la parte de plugins de postcssloader.
            
        en package.json agrega un script debajo de "licence"

        "browserslist": "> 1%, last 2 versions",

    411. Loading Images & Injecting into HTML Page

        Nos ayuda a cargar assets
            npm install --save-dev url-loader

        Dentro de webpackconfig
            {
                test: /\.(png|jpe?g'|gif)$/,
                loader: 'url-loader?limit=8000&name=images/[name].[ext]'
            }

        Para inyectar todas las transformaciones qe configuramos anteriormente en html:
            npm install --save-dev html-webpack-plugin
                arriba de todo abajo de autoprefixer
                    const HtmlWebpackPlugin = require('html-webpack-plugin');

            dentro del config de webpack, antes del } final:

            plugins: [
                new HtmlWebpackPlugin({
                    template: __dirname + '/src/index.html',    
                    filename: 'index.html',
                    inject: 'body'
                })
            ]

        npm install --save-dev file-loader  -> otro package necesario para webpack.

    412. Production Workflow & Wrap Up

        Copiamos y pegamos el webpack config y creamos un webpack.config.prod.js

        modificamos el development mode: 'production', en devtool: 'none'
        Agregamos un script debajo de start:
        
            "build:prod": "webpack --config webpack.config.prod.js"        

        npm start -> vemos como se genera la carpeta dsit y esta todo bundleado.

    413. Adding babel-polyfill

        The current setup won't support all browsers theoretically supported by React. Features like Promises and Object.assign() are missing in older browsers - especially in IE of course.

        If you need to support these browsers, you need to add a polyfill (a package which provides these features for older browsers).

        The Babel docs explain how you can take advantage of Babel's built-in "Polyfill auto injecting" feature: https://babeljs.io/docs/en/babel-polyfill

        Simply install two packages:

        npm install --save core-js

        and

        npm install --save regenerator-runtime 

        Change the config of your @babel/preset-env  babel preset in the .babelrc  file: 

        "presets": [
            ["@babel/preset-env", {
                "targets": {
                    "browsers": [
                        "> 1%",
                        "last 2 versions"
                    ]
                },
                "useBuiltIns": "usage"
            }],
            ...
        ],

    414. Useful Resources & Links
        Webpack Docs: https://webpack.js.org/concepts/
        More about Babel: https://babeljs.io/
        Recursos de esta clase
        webpack--01-basic-react-app.zip
        webpack--02-added-babel.zip
        webpack--03-finished.zip

### Sección 23: Bonus: Next.js

    415. Module Introduction

        Es una libreria basada en react, fuerza una estructura especifica y nos da server side rendering y configuración extra que no tenemos que hacer a mano. 

        Server side rendering ayuda mucho a los search engine

    416. Understanding Server Side Rendering

        Server Side Rendering simplemente significa, cuando un usuario entre a una url, se va a estar pre-renderizando esa pagina, del lado del servidor y lo va a retornar ya "cocinado"

        O sea, el cliente hace un request al server, el server hace el fetch y renderiza la app, retorna renderizada la primer pagina + react app bundle y en el cliente se re-renderiza la SPA.

    417. Setting Up a Project
        Web Next js: https://nextjs.org/
        
        Esto que vamos a hacer lo hace con el paso a paso que esta en github
            https://github.com/zeit/next.js/

            Actualmente esto no esta mas en github, sino en la pagina oficial, hay ciertas partes que ya no estan igual, yo voy a seguir como lo da el en el curso:
                https://nextjs.org/learn/basics/getting-started

        1) .gitignore
        2) npm init
        3) npm install --save next react react-dom
        4) package.json

            "scripts": {
                "dev": "next",
                "build": "next build",
                "start": "next start"
            }

            No se usa react-router, se usa file-system es la API main de Next js. Basicamente lo que se usa es carpetas y archivos para ir ruteando nuestra url, next js parsea esto y usa su propio ruteador interno, pre renderiza y automaticamente splitea y con lazy load lo muestra.

        5) creamos:
            pages/
                auth/
                    index.js
                index.js

            * podes usar clases, funcional componentes, state, etc.

            index.js
                import React from 'react';

                const indexPage = () => {
                    <div>
                        <h1> Main Page </h1>
                    </div>
                };

                export default indexPage;

            auth/index.js
                import React from 'react';

                const indexPage = () => {
                    <div>
                        <h1> Auth index Page </h1>
                    </div>
                };

                export default indexPage;

        6) npm run dev
           
           En localhost vamos a ver main page y en localhost/auth vamos a ver auth index page :O

    418. Understanding the Basics

        import Link from 'next/link';
        import Router from 'next/router';

        <Link href="/auth"> Auth </Link>
        <button onClick={() => Router.push('/auth')}> Go to Auth </button>

    419. Next.js & Components & Pages

        components/
            User.js

        Al componente lo importamos en otro js como cualquier import.

    420. Styling our App in Next.js

        Next JS tiene su propia manera de estilar. Podemos usar Radium, podes usar estilos en linea, no podemos usar CSS Modules.

        Styled-jsx 
        
        <style jsx> {`
            div {
                border: 1px solid black;
            }
        `} </style>

    421. Handling (404) Errors
        Next js tiene una pagina por default para esto, si se quiere sobreescribir hay que generar un archivo _error.js dentro de pages.

    422. A Special Lifecycle Hook
        
        Transforma el componente funcional en un componente de clase.

        usa una función nueva que también esta en functional components.

        Static puede ser llamado sin ser instanciado y es asincrono, retorna algo instantaneamente.
            Se puede usar async o no. * 
        Sirve para inicializar tu app antes de que se cargue.
            Podríamos traer info de la bd x ej.

        static async getInitialProps(context){
            // console.log(context);
            const promise = new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve({appName: 'Super App});
                }, 1000);
            });
            return promise;
        }

        Después lo usamos en el retorno de jsx.
            <h1> this.props.appName </h1>

        Solo va a renderizar esa parte, cuando se retorne la promesa.

        * Hace el ejemplo también con functional components.

    423. Deploying our App

        npm run build   -> para buildear el proyecto para deployarlo.

    424. Useful Resources & Links
        Next.js Repo & Docs: https://github.com/zeit/next.js/
        Recursos de esta clase
        nextjs--01-finished.zip

### Sección 24: Bonus: Animations in React Apps

    425. Module Introduction

    426. Preparing the Demo Project

    427. Using CSS Transitions

    428. Using CSS Animations

    429. CSS Transition & Animations Limitations

    430. Using ReactTransitionGroup

    431. Using the Transition Component

    432. Wrapping the Transition Component

    433. Animation Timings

    434. Transition Events

    435. The CSSTransition Component

    436. Customizing CSS Classnames

    437. Animating Lists

    438. Alternative Animation Packages

    439. Wrap Up
    440. Useful Resources & Links
        More on CSS Transitions: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions
        More on CSS Animations: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations
        More on ReactTransitionGroup: https://github.com/reactjs/react-transition-group
        Alternative => React Motion: https://github.com/chenglou/react-motion
        Alternative => React Move: https://github.com/react-tools/react-move
        Animating Route Animations: https://github.com/maisano/react-router-transition

### Sección 25: Bonus: A Brief Introduction to Redux Saga

    441. Module Introduction

    442. Installing Redux Saga

    443. Creating our First Saga

    444. Hooking the Saga Up (to the Store and Actions)

    445. Moving Logic from the Action Creator to a Saga

    446. Moving More Logic Into Sagas

    447. Handling Authentication with a Saga

    448. Handling Auto-Sign-In with a Saga

    449. Moving the BurgerBuilder Side Effects into a Saga

    450. Moving the Orders Side Effects into Sagas

    451. Why Sagas can be Helpful

    452. Diving Deeper into Sagas

    453. Useful Resources & Links
        Find the module source code attached to this lecture.

        Useful Links:

        Redux Saga: Full Documentation => https://redux-saga.js.org/
        Advanced Concepts: https://redux-saga.js.org/docs/advanced/
        API Reference: https://redux-saga.js.org/docs/api/
        Pros & Cons for Redux Saga vs Thunks: https://stackoverflow.com/questions/34930735/pros-cons-of-using-redux-saga-with-es6-generators-vs-redux-thunk-with-es2017-asy/34933395
        Recursos de esta clase
        redux-saga--01-start.zip
        redux-saga--02-auth.zip
        redux-saga--03-burger-builder.zip
        redux-saga--04-orders.zip
        redux-saga--05-finished.zip

### Sección 26: React Hooks - # TEORIA #

    454. Introduction
    455. What are "React Hooks"?

        Nos ayuda a trabajar con nuestros componentes de una manera mas eficiente.

        1) Functional:
            Props in, JSX out
            Great for Presentational
            Focused on one/few purpose(s)

        2)  Funcional With Hooks 
            Nos permite trabajar con functional components only.
            Hooks, reemplaza las funcionalidades de las clases (el manejo de estado) 
                (que por eso las teníamos que usar, si bien podes crear clases, no es obligación. 

        3) Class-based:
            Uses props and state
            Business logic goes in here
            Orchestates components.
            Lifecycle hooks (can be hard to use)

        - Para usar uno u otro, hay que convertirlos o desconvertirlos y es bastanta molesto.
        
        React hooks: 
                Estan en React desde la versión 16.8
                Se llaman así porque "enganchas" un "function component", con cierta funcionalidad.
                simplemente funciones javascript.
                Los nombres de las funciones de React hooks arrancan con useAlgo()
                Con Hooks, podes hacer que todo sean functional components, no necesitas mas clases.

            Se pueden usar:
                dentro de funcional components.        
                dentro de otros hooks.
                Son reutilizables e independientes de cada componente.

            También podemos:
                escribir nuestros propios hooks.
                Compartir la logica completa o sin estado entre multiples componentes.

            No son - no tienen que ver:
                No se pueden reemplazar los metodos de ciclo de vida con react hooks.
            
        La idea de los hooks, es que vos podes exponer cierta (posiblemente stateful funcionalities) a functions components, como manejar el estado, como el ciclo de vida de los componentes.

        # IMPORTANTE #
            Lifecycle hooks, son sinonimo de los metodos de ciclo de vida y solo se pueden usar en componentes basados en clases.

    456. The Starting Project
        
        Habla sobre el proyecto que dejó adjunto y sobre que no tiene ni una clase, son todos componentes de funciones.

    457. Getting Started with useState()
        Core Hook!

        Como usarlo:
            - Agregar al import de react, useState entre { }
            - useState() -> puede ser inicializado con cualquier tipo. No solo con un objeto como en las clases componentes.
            - Es mas facil inicialiarlos como string, ya que por mas que el input sea de otro tipo, el valor que se pone en el atributo value termina siendo siempre un string.
            - Devuelve una matriz con exactamente dos elemetos: 
        
            1) el valor actual 
            2) una función que te permite retornar el valor actualizado.

            const inputState = useState({title: '', amount: ''});

            en nuestro input:
                value={inputState[0].title} 
                onChange={event => useState[1]({title: event.target.value})}

    458. More on useState() & State Updating
        https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures

        Los que nos enseño recién NO SIRVE, NO SE HACE ASÍ, porque se esta pisando la información, no actualizando la propiedad especifica del objeto, esta creando un objeto nuevo y perdiendo la información de amount o de title si es que empezas a escribir por amount.

        const inputState = useState({title: '', amount: ''});

        Se podría solucionar así, pero tampoco es la manera correcta, porque no podemos quedarnos tranquilos de que sea el ultimo snapshot del estado de los elementos.

            en nuestro input:
                value={inputState[0].title} 
                onChange={event => inputState[1]({title: event.target.value, amount: useState[0].amount })}

        La solución es:
            value={inputState[0].title} 
            onChange={event => {
                const newTitle = event.target.value;
                inputState[1](prevInputState => ({
                    title: newTitle, 
                    amount: prevInputState.amount 
                }));
            }}

    459. Array Destructuring 

        const [ inputState, setInputState ] = useState({title: '', amount: ''});

        value={inputState.title} 
        onChange={event => {
            const newTitle = event.target.value;
            setInputState(prevInputState => ({
                title: newTitle, 
                amount: prevInputState.amount 
            }));
        }}

    460. Multiple States
        La manera correcta ya que la otra es inmantenible y aparte si tenes mas de un input en el form te volves loco, es:
        const [ enteredTitle, setEnteredTitle ] = useState('');
        const [ enteredAmount, setEnteredAmount ] = useState('');

        value={enteredTitle} 
        onChange={event => {
            setEnteredTitle(event.target.value);
        }}

    461. Rules of Hooks
        Entendiendo useState...

        - Podemos llamarlo con un estado inicial o no. 
        - Se crea un estado que se maneja "detras de escena" por React, que sobrevive re-render cicles.
        - Lo que obtenemos es una matriz con dos elementos, el primero es un puntero a tu estado y es el segundo es    una función de update del estado.

        # IMPORTANTE #
        Hay dos reglas importantes que se aplican a todos los estados:
            1) Los hooks, solo se deben usar en componentes funcionales (functional components) o dentro de nuestros propios hooks personalizados.
            2) No podes usar un hook en una función anidada, siempre es en el componente root. Para que quede claro, esto no se puede hacer:

            const unaFuncion = () => {
                useState() -> usarlo acá adentro.
            }

    462. Passing State Data Across Components   
        Explica como hacer para agregar ingredientes y pasarselo al otro componente.
        O sea, modifica el componente de Ingredientes, donde:
        Agrega el componente IngredientList y le pasa por prop el esado con los ingredients.
        Agrega una función addIngredientHandler y se la pasa al componente IngedienteForm

    Tarea 6: Time to Practice: Hooks Basics
        Deje la solución por la mitad.

    463. Sending Http Requests
        Creó un nuevo proyecto en Firebase.
        va a usar fetch y agrega la url del nuevo proyecto, configura el metodo como post, un body de lo que queres enviar (data en formato json), le envia el ingrediente sin id porque ahora eso lo va a generar firebase.
        
        # IMPORTANTE #
        Explica que en fetch es obligatorio poner el header de app/json para que parsee eso a json, en axios no es necesario.

        response.json() -> toma el body y lo convierte a json.

    464. useEffect() & Loading Data

        https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures

        Solo sepuede usar en componentes funcionales, y en el componente root.

        Side effect, basicamente significa que tenes cierta logica que afecta a tu aplicación.
        Por ejemplo, que dentro de la función estemos llamando a algo que no se termine en este ciclo de renderización o talvez afecta algo que esta afuera del alcance del código jsx. 
        Por ejemplo setear el titulo del documento, algo así.

        useEffect se ejecuta después de que cada componente procesa su ciclo.
        O sea, después de que el componente donde se esta por usar se haya procesado por primera vez, la función que le pasas a useEffect, va a ser ejecutada.

        # IMPORTANTE # 
        Se ejecuta cada vez que el componente se vaya a re-renderizar.

        Dentro de la función useEffect, hace un llamado a firebase con un get, para obtener los ingredientes.
         crea una variable para ir pusheando los ingredientes, como un objeto .push({ title: , description: }) bla bla.

         si no se usa useEffect, pasanlo un array, al hacer un fetch, se actualiza el estado, y como cada vez que se actualiza el estado, se re-renderiza el componente, useEffect genera un loop infinito porque siempre hace el fetch y siempre re-renderiza el estado.

        A tener en cuenta: useEffect actua como componentDidUpdate().

        En useEffect el primer parametro es la función que se ejecuta después de cada ciclo de renderizado, la segunda es una array con las dependencias de esa función, o sea, que solo va a correr la función cuando sus dependencias cambien. Para que corra solo una vez se agrega el array vacio, que no necesita dependencias, por ende solo ejecuta una vez. 

    465. Understanding useEffect() Dependencies
        
        # IMPORTANTE #
        Se puede tener tantos useEffect como necesites, como useState.

        Si le pasamos una dependencia, useEffect va a correr solo cuando a esa dependencia se le cambie algo (State, props
        )
        
    466. More on useEffect()

        Va a usar useEffect para hacer un request a firebase cada vez que el usuario pulse una tecla.
        Por ende en vez de un array vacio, le pasa enteredFilter, que es el estado actualizado de las letras que se van escribiendo en el value.

        Al final de la llamada, usa props.onLoadIngredients(loadedIngredients), este ultimo es donde se va pusheando la info a cada respuesta del request.

        Así que le pasa al componente Search, la nueva prop onLoadIngredients={filteredIngredientsHandler}

        crea la funcion filteredIngredientsHandler, como props es una dependencia de useEffect, también hay que pasarla como parametro del array, pero como esto puede traer otros problemas, lo que se hace en realidad es oasar la funcion onLoadIngredients, y arriba de todo después de crearse la función, lo que se hace es extraer con destructuring, esa función de las props, const { onLoadIngredients } = props;
        Esto se hace para que useEffect se use solo cuando uno de los dos parametros que le psamos cambie.

        Firebase admite filtrado, así que arma una constante query con enteredFilter.lenght === 0 ? '' : `?orderBy="title"&equalTo="${enteredFilter}"

        eso se lo pasamos al final de la url en el fetch

        También hay que ir a rules, y habilitar filtering en firebase, ingredients: { ".indexOn": [ "title" ]}

        esto da un loop infinito, lo resuelve en el proximo video.

    467. What's useCallback()?
        
        Al re-renderizarse el componente, las funciones se vuelven a crear, es esto lo que esta causando el lopp infinito.

        Para prevenir esto, hay otro hook que se llama useCallback. 

        Nos permite envolver nuestra función y pasarle un 2do argumento con las dependencias del argumento, como nuestra funcion setUserIngredients, no tiene dependencias, entonces le especificamos a useCallback un array vacio, como useeffect.

         Lo que hace useCallback es cachear la función y que sobreviva a las re-renderizaciones, o sea, no se va a recrear la funcion cuando el componente se re-renderice.

         Si bien elimina el loop infinito en la solapa de network verifica porque hay 2 peticiones. 

         Una es para obtener los ingredientes, la otra es desde ingredientes.

    468. Working with Refs & useRef()
        
        Vamos a arreglar un problema, que es que cada vez que pulsamos una tecla se esta haciendo un request al servidor. 
        Lo que quiere hacer es que después de un tiempo especifico se envie la consulta y no todo el tiempo.

        Con useRef(), podemos generar una variable de referencia.

        EL PROBLEMA DE ESTO ES QUE ESTAMOS GENERANDO UN NUEVO TIMEOUT TODO EL TIEMPO, PORQUE SE ACTUALIZA EL ESTADO CADA VEZ QUE TECLEAMOS. Y PORQUE ESTAMOS PASANDO DEPENDENCIAS A USEEFFECT.
        
        
        const inputRef = useRef();

        useEffect(() => {
            setTimeout(() => {
            if (enteredFilter === inputRef.current.value) {
                const query =
                enteredFilter.length === 0
                    ? ''
                    : `?orderBy="title"&equalTo="${enteredFilter}"`;
                fetch(
                'https://react-hooks-update.firebaseio.com/ingredients.json' + query
                )
                .then(response => response.json())
                .then(responseData => {
                    const loadedIngredients = [];
                    for (const key in responseData) {
                    loadedIngredients.push({
                        id: key,
                        title: responseData[key].title,
                        amount: responseData[key].amount
                    });
                    }
                    onLoadIngredients(loadedIngredients);
                });
            }
            }, 500);
        }, [enteredFilter, onLoadIngredients, inputRef]);

    469. Cleaning Up with useEffect()
        Acá la función ya esta arreglada, la arreglaba en el proximo video.

        Como setTimeout es un puntero a la función de timer, la guarda en una variable para después limpiarla con la función clearTimeout.

        const timer = setTimeout(() => {
        if (enteredFilter === inputRef.current.value) {
            const query =
            enteredFilter.length === 0
                ? ''
                : `?orderBy="title"&equalTo="${enteredFilter}"`;
            fetch(
            'https://react-hooks-update.firebaseio.com/ingredients.json' + query
            )
            .then(response => response.json())
            .then(responseData => {
                const loadedIngredients = [];
                for (const key in responseData) {
                loadedIngredients.push({
                    id: key,
                    title: responseData[key].title,
                    amount: responseData[key].amount
                });
                }
                onLoadIngredients(loadedIngredients);
            });
        }
        }, 500);
        return () => {
        clearTimeout(timer);
        };

    470. Deleting Ingredients
        Actualiza la función de eliminar ingredientes, para que los elimine de firebase
        
        const removeIngredientHandler = ingredientId => {
            setIsLoading(true);
            fetch(
            `https://react-hooks-update.firebaseio.com/ingredients/${ingredientId}.json`,
            {
                method: 'DELETE'
            }
            )
            .then(response => {
                setIsLoading(false);
                // setUserIngredients(prevIngredients =>
                //   prevIngredients.filter(ingredient => ingredient.id !== ingredientId)
                // );
                dispatch({ type: 'DELETE', id: ingredientId });
            })
            .catch(error => {
                setError('Something went wrong!');
                setIsLoading(false);h
            });
        };

    471. Loading Errors & State Batching
        Para mostrar un loading, genera un estado solo para eso, la actualiza en el comienzo de la llamada y en el final.

        importa el ErrorModal y en el catch de fetch, setea el error en un nuevo estado que genera especificamente para eso. 

        De manera condicional utiliza el nuevo estado para verificar si tiene algo y sino muestra el modal, muestra un shortcut de ese if que es así:

        const clearError = () => {
            setError(null);
            setIsLoading(false)
        }

       {error && <ErrorModal onClose={clearError}>{error}</ErrorModal>}

        Explica que cuando hay 2 estados que se actualian al mismo tiempo, en realidad react lo que hace es acualizarlos de manera sincronica. O sea, uno por uno, pero después la actualización en si, se hace toda junta "de manera bath"
        De esta manera solo vamos a tener un solo evento de re-renderizado no dos.

    472. More on State Batching & State Updates
        React batches state updates - see: https://github.com/facebook/react/issues/10231#issuecomment-316644950

        That simply means that calling

        setName('Max');
        setAge(30);
        in the same synchronous (!) execution cycle (e.g. in the same function) will NOT trigger two component re-render cycles.

        Instead, the component will only re-render once and both state updates will be applied simultaneously.

        Not directly related, but also sometimes misunderstood, is when the new state value is available.

        Consider this code:

        console.log(name); // prints name state, e.g. 'Manu'
        setName('Max');
        console.log(name); // ??? what gets printed? 'Max'?
        You could think that accessing the name state after setName('Max'); should yield the new value (e.g. 'Max') but this is NOT the case. Keep in mind, that the new state value is only available in the next component render cycle (which gets scheduled by calling setName()).

        Both concepts (batching and when new state is available) behave in the same way for both functional components with hooks as well as class-based components with this.setState()!

    473. Understanding useReducer()
        Son funciones que toman algo y retornan algo. O sea, administran el/los estados y se encargan de retornarte uno.

        Un reducer se utiliza fuera del componente, ya que sino se estaría re-renderizando todo el tiempo. O sea, por fuera de la función (componente).

        state = que puede ser un estado en particular
        action = es la que se va a encargar de observar la acción y actualizar el estado.
        en el switch se maneja cada tipo a escuchar.

        const ingredientReducer = (state, action) => {
            switch(action.type){
                case 'ADD':
                    return action.ingredients;
                case 'SET':
                    return [...state, action.ingredient]; // esto depende que quieras hacer.
                case 'DELETE':
                    return currentIngridients.filter(ing => ing.id !== actions.id);
                default:
                    throw new Error("Should not get there");
            }
        }

        En el componente, debemos inicializar el reducer, utilizar la función useReducer()
        
        Le tenemos que pasar un estado incial en nuestro caso un array vacio porque la pimera vez el estado esta vacio.

        Es parecido a un state, primero el estado después la función que despacha cada acción. NO ES UN SET STATE.
        Se puede nombrar como se te canta.
        
        const [userIngredients, dispatch ] = useReducer(ingredientsReducer, [])

        Ahora todo lo que se manejaba por estado, se tiene que cambiar para usar reducer. O sea:
        
        Por ej:
        en vez de setUserIngrendients(filteredIngredients)

        Por:
        hay que pasarle un objeto a dispatch.

        dispatch({type: 'SET', ingredientes: filteredIngredients} )

        Las propiedades del objeto son las que utilizamos en el switch.-

        AL UTILIZAR USEREDUCER, EL COMPONENTE SOLO SE VA A RE-RENDERIZAR CUANDO ESTE RETORNE EL NUEVO ESTADO.

    474. Using useReducer() for the Http State
        Genera un reducer para los tipos de acciones al hacer algo http, como enviar, respuesta, error, etc:

        Solo manejamos estados, no es que vamos a hacer las llamadas ahí.
        
        const httpReducer = (curHttpState, action) => {
        switch (action.type) {
            case 'SEND':
            return { loading: true, error: null };
            case 'RESPONSE':
            return { ...curHttpState, loading: false };
            case 'ERROR':
            return { loading: false, error: action.errorMessage };
            case 'CLEAR':
            return { ...curHttpState, error: null };
            default:
            throw new Error('Should not be reached!');
        }
        };


         const [httpState, dispatchHttp] = useReducer(httpReducer, {
            loading: false,
            error: null
        });

        // const [isLoading, setIsLoading] = useState(false);
        // const [error, setError] = useState();

    475. Working with useContext()
        Crea una carpeta context (porque a el le gusta hacerlo así): de esta manera todos los componentes que esten envueltos en el componente AuthContext, van a "escuchar" las actualizaciones sobre los estados isAuth y login.

        auth-context.js
            import React, { useState } from 'react';

            export const AuthContext = React.createContext({
                isAuth: false,
                login: () => {}
            });

            const AuthContextProvider = props => {
                const [isAuthenticated, setIsAuthenticated] = useState(false);

                const loginHandler = () => {
                    setIsAuthenticated(true);
                };

                return (
                    <AuthContext.Provider
                    value={{ login: loginHandler, isAuth: isAuthenticated }}>
                        {props.children} // De esta manera decis que a este componente se le puede pasar cualquier otro componente, es un wrapper.
                    </AuthContext.Provider>
                );
            };

            export default AuthContextProvider;

        index.js

            <AuthContextProvider>
                <App />
            </AuthContextProvider>

        app.js
            En los componentes funionales, el contexto no se puede utilizar, deberíamos convertirlos a clases, pero, para no hacer eso, podemos usar el hoook useContext.

            import React, { useContext } from 'react';

            import Ingredients from './components/Ingredients/Ingredients';
            import Auth from './components/Auth';
            import { AuthContext } from './context/auth-context';

            const App = props => {
                const authContext = useContext(AuthContext);

                let content = <Auth />;
                if (authContext.isAuth) {
                    content = <Ingredients />;
                }

                return content;
            };

            export default App;

        Auth.js
            import React, { useContext } from 'react';

            import Card from './UI/Card';
            import { AuthContext } from '../context/auth-context';
            import './Auth.css';

            const Auth = props => {
            const authContext = useContext(AuthContext);

            const loginHandler = () => {
                authContext.login();
            };

            return (
                <div className="auth">
                <Card>
                    <h2>You are not authenticated!</h2>
                    <p>Please log in to continue.</p>
                    <button onClick={loginHandler}>Log In</button>
                </Card>
                </div>
            );
            };

            export default Auth;

        Cualquier cosa revisar la sección 7 donde explica mas sobre el contexto.

    476. Performance Optimizations with useMemo()

        Cuando el componente donde se aloja una función se re-renderiza, la función se vuelve a recrear, es por eso que necesitamos usar useCallback, para que no se recree nuevamente. No es que se  ejecuta, se vuelve a crear.

        useMemo es como useCallback pero con un valor. 

        Lo que hace es cortar el componente IngridientList y usa useMemo. Lo que hace es que React memoriza el valor que queres retornar, en este caso es un component.

        useMemo también tiene segundo parametro como useCallback, solo que le dice a React, cuando debe volver a ejecutar la función para crear un nuevo objeto que debe memorizar, entonces le pasamos las dependencias para que sepa cuando ese componente se tiene que re-renderizar, que es cuando cambian alguno de los dos, un estado y una prop.

        A veces hay que analizar sivale la pena usar react.memo o useCallback o useMemo, porque capaz que son cosas chicas y no valenla pena, porque el costo re-renderizado al de chequeo constante puede ser menos.

    477. Getting Started with Custom Hooks

        Crea una carpeta hooks y un el archivo http.js, crea un custom hooks, siempre hay que arrancar el nombre con useAlgo, va a ser una función, como cualquier otra.
        Podes usar cualquier hook dentro de tu custom hook.

        Si se usa en diferentes componentes, no es que van a compartir los datos, sino que cada componente va a tener un snapshot del hook. O sea que compartis logica, pero no los datos.

        No se importa React, porque no se esta haciendo un componente.
        
        https.js:
            import { useReducer, useCallback } from 'react';

            const httpReducer = (curHttpState, action) => {
                switch (action.type) {
                        case 'SEND':
                            return {
                                loading: true,
                                error: null,
                                data: null,
                                extra: null,
                                identifier: action.identifier
                            };
                        case 'RESPONSE':
                            return {
                                ...curHttpState,
                                loading: false,
                                data: action.responseData,
                                extra: action.extra
                            };
                        case 'ERROR':
                            return { loading: false, error: action.errorMessage };
                        case 'CLEAR':
                            return { ...curHttpState, error: null };
                        default:
                            throw new Error('Should not be reached!');
                }
            };

            const useHttp = () => {
                const [httpState, dispatchHttp] = useReducer(httpReducer, {
                    loading: false,
                    error: null,
                    data: null,
                    extra: null,
                    identifier: null
                })
            };

            const sendRequest = useCallback((url, method, body, reqExtra, reqIdentifer) => {
                dispatchHttp({ type: 'SEND', identifier: reqIdentifer });
                    fetch(url, {
                        method: method,
                        body: body,
                        headers: {
                        'Content-Type': 'application/json'
                        }
                    })
                    .then(response => {
                        return response.json();
                    })
                    .then(responseData => {
                        dispatchHttp({
                            type: 'RESPONSE',
                            responseData: responseData,
                            extra: reqExtra
                        });
                    })
                    .catch(error => {
                        dispatchHttp({
                            type: 'ERROR',
                            errorMessage: 'Something went wrong!'
                        });
                    });
                },
                []
            );

            return {
                    isLoading: httpState.loading,
                    data: httpState.data,
                    error: httpState.error,
                    sendRequest: sendRequest,
                    reqExtra: httpState.extra,
                    reqIdentifer: httpState.identifier
                };
            };

            export default useHttp;

    478. Sharing Data Between Custom Hooks & Components
        Volver a ver.

    479. Using the Custom Hook
        Muestra como usa el hook que creo en las llamadas http del proyecto.

    480. Wrap Up
    481. What's [LEGACY]?
    482. [LEGACY] What are Hooks?
    483. [LEGACY] Enabling Hooks
    484. [LEGACY] The useState() Hook
    485. [LEGACY] Adding Array Destructuring
    486. [LEGACY] Using Multiple State
    487. [LEGACY] Using One State Instead
    488. [LEGACY] The "Rules of Hooks"
    489. [LEGACY] Sending Data via Http
    490. [LEGACY] The useEffect() Hook
    491. [LEGACY] Controlling Effect Execution
    492. [LEGACY] Effect Cleanup
    493. [LEGACY] Converting the "App" Component
    494. [LEGACY] The useContext() Hook
    495. [LEGACY] State and Effects Gotchas
    496. [LEGACY] The useReducer() Hook
    497. [LEGACY] useReducer() vs useState()
    498. [LEGACY] Working with References and useRef()
    499. [LEGACY] Preparing & Optimizing
    500. [LEGACY] Avoiding Unnecessary Re-Rendering
    501. [LEGACY] How to think about Functional Components with Hooks
    502. [LEGACY] Creating a Custom Hook
    503. [LEGACY] Wrap Up

### Sección 27: Using Hooks in the Burger Builder

    504. Introduction

    505. Converting <App>

    506. Routing with React.lazy()

    507. Converting the Layout Component

    508. Converting withErrorHandler HOC
    
    509. Adjusting the Order & Checkout Containers

    510. Add Hooks to ContactData

    511. Converting the BurgerBuilder Container

    512. Adjusting Auth & Logout Components

    513. Using React.memo() & More!

    514. Adding a Custom Error Handling Hook

    515. Setting the right useEffect() Dependencies

    516. Working with useSelector() and useDispatch()

    517. Wrap Up
    518. Useful Resources & Links
        Official Hooks Docs: https://reactjs.org/docs/hooks-intro.html

        Recursos de esta clase
        hooks-prj-01-starting-project.zip
        hooks-prj-02-added-lazy-loading.zip
        hooks-prj-03-converted-hocs.zip
        hooks-prj-04-orders-contactdata.zip
        hooks-prj-05-burgerbuilder.zip
        hooks-prj-06-auth.zip
        hooks-prj-07-custom-error-handling-hook.zip
        hooks-prj-08-finished.zip

### Sección 28: Bonus: Replacing Redux with React Hooks

    519. Module Introduction
    520. Starting Project & Why You Would Replace Redux

        Hay dos approach uno bueno y uno que no debería usarse para cualquier opción.
        
    521. Alternative: Using the Context API

        La alternativa que no se debe usar siempre (o sea, para cualquier cosa).
        
        Crea una carpeta context > products-context.js
    
    522. Toggling Favorites with the Context API

    523. Context API Summary (and why NOT to use it instead of Redux)

    524. Getting Started with a Custom Hook as a Store

    525. Finishing the Store Hook

    526. Creating a Concrete Store

    527. Using the Custom Store

    528. Custom Hook Store Summary

    529. Optimizing the Custom Hook Store

    530. Bonus: Managing Multiple State Slices with the Custom Store Hook

    531. Wrap Up
    532. Useful Resources & Links
        Attached, you find the module source code.

        These resources might also be helpful:

        More on React Hooks: https://reactjs.org/docs/hooks-intro.html

        npm Custom Store Hook package: https://www.npmjs.com/package/use-global-hook

        Recursos de esta clase
        replace-redux-01-starting-project.zip
        replace-redux-02-use-context-api.zip
        replace-redux-03-started-work-on-custom-store-hook.zip
        replace-redux-04-finished-custom-hook.zip
        replace-redux-05-finished.zip
        replace-redux-06-bonus-multiple-slices.zip

### Sección 29: Bonus: Building the Burger CSS

    533. Building the Burger CSS Code
        Todo el video es sobre css y como crea el icono de hamburguesa, también esta el pdf adjunto: burger-css.pdf

### Sección 30: Next Steps and Course Roundup

    534. Module Introduction
        Practicar, practicar...

    535. React Rocks! Where to find more Examples
        http://react.rocks
        Tiene mas ejemplos, no necesariamente pueden estar bien codeados, pero tenes muchos ejemplos.

    536. More Inspiration: Real-World Projects Built with React
        build with react.
        es un repo de git que tenes un monton de opciones para elegir que hacer en react.

    537. Static React Apps with Gatsby.js
        sitios web staticos con react. 

    538. Introducing React Native
        ...
    539. Component Libraries (Example: Material UI)
        material-ui.com

    540. Smaller Apps with Preact
        mas liviano que react. no lo termine de ver

    541. Comparing React with Preact
        no lo vi.
    542. Congratulations
        ...
    543. Bonus: More Content!
        I got a lot of other high-quality & bestselling courses you might be interested in: https://academind.com/learn/our-courses/

        I'd love to welcome you on board of any of these courses! :-)

        Also don't forget to subscribe to my newsletter on https://academind.com/ to receive the latest updates and exclusive offers!

        And in case you didn't know: On the same page as well as on my YouTube channel I got loads of additional tutorials.

        Last but not least - I tweet on @maxedapps and on @academind_real, would love to see you there!